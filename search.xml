<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017年 最好的javascript 书籍]]></title>
    <url>%2F2017-best-js-books.html</url>
    <content type="text"><![CDATA[我看过三本，第1本，第二本，第四本。第一本买的的实体书，其他两本看的是电子书。第一本是大名鼎鼎老道写的，书很薄，但是非常经典。javascirpt忍者秘籍是jquery的作者写的，也是非常经典。you dont kown js系列也是非常好。看了收益匪浅。文章是谷歌翻译的，英文好的直接看原文吧。 原文：https://reactdom.com/blog/javascript-books 你不能是一个好的ReactJS，React Native或GraphQL开发人员，如果你没有很好地理解JavaScript。有太多的JavaScript书出来，每月出来更多。那么什么是最好的JavaScript书为你？经过多年的经历，这些是学习JavaScript的最好的JavaScript书。请记住，这些书中的一些可能不是最新的，但概念和基础仍应适用。我们将继续更新这个最好的JavaScript书籍的列表，还有书签，共享和定期检查！ JavaScript: The Good Parts《JavaScript语言精粹》 JavaScript：Douglas Crockford的Good Parts是JavaScript书籍历史中的一个重要版本，是每个JavaScript程序员都需要阅读的一本书。 Douglas Crockford是JSON，JSLint的创建者，并且对JavaScript的开发做出了许多贡献。 JavaScript：The Good Parts侧重于使JavaScript成为一个伟大的面向对象编程语言的想法。这些想法包括函数，对象，语法，符号等。不幸的是，这些好的想法与坏的和彻底的可怕的想法混在一起，如基于全局变量的编程模型。这本书将告诉你如何避免这些坏的部分，并使用好的部分来制作伟大的代码。 JavaScript：Good Parts将告诉你如何创建优雅的代码，而不管你使用JavaScript的方式。如果你为Web开发网站或应用程序，这本书是绝对必须的。你需要编写复杂的接口，做大量的计算和处理JS，就像它是面向对象的语言，这实际上是一个必读。 You Don’t Know JS《你不知道js》 你不知道JS通过Kyle Simpson是一个JavaScript系列的书，将显示你的JavaScript知识的差距，然后教你需要了解JavaScript的一切，以弥补这些差距。 Kyle Simpson是最好的JavaScript老师之一。任何认真对待JavaScript的人都应该注意凯尔的所有教义。 你不知道JS书籍处理JavaScript的棘手部分，以帮助你实现真正的JavaScript掌握。这些书的范围相似，涵盖了并不总是被理解的主题。你不知道JS是每个级别的开发人员的完美。这些书在范围上非常具体，这是它的最大优势。 你不知道JS书系列是所有JavaScript程序员的必须，所有的书是伟大的。短书的长度是一件伟大的事情，你可以快速完成，而不失去焦点。你不知道JS带有最高的建议。 JavaScript: The Definitive Guide《JavaScript权威指南》 JavaScript：David Flanagan的“绝对指南”是一本书，它肯定是一个非常沉重的标题，绝对是最好的JavaScript书籍之一。 David Flanagan在Mozilla工作，他的大部分时间都在编写编程书。 JavaScript：The Definitive Guide被分为两个部分，分别是讨论和引用。这两个部分中的每一个包含两个部分，核心和客户端。核心章节涵盖了数据类型，函数，类等语言特性。客户端章节涵盖了在浏览器中运行的JavaScript的使用。 JavaScript：The Definitive Guide包括基于作者现实世界经验的准确文档。 JavaScript：The Definitive Guide多年来一直有多个版本和更新。这是很好的理由;这本书总是在改进，作者总是参与新版本（缺乏许多JavaScript书籍的东西）。无论版本是什么，本书的基础和核心以及JavaScript保持不变。 JavaScript：The Definitive Guide是一个关于JavaScript的最终指南，从基础知识开始，一直到高级功能。 JavaScript：The Definitive Guide属于每个程序员的架子，不能被推荐足够。 Secrets of the JavaScript Ninja《JavaScript忍者秘籍》 JavaScript Ninja的秘密由John Resig，Bear Bibeault＆Josip Maras是一个JavaScript经典，将把你变成一个JavaScript忍者。 John Resig是jQuery库的创建者，Bear Bibeault是一名网络开发人员，Josip Maras是一位博士后研究员。 JavaScript Ninja的秘密由4部分组成。每个部分都集中在几个相关的话题，从基础到高级。包括的一些主题是功能，对象，原型，承诺等。本书有很多有用的摘要和练习。 JavaScript Ninja的秘密使用非常实用的例子清楚地说明每个核心概念和技术。 JavaScript Ninja的秘密还包括API，最佳实践，跨各种浏览器测试等。 JavaScript Ninja的秘密是非常精巧的写作，这是没有什么惊喜，因为作者在JavaScript非常有经验。 JavaScript Ninja的秘密推荐给任何想成为一个JavaScript忍者，这是每个人。 Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript 有效的JavaScript：68具体的方法来利用JavaScript的力量David Herman将教会你通过68提示和技巧写更好的JavaScript。 David Herman是Mozilla Research的首席研究员，在Ecma的JavaScript标准化委员会有多年的经验。 有效的JavaScript集中在68个不同的课程与示例，使你写更好的JavaScript。从基础到高级功能的一切都在详细讨论。要成为JavaScript的主人，您必须学习如何避免陷阱，并使用JavaScript的强大功能有效地工作。有效的JavaScript将帮助编写更好和可维护的代码，而不管您的JavaScript体验。 有效的JavaScript涵盖68个JavaScript原则到68个简短的课程，使它成为一个伟大的方式来学习JavaScript。 Effective JavaScript是一本推荐给所有级别的JavaScript程序员的书，不管它们有多忙。 JavaScript Patterns: Build Better Applications with Coding and Design Patterns JavaScript模式：使用编码和设计模式构建更好的应用程序Stoyan Stefanov教你JavaScript编码模式和最佳实践。 Stoyan Stefanov在雅虎工作，是YSlow 2.0的建筑师 JavaScript模式将引导您使用模式和反模式编写JavaScript。讨论了Singleton等经典设计模式，然后展示了如何在JavaScript中使用它们。讨论了编写高质量JavaScript代码和定义函数的不同和适当方法的伟大习惯。本书涵盖了大量的继承和代码重用技术。 JavaScript模式将教你从初学者到高级水平所需的一切。 JavaScript模式在JavaScript的教学模式以及详细的代码示例方面非常出色。这本书展示了你使用它教授的各种技术的优点和缺点。 JavaScript模式是一本关于开发JavaScript应用程序的精心编写的书，应该用作各级JavaScript开发人员的参考。 The Principles of Object-Oriented JavaScript Nicholas C. Zakas的面向对象JavaScript的原理探讨了JavaScript的面向对象的特性，并揭示了JavaScript如何使用继承和其他关键属性。 Nicholas C. Zakas是一位前端顾问，在他的主页，YUI等上与Yahoo广泛合作。 面向对象的JavaScript的原则遍历所有的方式在JavaScript中使用面向对象的原则。所有讨论的主题，如处理原型，对象，构造函数等。面向对象的JavaScript的原则涵盖了所有提供的解决方案的优点和缺点，同时深入地涵盖了主题。所有级别的JavaScript开发人员都将从阅读本书中获益良多，并编写更高效的代码。 面向对象的JavaScript的原则涵盖JavaScript的面向对象的方面，并且非常好。这本书的长度不算太大，所以它不会压倒你。如果你想使用JavaScript的面向对象的原则，面向对象的JavaScript的原则是为你。 Eloquent JavaScript: A Modern Introduction to Programming 雄辩的JavaScript：Marijn的现代编程介绍Haverbeke是一本关于JavaScript的惊人的书。这肯定是一本雄辩的书.Marijn Haverbeke在开源软件上工作，并创建了CodeMirror和Tern。 雄辩的JavaScript是所有关于编程。这本书专注于编程和所有的编程概念。雄辩的JavaScript是伟大的初学者，因为它假设没有以前的经验，从编程的基础开始。 雄辩的JavaScript使用一个非常集中的路线图，并充满了练习。 Eloquent JavaScript是一本伟大的书，可以启动JavaScript，并推荐给大家。 擅长JavaScript是一个需要是一个好的ReactJS开发人员。无论你在JavaScript中的专业水平，这些书将帮助你成为一个更好的JavaScript开发人员。不仅如此，他们还会让你成为一个更好的ReactJS和前端开发人员。在你完成这些书后，查看ReactJS书籍和最好的React本土书籍。]]></content>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：编写高质量javascript的68个方法]]></title>
    <url>%2F68-skills-to-write-better-js-code.html</url>
    <content type="text"><![CDATA[书还没看完。一遍看，一遍写读书笔记。 这本书的序是JavaScript之父Brendan Eich写的，作者是JavaScript标准化委员会专家。可想而知其质量如何。这本书不厚，和《JavaScript语言精粹》差不多厚，约等于4分之一的《JavaScript权威指南》的厚度。绝对值得一看。 本书赞誉本书的赞誉有来自Chrome开发主管，有来自JSHint的专家，还有一些行业大咖。 如果你想成为一名真正的JavaScript开发者, 那么请阅读这本书。就我来说，我多么希望在第一次开始JavaScript编程时就阅读它。—Anton Kovalyov, JSHint开发者 很少有人有机会同大师一起学习他们的手艺。这本书弥补了这种缺陷，其对JavaScript的研究就像随一位时间旅行哲学家回到公园前5世纪与柏拉图一起学习。—Rick Waldron, JavaScript传教士， Bocoup 让自己习惯JavaScript 有些人说不清哪里好，可就是谁也替代不了。 了解你使用的JavaScript的版本 理解JavaScript的浮点数当心隐式的强制类型转换原始类型优于封装对象避免对混合类型使用 == 运算符了解分号插入的局限视字符串为16位的代码单元序列变量与作用域 作用域对程序员来说就像氧气。它无处不在，甚至，你往往不会去想它。但当它被污染时，你会感觉到窒息。 尽量少使用全局对象 避免声明全局变量 尽量声明局部变量 避免对全局变量增加属性 始终声明局部变量避免使用with语句熟练使用闭包 JavaScript的函数值包含了比调用他们时执行所需要的代码还要更多的信息。而且，JavaScript函数值还在内部存储他们可能会引用的定义在其封闭作用域的变量。那些在其所涵盖的作用域内跟踪变量的函数称为闭包。 JavaScript允许你引用在当前函数以外定义的变量 即使外部函数已经返回，当前函数仍然可以引用外部函数定义的变量 闭包可以更新外部函数的值 理解变量声明提升使用立即调用表达式创建局部作用域当心命名函数表达式笨拙的作用域当心局部块函数声明笨拙的作用域避免使用evel创建局部变量间接调用eval函数函数优于直接调用]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高级技巧]]></title>
    <url>%2Fjs-high-skills.html</url>
    <content type="text"><![CDATA[安全类型检测 javascript内置类型检测并不可靠 safari某些版本（&lt;4）typeof正则表达式返回为function 建议使用Object.prototype.toString.call()方法检测数据类型12345678910111213141516function isArray(value)&#123; return Object.prototype.toString.call(value) === "[object Array]";&#125;function isFunction(value)&#123; return Object.prototype.toString.call(value) === "[object Function]";&#125;function isRegExp(value)&#123; return Object.prototype.toString.call(value) === "[object RegExp]";&#125;function isNativeJSON()&#123; return window.JSON &amp;&amp; Object.prototype.toString.call(JSON) === "[object JSON]";&#125; 对于ie中一COM对象形式实现的任何函数，isFunction都返回false，因为他们并非原生的javascript函数。 在web开发中，能够区分原生与非原生的对象非常重要。只有这样才能确切知道某个对象是否有哪些功能 以上所有的正确性的前提是：Object.prototype.toString没有被修改过 作用域安全的构造函数123456789function Person(name)&#123; this.name = name;&#125;//使用new来创建一个对象var one = new Person('wdd');//直接调用构造函数Person(); 由于this是运行时分配的，如果你使用new来操作，this指向的就是one。如果直接调用构造函数，那么this会指向全局对象window,然后你的代码就会覆盖window的原生name。如果有其他地方使用过window.name, 那么你的函数将会埋下一个深藏的bug。 ==那么，如何才能创建一个作用域安全的构造函数？==方法112345678function Person(name)&#123; if(this instanceof Person)&#123; this.name = name; &#125; else&#123; return new Person(name); &#125;&#125; 惰性载入函数假设有一个方法X，在A类浏览器里叫A,在b类浏览器里叫B,有些浏览器并没有这个方法,你想实现一个跨浏览器的方法。 惰性载入函数的思想是：在函数内部改变函数自身的执行逻辑 12345678910111213function X()&#123; if(A)&#123; return new A(); &#125; else&#123; if(B)&#123; return new B(); &#125; else&#123; throw new Error('no A or B'); &#125; &#125;&#125; 换一种写法12345678910111213141516171819function X()&#123; if(A)&#123; X = function()&#123; return new A(); &#125;; &#125; else&#123; if(B)&#123; X = function()&#123; return new B(); &#125;; &#125; else&#123; throw new Error('no A or B'); &#125; &#125; return new X();&#125; 防篡改对象不可扩展对象 Object.preventExtensions1234567891011// 下面代码在谷歌浏览器中执行&gt; var person = &#123;name: 'wdd'&#125;;undefined&gt; Object.preventExtensions(person);Object &#123;name: "wdd"&#125;&gt; person.age = 1010&gt; personObject &#123;name: "wdd"&#125;&gt; Object.isExtensible(person)false 密封对象Object.seal密封对象不可扩展，并且不能删除对象的属性或者方法。但是属性值可以修改。123456789101112&gt; var one = &#123;name: 'hihi'&#125;undefined&gt; Object.seal(one)Object &#123;name: "hihi"&#125;&gt; one.age = 1212&gt; oneObject &#123;name: "hihi"&#125;&gt; delete one.namefalse&gt; oneObject &#123;name: "hihi"&#125; 冻结对象 Object.freeze最严格的防篡改就是冻结对象。对象不可扩展，而且密封，不能修改。只能访问。 高级定时器函数节流函数节流的思想是：某些代码不可以没有间断的连续重复执行12345678910111213141516171819202122var processor = &#123; timeoutId: null, // 实际进行处理的方法 performProcessing: function()&#123; ... &#125;, // 初始化调用方法 process: function()&#123; clearTimeout(this.timeoutId); var that = this; this.timeoutId = setTimeout(function()&#123; that.performProcessing(); &#125;, 100); &#125;&#125;// 尝试开始执行processor.process(); 中央定时器页面如果有十个区域要动态显示当前时间，一般来说，可以用10个定时来实现。其实一个中央定时器就可以搞定。 中央定时器动画 demo地址：http://wangduanduan.coding.me/my-all-demos/ninja/center-time-control.html 1234567891011121314151617181920212223242526272829var timers = &#123; timerId: 0, timers: [], add: function(fn)&#123; this.timers.push(fn); &#125;, start: function()&#123; if(this.timerId)&#123; return; &#125; (function runNext()&#123; if(timers.timers.length &gt; 0)&#123; for(var i=0; i &lt; timers.timers.length ; i++)&#123; if(timers.timers[i]() === false)&#123; timers.timers.splice(i, 1); i--; &#125; &#125; timers.timerId = setTimeout(runNext, 16); &#125; &#125;)(); &#125;, stop: function()&#123; clearTimeout(timers.timerId); this.timerId = 0; &#125; &#125;; 参考书籍：《javascript高级程序设计》《javascript忍者秘籍》]]></content>
  </entry>
  <entry>
    <title><![CDATA[从一个小场景学会使用 apply方法]]></title>
    <url>%2Fhow-to-use-apply.html</url>
    <content type="text"><![CDATA[需求 需要自定义一个log方法，这个方法可以像原生的console.log一样 在开发环境我希望调用这个log会输出日志信息，生产环境我希望即使调用了这个方法，也不会输出日志信息。 实现这个log 可能要使用apply或者call方法 log的参数个数和类型都是不固定的 call的参数个数是固定的，要排除它 apply的参数是需要一个数组，这个合适，可以使用arguments来当做数组传递 代码12345678var MyLog = &#123; silent: false, log: function()&#123; if(!this.silent)&#123; console.log.apply(this, arguments); &#125; &#125;&#125;; 试用123456789&gt; MyLog.log(1,2,3, '4545');1 2 3 "4545"undefined&gt; MyLog.silent = truetrue&gt; MyLog.log(1,2,3, '4545');undefined 后记 不要随处使用console.log，因为这样当你不需要日志输出的时候，你就要到处填坑了 不要使用alert，这个很烦人]]></content>
  </entry>
  <entry>
    <title><![CDATA[突然觉得自己好像没学过JS]]></title>
    <url>%2Fi-realy-dont-know-js.html</url>
    <content type="text"><![CDATA[先看题：mean的值是什么？123456789var scores = [10,11,12];var total = 0;for(var score in scores)&#123; total += score;&#125;var mean = total/scores.length;console.log(mean); 是11？恭喜你：答错了！ 是1？恭喜你：答错了！ 正确答案： 4解释： for in 循环循环的值永远是key, key是一个字符串。所以total的值是：’0012’。它是一个字符串，字符串’0012’/3,0012会被转换成12，然后除以3，结果是4。 后记这个示例是来自《编写高质量JavaScript的68个方法》的第49条：数组迭代要优先使用for循环而不是for in循环。既然已经发布，就可能有好事者拿出去当面试题。这个题目很有可能坑一堆人。其中包括我。 这里涉及到许多js的基础知识. for in 循环是循环对象的索引属性，key是一个字符串。 数值类型和字符串相加，会自动转换为字符串 字符串除以数值类型，会先把字符串转为数值，最终结果为数值 正确方法123456789var scores = [10,11,12];var total = 0;for(var i=0, n=scores.length; i &lt; n; i++)&#123; total += scores[i];&#125;var mean = total/scores.length;console.log(mean); 这样写有几个好处。 循环的终止条件简单且明确 即使在循环体内修改了数组，也能有效的终止循环。否则就可能变成死循环。 编译器很难保证重启计算scores.length是安全的。 提前确定了循环终止条件，避免多次计算数组长度。这个可能会被一些浏览器优化。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI大全：前端UI框架集合（持续更新）]]></title>
    <url>%2Fall-best-ui-frame.html</url>
    <content type="text"><![CDATA[更新UI选择务必慎重，货比三家。 弱水三千只取一瓢：弱水三千只取一瓢，源起佛经中的一则故事，警醒人们在一生中可能会遇到很多美好的东西，但只要用心好好把握住其中的一样就足够了 😊😊😊😊欢迎贡献😊😊😊😊 2017-1209 ZanUI (Vue) 2017-1218 Onsen UI(Vue, React, Angular) 2017-1215 增加 Vuetify, Weex UI, Semantic UI React,element-react, element-angular,NG-ZORRO 2017-1214 增加 Mint UI 2017-1211 增加 Layui, UIkit 2017-1206 增加 cube-ui, Amaze ui React 除了老牌构建于jQuery框架之上的UI外, 新锐UI派系： 基于Vue: ELementUI, iViewui 基于React: AntDesign, Amaze UI React 移动端WeUI 来自：腾讯 WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。详情 SUI Mobile 来自：阿里 SUI Mobile 是一套基于 Framework7 开发的UI库。它非常轻量、精美，只需要引入我们的CDN文件就可以使用，并且能兼容到 iOS 6.0+ 和 Android 4.0+，非常适合开发跨平台Web App。轻量的UI库SUI Mobile 非常轻量，核心库压缩Gzip后的JS、CSS网络传输体积总共只有52K，却提供了20+个常用的组件。详情 Amaze ~ 妹子 UI 中国首个开源 HTML5 跨屏前端框架 详情 Amaze UI 以移动优先（Mobile first）为理念，从小屏逐步扩展到大屏，最终实现所有屏幕适配，适应移动互联潮流。 Amaze UI 含近 20 个 CSS 组件、20 余 JS 组件，更有多个包含不同主题的 Web 组件，可快速构建界面出色、体验优秀的跨屏页面，大幅提升开发效率。 相比国外框架，Amaze UI 关注中文排版，根据用户代理调整字体，实现更好的中文排版效果；兼顾国内主流浏览器及 App 内置浏览器兼容支持。 Amaze UI 面向 HTML5 开发，使用 CSS3 来做动画交互，平滑、高效，更适合移动设备，让 Web 应用更快速载入。 jQuery mobile jQuery移动是一个基于html5的用户界面系统,为响应web站点和应用程序都可以访问所有的智能手机,平板电脑和桌面设备而设计。详情 Framework7 Framework7 是一个开源免费的框架可以用来开发混合移动应用（原生和HTML混合）或者开发 iOS &amp; Android 风格的WEB APP。也可以用来作为原型开发工具，可以迅速创建一个应用的原型。详情 Framework7 最主要的功能是可以使用HTML、CSS和JS来开发iOS7应用。Framework7 是完全免费开源的。 Framework7 并不能兼容所有的设备。她只专注于为 iOS 和 Google Material 设计提供最好的体验。 如果你想开发 iOS 或者 Android 混合应用（Phonegap）或者你想开发 iOS 和 Google Material 风格的WEB APP，那么Framework7将会是你的首选。 cube-ui（Vue）cube-ui 是由滴滴开源的基于 Vue.js 实现的移动端组件库。 详情 ● 质量可靠：由滴滴内部组件库精简提炼而来，历经考验，并且每个组件都有充分单元测试，为后续集成提供保障。● 体验极致：以迅速响应、动画流畅、接近原生为目标，在交互体验方面追求极致。● 标准规范：遵循统一的设计交互标准，高度还原设计效果；接口标准化，统一规范使用方式，开发更加简单高效。● 扩展性强：支持按需引入和后编译，轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。 Mint UI (Vue)基于 Vue.js 的移动端组件库 详情 Weex UI (Vue)一个基于 Weex 的富交互、轻量级、高性能的 UI 组件库 详情 Onsen UI(Vue, React, Angular)最偏亮高效的开发HTML5应用和WEB apps, 支持angular, vue ,react, 详情 PC端EasyUI easyui是一种基于jQuery的用户界面插件集合。easyui为创建现代化，互动，JavaScript应用程序，提供必要的功能。详情 使用easyui你不需要写很多代码，你只需要通过编写一些简单HTML标记，就可以定义用户界面。 easyui是个完美支持HTML5网页的完整框架。 easyui节省您网页开发的时间和规模。 easyui很简单但功能强大的。 Bootstrap 简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。详情 jQuery UI jQuery UI 是建立在 jQuery JavaScript 库上的一组用户界面交互、特效、小部件及主题。无论您是创建高度交互的 Web 应用程序还是仅仅向窗体控件添加一个日期选择器，jQuery UI 都是一个完美的选择。jQuery UI 包含了许多维持状态的小部件（Widget），因此，它与典型的 jQuery 插件使用模式略有不同。所有的 jQuery UI 小部件（Widget）使用相同的模式，所以，只要您学会使用其中一个，您就知道如何使用其他的小部件（Widget）。详情 SUI SUI 是一套基于bootstrap开发的前端组件库，同时她也是一套设计规范。通过SUI，可以非常方便的设计和实现精美的页面。详情 ZUI 一个基于 Bootstrap 深度定制开源前端实践方案，帮助你快速构建现代跨屏应用。详情 Plane UI HTML5 跨终端响应式前端界面框架详情 Semantic UI Semantic UI 是一款语义化设计的前端开源框架，其功能强大，使用简单，为设计师和开发师提供可复用的完美设计方案。详情 materialize 基于谷歌material design设计的框架详情 ElementUI （Vue）Element由饿了吗团队开源，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的组件库，提供了配套设计资源，帮助你的网站快速成型。详情 iviewui （Vue）一套基于 Vue.js 的高质量 UI 组件库 详情 ANT DESIGN (React)一套企业级的 UI 设计语言和 React 实现。https://ant.design/index-cn 提炼自企业级中后台产品的交互语言和视觉风格。 开箱即用的高质量 React 组件。 使用 TypeScript 构建，提供完整的类型定义文件。 基于 npm + webpack + dva 的企业级开发框架。 MDUIMDUI 是一套基于 Material Design 的前端框架。轻量级、多主题切换、响应式、无依赖。http://www.mdui.org/ Amaze UI React (React)基于 React.js 开发的 Web 组件库 详情 Layui layui（谐音：类UI) 是一款采用自身模块规范编写的前端 UI 框架，遵循原生 HTML/CSS/JS 的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到 API 的每一处细节都经过精心雕琢，非常适合界面的快速开发。layui 首个版本发布于2016年金秋，她区别于那些基于 MVVM 底层的 UI 框架，却并非逆道而行，而是信奉返璞归真之道。准确地说，她更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。 详情 UIkit 轻量级模块化前端框架 详情 Vuetify (Vue)基于vue2的material风格组件化框架 详情 Semantic UI React(React)The official Semantic-UI-React integration. detail jQuery Free Declarative API Augmentation Shorthand Props Sub Components Auto Controlled State element-react (React)element ui的react版本 详情 element-angular (angular)element ui的react版本 详情 NG-ZORRO (angular)这里是 Ant Design 的 Angular^5.0.0 实现，开发和服务于企业级后台产品。 详情 3 PC &amp; 移动端3.1 ZanUI (Vue) Vant ( \ˈvænt\ ) 是有赞前端团队基于有赞统一的规范实现的 Vue 组件库，提供了一整套 UI 基础组件和业务组件。 详情 48+ 个经过有赞线上业务检验的组件 单测覆盖率超过 90% 完善详实的 中英文文档 专门的设计师团队维护视觉规范，统一而优雅 支持 babel-plugin-import 支持 TypeScript]]></content>
      <tags>
        <tag>ui</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发常用工具网站]]></title>
    <url>%2Ffront-end-common-websit.html</url>
    <content type="text"><![CDATA[性能测试 PageSpeed Insights 查询浏览器支持: caniuse 文档查询: W3C 浏览器调试：chrome-devtools 工具箱: bejson]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue+websocket+stompjs 实时监控坐席状态demo]]></title>
    <url>%2Fvue-ws-monitor-agent-status.html</url>
    <content type="text"><![CDATA[由于是前后端分离的demo, 程序的后端我不管，我只负责把前端做好，这只是个demo， 还有很多不完善的地方。 2018-01-09新增：后端的MQ事件结构现在也改了，该demo只能看看了。 html1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;table class="table" id="event-queue"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;当前状态&lt;/th&gt; &lt;th&gt;状态改变时间&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;工号&lt;/th&gt; &lt;th&gt;分机号&lt;/th&gt; &lt;th&gt;对方号码&lt;/th&gt; &lt;th&gt;呼入数&lt;/th&gt; &lt;th&gt;呼出数&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="item in eventQueue"&gt; &lt;td&gt;&#123;&#123;item.agentStatus | transAgentStatus&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.agentStatusTime&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.userName&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.loginName&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.deviceId&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &lt;script src="http://cdn.bootcss.com/vue/1.0.26/vue.js"&gt;&lt;/script&gt; &lt;script src="js/websocket-suport.min.js"&gt;&lt;/script&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159var tm = (function()&#123; var App = function()&#123;&#125;; var app = App.prototype; var config = &#123; dest: 'http://xxx.xxx.xxx.xxx:58080/mvc/stomp', topic: '/topic/csta/namespace/testwdd2.com' // topic: '/topic/csta/device/8002@testwdd2.com' &#125;; var eventQueue = []; var vm = new Vue(&#123; el:'#event-queue', data:&#123; eventQueue: eventQueue &#125; &#125;); Vue.filter('transAgentStatus', function(status)&#123; switch(status)&#123; case 'NotReady': return '未就绪'; case 'WorkNotReady': return '话后处理状态'; case 'Idle': return '就绪'; case 'OnCallIn': return '呼入通话'; case 'OnCallOut': return '呼出通话'; case 'Logout': return '登出'; case 'Ringing': return '振铃'; case 'OffHook': return '摘机'; case 'CallInternal': return '内部通话'; case 'Dailing': return '外线已经振铃'; case 'Ringback': return '回铃'; case 'Conference': return '会议'; case 'OnHold': return '保持'; case 'Other': return '其他'; &#125; return ''; &#125;); /** * [render description] * @Author Wdd * @DateTime 2016-12-26T16:06:16+0800 * @param &#123;[string]&#125; tpl [模板字符串] * @param &#123;[object]&#125; data [data对象] * @return &#123;[string]&#125; [渲染后的字符串] */ app.render = function(tpl,data)&#123; var re = /&#123;&#123;([^&#125;]+)?&#125;&#125;/g; while(match = re.exec(tpl))&#123; tpl = tpl.replace(match[0],data[match[1]] || ''); &#125; return tpl; &#125;; app.initWebSocket = function(dest, topic)&#123; dest = dest || config.dest; topic = topic || config.topic; var socket = new SockJS(dest); var ws = Stomp.over(socket); ws.connect(&#123;&#125;, function(frame) &#123; ws.subscribe(topic, function(event) &#123; // var eventInfo = JSON.parse(event.body); app.handerEvent(JSON.parse(event.body)); &#125;); &#125;, function(frame) &#123; console.log(frame); console.error(new Date() + 'websocket失去连接'); &#125;); &#125;; /** * [findAgentIndex description] * @Author Wdd * @DateTime 2016-12-28T10:34:13+0800 * @param &#123;[string]&#125; agentId [description] * @return &#123;[int]&#125; [description] */ app.findAgentIndex = function(agentId)&#123; for(var i = eventQueue.length - 1; i &gt;= 0; i--)&#123; if(eventQueue[i].agentId === agentId)&#123; return i; &#125; &#125; return -1; &#125;; /** * [handerEvent 处理websocket事件] * @Author Wdd * @DateTime 2016-12-28T10:33:03+0800 * @param &#123;[object]&#125; data [description] * @return &#123;[type]&#125; [description] */ app.handerEvent = function(data)&#123; if(data.eventType === 'CallEvent')&#123; return; &#125; if(!data.eventSrc)&#123; return; &#125; var eventItem = &#123; agentStatus: '', eventName: data.eventName, agentId: '', loginName: '', userName: '', deviceId: data.deviceId, agentStatusTime: '' &#125;; var agent = data.eventSrc.agent || ''; if(agent)&#123; eventItem.agentId = agent.agentId; eventItem.loginName = agent.loginName; eventItem.userName = agent.userName; eventItem.agentStatus = agent.agentStatus; eventItem.agentStatusTime = agent.agentStatusTime; &#125; // 针对登出事件的agentId在外层 else if(data.agentMode)&#123; eventItem.agentStatus = data.agentMode; eventItem.agentId = data.agentId; &#125; else if(data.agentStatus)&#123; eventItem.agentStatus = data.agentStatus; &#125; if(!eventItem.agentId)&#123; return; &#125; var itemIndex = app.findAgentIndex(eventItem.agentId); // 新的座席加入 if(itemIndex === -1)&#123; eventQueue.push(eventItem); &#125; // 更新已有座席的状态 else&#123; eventQueue[itemIndex].agentStatus = eventItem.agentStatus; eventQueue[itemIndex].agentStatusTime = eventItem.agentStatusTime; eventQueue[itemIndex].eventName = eventItem.eventName; &#125; &#125;; return new App();&#125;)(); 打开控制台，输入tm.initWebsocket()后，websocket连接正常。 之后坐席状态改变，可以看到有事件推送过来。 看下整个页面： 最后，这个小小的监控如果用jQuery写，也可以，不过就是太坑了，每次都要去找到Dom元素，再更新DOM，用了Vue这类的框架，页面的dom操作完全不用关心了，真是太舒服了。\(^o^)/ 关于stomp的重连程序后服务端使用RabbitMQ这里我直接引用我的另一个项目的部分代码，这个没有使用SockJS， 直接使用浏览器原生的WebSocket。重连的原理很简单，就是检测到断开时，去调用我的reconnectWs方法，这里我也做了重连的次数限制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109initWebSocket: function(callback, errorCallback) &#123; callback = callback || function()&#123;&#125;; if(ws &amp;&amp; ws.connected)&#123; return; &#125; Config.isManCloseWs = false; var url = Config.wsProtocol + Config.SDK + Config.eventPort + Config.eventBasePath + "/websocket"; if(typeof WebSocket != 'function')&#123; alert('您的浏览器版本太太太老了，请升级你的浏览器到IE11，或使用任何支持原生WebSocket的浏览器'); return; &#125; try&#123; var socket = new WebSocket(url); &#125; catch(e)&#123; console.log(e); return; &#125; var wsHeartbeatId = ''; ws = Stomp.over(socket); if(!Config.useWsLog)&#123; ws.debug = null; &#125; ws.connect(&#123;&#125;, function(frame) &#123; Config.currentReconnectTimes = 0; var dest = Config.newWsTopic + env.loginId.replace(/\./g,'_'); var lastEventSerial = ''; ws.subscribe(dest, function(event) &#123; var eventInfo = &#123;&#125;; try&#123; eventInfo = JSON.parse(event.body); delete eventInfo.params; delete eventInfo._type; delete eventInfo.topics; &#125; catch(e)&#123; console.log(e); return; &#125; if(lastEventSerial === eventInfo.serial)&#123; util.error('Error: event repeat sent !'); return; &#125; else&#123; lastEventSerial = eventInfo.serial; &#125; if(Config.useEventLog)&#123; util.debugout.log(' ' + JSON.stringify(eventInfo)); &#125; eventHandler.deliverEvent(eventInfo); &#125;); callback(); &#125;, function(frame) &#123; // websocket upexpected disconnected // maybe network disconnection, or browser in offline // this condition will emit wsDisconnected event if(Config.isManCloseWs)&#123;return;&#125; errorCallback(); util.log(frame); util.error(new Date() + 'websocket disconnect'); // clearInterval(wsHeartbeatId); if(Config.currentReconnectTimes &lt; Config.maxReconnectTimes)&#123; Config.currentReconnectTimes++; util.reconnectWs(); &#125; else&#123; var errorMsg = &#123; eventName: 'wsDisconnected', msg: 'websocket disconnect' &#125;; wellClient.ui.main(&#123; eventName:'wsDisconnected' &#125;); util.debugout.log('&gt;&gt;&gt; websocket disconnect'); wellClient.triggerInnerOn(errorMsg); &#125; &#125;); &#125;, reconnectWs: function()&#123; setTimeout(function()&#123; util.log('&gt;&gt;&gt; try to reconnect'); util.debugout.log('&gt;&gt;&gt; try to reconnect'); util.initWebSocket(function()&#123;&#125;,function()&#123;&#125;); &#125;, Config.timeout * 1000); &#125;, 参考 STOMP Over WebSocket]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>WebSocket</tag>
        <tag>stompjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自从装了windows神器，再也不用羡慕mac了]]></title>
    <url>%2Fwindows-powerful-tools.html</url>
    <content type="text"><![CDATA[命令行神器GOW Gow（Gnu On Windows）是Cygwin的轻量级替代品。 它使用一个方便的NSIS安装程序，安装超过100个非常有用的开源UNIX应用程序，编译为本机win32二进制文件。 它被设计为尽可能小，大约18 MB，而不是Cygwin，它可以运行超过100 MB根据选项。 强烈推荐 ConEmu 非常强大，可以在里面愉快的ctrl+v,ctrl+c用过你才知道好用https://conemu.github.io/ 搜索神器Wox Windows下一款最接近 Alfred 的软件启动/文件搜索利器 Everything 快速批量查找文件的利器 包管理神器Chocolatey 安装软件再也不用烦恼教程 健康管理神器f.lux 有没有注意到人们在夜间发短信的怪异蓝色发光？或者醒来准备写下一个伟大的想法，并被你的电脑屏幕蒙蔽？白天，电脑屏幕看起来很好，他们的设计看起来像太阳。但是，在晚上9点，晚上10点或凌晨3点，你可能不应该看太阳。f.lux修复这个：它使你的电脑显示器的颜色适应一天的时间，在夜间温暖和白天喜欢阳光。甚至有可能你因为你的电脑而停滞太晚。你可以使用f.lux因为它使你睡得更好，或者你可以只使用它，只是因为它使你的电脑看起来更好。 谷歌浏览器插件神器强烈推荐vimium 速度起飞，只用键盘就可以完全操纵谷歌浏览器 shortKeys vimium的快捷键其实已经足够多了，但是如果你想有更多自定义的快捷键，例如：关闭右侧的标签页，这个快捷键。你可以试试shortKeys。唯一遗憾的是，这里面也没有关闭其他标签页的快捷键，如果你知道有哪些工具可以做到，麻烦请告诉我。 5.3 infinity新标签页 参考 http://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/ http://www.jeffjade.com/2015/10/19/2015-10-18-Efficacious-win-software/ https://www.zhihu.com/question/22919326 https://blogs.msdn.microsoft.com/scott_hanselman/2013/07/31/windows/]]></content>
      <tags>
        <tag>windows</tag>
        <tag>神器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发起Ajax请求当页面onunload]]></title>
    <url>%2Fsend-ajax-when-page-unload.html</url>
    <content type="text"><![CDATA[1 同步Ajax 这种需求主要用于当浏览器关闭，或者刷新时，向后端发起Ajax请求。 123window.onunload = function()&#123; $.ajax(&#123;url:"http://localhost:8888/test.php?", async:false&#125;);&#125;; 使用async：false参数使请求同步（默认是异步的）。 同步请求锁定浏览器，直到完成。 如果请求是异步的，页面只是继续卸载。 它足够快，以至于该请求甚至没有时间触发。服务端很可能收不到请求。 2 navigator.sendBeacon优点：简洁、异步、非阻塞缺点：这是实验性的技术，并非所有浏览器都支持。其中IE和safari不支持该技术。 示例：12345window.addEventListener('unload', logData, false);function logData() &#123; navigator.sendBeacon("/log", analyticsData);&#125; 参考：http://stackoverflow.com/questions/1821625/ajax-request-with-jquery-on-page-unload参考：https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon]]></content>
      <tags>
        <tag>ajax</tag>
        <tag>onunload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongo DB增删改查命令概要]]></title>
    <url>%2Fmongodb-api-overview.html</url>
    <content type="text"><![CDATA[1 列出并选用1.1 列出所有数据库123&gt; show dbs local 0.000GBmyblog 0.000GB 1.2 使用某个数据库12&gt; use myblogswitched to db myblog 1.3 列出所有集合123456&gt; show collectionsarticlesreplicationColletionsessionsuserswangduanduan 2 插入数据 insert(value)1234567// 在已经存在的集合中插入数据&gt; db.users.insert(&#123;name:'hh',age:23&#125;)Inserted 1 record(s) in 43ms// 在不存在的集合中插入数据,集合不存在则自动创建集合并插入&gt; db.students.insert(&#123;name:'hh',age:23&#125;)Inserted 1 record(s) in 72ms 3 查询 find(option)3.1 查询集合里所有的文档12345678910111213141516171819202122232425262728&gt; db.users.find()/* 1 */&#123; "_id" : ObjectId("583e908453be942d0c5419dc"), "login_name" : "wangduanduan", "password" : "wrong age"&#125;/* 2 */&#123; "_id" : ObjectId("583ed2a5cc9a937db049616d"), "login_name" : "hh", "password" : "sdfsdf"&#125;/* 3 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125;/* 4 */&#123; "_id" : ObjectId("583fb707b12f8b7a7aa37573"), "name" : "hh", "age" : 23.0&#125; 3.2 按条件查询文档1234567&gt; db.users.find(&#123;name:'wangduanduan'&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125; 注意12345678910111213// 这是错的，查不到结果&gt; db.users.find(&#123;_id:'583fb2e9b12f8b7a7aa37572'&#125;)Fetched 0 record(s) in 1ms// 这是正确的&gt; db.users.find(&#123;_id:ObjectId('583fb2e9b12f8b7a7aa37572')&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125; 3.3 查询集合内文档的个数12&gt; db.users.count()4 3.4 比较运算符 $gt: 大于 $gte: 大于等于 $lt: 小于 $lte: 小于等于 $ne: 不等于 123456789// 查询用户里年龄大于30岁的人， 其他条件以此类推&gt; db.user.find(&#123;age:&#123;$gt:30&#125;&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125; 3.5 逻辑运算符3.5.1 与12345678// 查询名字是wangduanduan,age=34的用户&gt; db.users.find(&#123;name:'wangduanduan',age:34&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125; 3.5.2 $in 或12345678// 查询名字是wangduanduan,或hh的用户&gt; db.users.find(&#123;name:&#123;$in:['wangduanduan','hh']&#125;&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125; 3.5.3 $nin 非123456789101112131415// 查询名字不是wangduanduan或者hh的用户&gt; db.users.find(&#123;name:&#123;$nin:['wangduanduan','hh']&#125;&#125;)/* 1 */&#123; "_id" : ObjectId("583e908453be942d0c5419dc"), "login_name" : "wangduanduan", "password" : "wrong age"&#125;/* 2 */&#123; "_id" : ObjectId("583ed2a5cc9a937db049616d"), "login_name" : "hh", "password" : "sdfsdf"&#125; 3.6 正则匹配123456789101112131415// 查询名字是中含有duan的用户&gt; db.users.find(&#123;name:/duan/&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125;/* 2 */&#123; "_id" : ObjectId("583fc919b12f8b7a7aa37575"), "name" : "wangduanduan", "age" : 45.0&#125; 3.7 大招$where1234// 返回含有login_name字段的文档db.getCollection('users').find(&#123;$where:function()&#123; return !!this.login_name;&#125;&#125;) 4 更新 update();4.1 整体更新12&gt; db.users.update(&#123;login_name:'wangduanduan'&#125;,&#123;name:'heihei',age:34&#125;)Updated 1 existing record(s) in 116ms 4.2 $set 局部更新12// 只是将用户年龄设置成101&gt; db.users.update(&#123;name:'wangduanduan'&#125;,&#123;$set:&#123;age:101&#125;&#125;) 4.3 $inc12// 将用户年龄增加1岁，如果文档没有age这个字段，则会增加这个字段&gt; db.users.update(&#123;name:'wangduanduan'&#125;,&#123;$inc:&#123;age:1&#125;&#125;) 4.3 upsert操作12345678910// 如果查不到文档，则增加文档&gt; db.users.update(&#123;name:'nobody'&#125;,&#123;$inc:&#123;age:1&#125;&#125;,true)Updated 1 new record(s) in 3ms/* 6 */&#123; "_id" : ObjectId("583fd20f2cfa6a4817c4171c"), "name" : "nobody", "age" : 1.0&#125; 4.4 批量更新12// upadate 的第四个参数设置成true的时候，就会批量更新&gt; db.users.update(&#123;name:'wangduanduan'&#125;,&#123;$set:&#123;age:1891&#125;&#125;,false,true) 5 删除12345// 删除某些文档db.person.remove(&#123;"name":"joe"&#125;)// 删除整个集合db.person.remove()]]></content>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git化文档管理]]></title>
    <url>%2Fgit-manager-docs.html</url>
    <content type="text"><![CDATA[产品概况基本要求 所有文档的格式采用markdown 文档使用Git进行 前提准备从MVC角度分析需求 模型层：资源最小数据集定义，功能定义 控制器：负责请求处理。例如增删改查 视图层：资源展现与交互 对于前端的需求是：视图层 + 模型层对于后端的需求是：控制器 + 模型层 前端需求文档实施资源下载参考文献 产品经理如何绕开API的坑]]></content>
      <tags>
        <tag>git</tag>
        <tag>未完成</tag>
        <tag>gitlab</tag>
        <tag>gow</tag>
        <tag>ConEmu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年我的阅读计划]]></title>
    <url>%2F2018-reading-plan.html</url>
    <content type="text"><![CDATA[阅读速度： 每天54000字, 无法量化，就无法改进 页码控制基于多看阅读和kindle paper white 我的2018年总书单 序号 书名 来源 状态 开始阅读时间 读完时间 1 浪潮之巅 纸质 在读 2 新生 七年就是一辈子 多看 已读完 0205 3 大数据 多看 在读 4 怪诞经济学 多看 在读 5 专业主义 多看 6 失控 多看 在读 0205 7 怪诞心理学 多看 在读 8 设计心理学 多看 9 魔鬼经济学 多看 10 乌合之众 多看 11 把时间当做朋友 多看 12 三体 多看 13 人性的弱点 多看 14 物种起源 kindle 15 沉默的大多数 kindle 在读 16 生命不息，折腾不止 kindle 在读 17 动物农场 kindle 18 世说新语 kindle 19 厚黑学 kindle 第6周 0205-0211 ing 书名 周一 周二 周三 周四 周五 周六 周日 新生 七年就是一辈子917-19 900ok 917ok null null null null null 怪诞经济学539-11 450ok 500 539 null null null null 大数据851-17 750ok 800 851 null null null null 人性的弱点490-10 null 50 100 150 200 250 300 怪诞心理学546 null null 50 100 150 200 250 专业主义378 null null null 50 100 150 200 失控1573 50 150 200 250 300 350 400 第5周 0129-0204 ed 页数基于多看阅读 书名 周一 周二 周三 周四 周五 周六 周日 新生 七年就是一辈子917-19 550 ok 600 ok 650 ok 700ok 750ok 800ok 850ok 怪诞经济学539-11 null null null 250ok 300ok 350ok 400ok 大数据851-17 400 ok 450 ok 500 ok 550ok 600ok 650ok 700ok 第4周 0122-0128 ed 备注：明朝那些事儿，看到抗日援朝那部分，实在是看不下去啦，索性不看了 页数基于多看阅读 书名 周一 周二 周三 周四 周五 周六 周日 新生 七年就是一辈子 200 ok 250 ok 300 ok 350 ok 400 ok 450 ok 500 ok 明朝哪些事儿 4050 ok 4100 ok 4150 ok 4200 ok 4250 4300 4350 大数据 50 ok 100 ok 150 ok 200 ok 250 ok 300 ok 350 ok]]></content>
      <tags>
        <tag>reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要成为某个技术的死忠粉]]></title>
    <url>%2Fdo-not-be-big-fans.html</url>
    <content type="text"><![CDATA[我对Vue与React的态度成年人权衡利弊，小孩子才说好坏你只不过在找借口罢了不要成为某个技术的死忠粉]]></content>
      <tags>
        <tag>idea</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Think With Stream]]></title>
    <url>%2Fthink-with-stream.html</url>
    <content type="text"><![CDATA[流的存在 流的规则终极的流]]></content>
      <tags>
        <tag>idea</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode常用快捷键集锦]]></title>
    <url>%2Fvscode-commom-shortcuts.html</url>
    <content type="text"><![CDATA[功能 键 多行选中 alt+shift+鼠标拖动 打开terminal ctrl + ` 行上下移动 atlt + 上或下箭头 向下复制当前行 shift alt + 下箭头 向上复制当前行 shift alt + 上箭头 f1 打开命令面板 开关书签 com + option + k 书签跳转 com + option + j or l]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Commit Message 格式与类型分类]]></title>
    <url>%2Fcommit-type-summary.html</url>
    <content type="text"><![CDATA[缩写含义说明 类型 描述 feat 新增feature fix 修复bug docs 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等 style 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 refactor 代码重构，没有加新功能或者修复bug perf 优化相关，比如提升性能、体验 test 测试用例，包括单元测试、集成测试等 chore 改变构建流程、或者增加依赖库、工具等 revert 回滚到上一个版本 tips 增加一些提示信息，例如错误提示 格式示例格式： type [id] message 1git commit -am "fix 2038 解决点击无反应的问题" 小技巧使用单引号多行commit注意： window下务必使用git bash。 123git commit -am 'fix 2093 alsdfj laksdasdflka sdflkasdf ' 参考 project-guidelines Commit message 和 Change log 编写指南 cz-cli Git commit message和工作流规范]]></content>
      <tags>
        <tag>git</tag>
        <tag>git-commit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：浪潮之巅]]></title>
    <url>%2Fread-notes-on-top-of-tides.html</url>
    <content type="text"><![CDATA[互联网的金门大桥： 思科关于情书的八卦思科的创始人刚开始是男女朋友关系，他们是斯坦福大学不同计算机中心的主管。两人经常用计算机写情书，但是呢，不同的网络之间的设备协议不同，互不兼容，导致了情书传递非常不方便。于是他们就发明了一种能够支持各种网络设备，各种协议的路由器，即多协议路由器。 对立与兼容大公司都是想打败对手，而不是做出兼容。所以思科的多协议路由器能够有生存的机会。]]></content>
      <tags>
        <tag>未完成</tag>
        <tag>读书笔记</tag>
        <tag>浪潮之巅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无坚不摧：打造极大提高工作效率的装备库]]></title>
    <url>%2Ftool-improve-work-efficiency.html</url>
    <content type="text"><![CDATA[Git Bash Gow 1 2 3 4 5 6 7 8 9 10 awk basename bash bc bison bunzip2 bzip2 bzip2 bzip2recover cat chgrp chmod chown chroot cksum clear cp csplit curl cut dc dd df diff diff3 dirname dos2unix du egrep env expand expr factor fgrep flex fmt fold gawk gdbm3 gfind gow grep gsar gsort gzip head history5 hostid hostname id indent install join jwhois less lesskey libcurl libeay32 libiconv-2 libidn-11 libintl-2 libintl3 libssl32 ln ls m4 make md5sum mkdir mkfifo mknod msys-1 msys-regex-1 msys-termcap-0 mv nano ncftp nl od pageant paste patch pathchk pcre3 plink pr printenv printf pscp psftp putty puttygen pwd readline5 regex2 rm rmdir scp sdiff sed seq sftp sha1sum shar sleep split ssh ssleay32 su sum sync tac tail tar tee test touch tr uname unexpand uniq unix2dos unlink unrar unrar3 unshar uudecode uuencode vim wc wget whereis which whoami xargs yes zip zip32z64 ConEmugerpChrome ExtensionsvimiumMulti-highlightRestlet Client - REST API TestingTampermonkeyWeb Toolsjsonviewernewhttps://www.bejson.com/jsonviewernew/ regex101Linux 工具快速教程]]></content>
      <tags>
        <tag>git</tag>
        <tag>未完成</tag>
        <tag>gow</tag>
        <tag>conemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码工作法]]></title>
    <url>%2Fhttp-status-code-work-method.html</url>
    <content type="text"><![CDATA[概念类比1234Title:连接建立的过程客户主机-&gt;服务器主机: 连接请求（SYN=1,seq=client_isn） 服务器主机-&gt;客户主机: 授予连接（SYN=1,seq=client_isn）\n ack=client_isn+1客户主机-&gt;服务器主机: 确认（SYN=0,seq=client_isn+1）\nack=server_isn+1 工作状态码分类 分类 分类描述 100 已经开始开发该项目，但是还未完成，需要继续开发 200 完成任务 301 任务被转给其他人处理 400 任务描述不清晰，导致无法继续工作，需要重新设计需求 500 任务需要依赖其他服务，但是其他服务无法提供服务，正在等待]]></content>
      <tags>
        <tag>http</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdwon、笔记、编辑器与缓存]]></title>
    <url>%2Fthink-about-markdown-and-editor.html</url>
    <content type="text"><![CDATA[笔记有哪些种类？ 所有人可读：所有人都可以看的，这种类型的笔记适合作为博客 部分可读：这种不适合作为博客，需要一些约束条件，被授权的人才有资格去读 仅自己可读：这种类型的往往都是个人隐私，不需要和别人分享 为什么要记笔记？你需要的东西网上都有，搜索引擎都能找到，那么你为什么还要记笔记？ 节约效率与缓存：搜索引擎并不一定能够找到你需要的数据，一旦找到，最好可以缓存起来，作为笔记，下次查找的效率往往会提高非常多；另外，这次可以找到的内容，下次同样的位置，也可能文档已经被删除。 知识经验积累: 原创的内容在互联网上是搜不到的，所以需要记录，积累知识，内化吸收 生活感情记录: 作为一种情绪的记录 markdown, 笔记， 编辑器之间有什么关系markdown是笔记的一种形式，编辑器来制作笔记。 对于编辑器的要求 可以编辑markdown 可以导出pdf 可以云端备份]]></content>
      <tags>
        <tag>未完成</tag>
        <tag>markdown</tag>
        <tag>editor</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git合并上游仓库即同步fork后的仓库]]></title>
    <url>%2Ffork-sync-learn.html</url>
    <content type="text"><![CDATA[前提说明 仓库A: http://gitlab.tt.cc:30000/fe/omp.git 仓库B: 仓库Bfork自仓库A, 仓库A的地址是：http://gitlab.tt.cc:30000/wangdd/omp.git 某一时刻，仓库A更新了。仓库B需要同步上游分支的更新。 本地操作12345678910111213141516171819202122232425262728293031323334// 1 查看远程分支➜ omp git:(master) git remote -vorigin http://gitlab.tt.cc:30000/wangdd/omp.git (fetch)origin http://gitlab.tt.cc:30000/wangdd/omp.git (push)// 2 添加一个远程同步的上游仓库➜ omp git:(master) git remote add upstream http://gitlab.tt.cc:30000/fe/omp.git➜ omp git:(master) git remote -vorigin http://gitlab.tt.cc:30000/wangdd/omp.git (fetch)origin http://gitlab.tt.cc:30000/wangdd/omp.git (push)upstream http://gitlab.tt.cc:30000/fe/omp.git (fetch)upstream http://gitlab.tt.cc:30000/fe/omp.git (push)// 3 拉去上游分支到本地，并且会被存储在一个新分支upstream/master➜ omp git:(master) git fetch upstreamremote: Counting objects: 4, done.remote: Compressing objects: 100% (4/4), done.remote: Total 4 (delta 2), reused 0 (delta 0)Unpacking objects: 100% (4/4), done.From http://gitlab.tt.cc:30000/fe/omp * [new branch] master -&gt; upstream/master// 4 将upstream/master分支合并到master分支，由于我已经在master分支，此处就不在切换到master分支➜ omp git:(master) git merge upstream/masterUpdating 29c098c..6413803Fast-forward README.md | 1 + 1 file changed, 1 insertion(+)// 5 查看一下，此次合并，本地有哪些更新➜ omp git:(master) git log -p// 6 然后将更新推送到仓库B➜ omp git:(master) git push 总结通过上述操作，仓库B就同步了仓库A的代码。整体的逻辑就是将上游分支拉去到本地，然后合并到本地分支上。就这么简单。]]></content>
      <tags>
        <tag>fork</tag>
        <tag>git</tag>
        <tag>合并上游分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令与oh-my-zsh常用缩写]]></title>
    <url>%2Fgit-commom-cmds.html</url>
    <content type="text"><![CDATA[oh-my-zsh中常用的git缩写12345678910111213141516171819202122alias ga='git add'alias gb='git branch'alias gba='git branch -a'alias gbd='git branch -d'alias gcam='git commit -a -m'alias gcb='git checkout -b'alias gco='git checkout'alias gcm='git checkout master'alias gcp='git cherry-pick'alias gd='git diff'alias gfo='git fetch origin'alias ggpush='git push origin $(git_current_branch)'alias ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'alias glgp='git log --stat -p'alias gm='git merge'alias gp='git push'alias gst='git status'alias gsta='git stash save'alias gstp='git stash pop'alias gl='git pull'alias glg='git log --stat'alias glgp='git log --stat -p' oh-my-zsh git命令缩写完整版 常用的git命令假设你在master分支上 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 12345// 将本地修改后的文件推送到本地仓库git commit -am '修改了一个问题'// 将本地仓库推送到远程仓库git push 状态管理状态查看查看当前仓库状态1git status 分支管理分支新建基于当前分支，创建test分支12345678// 创建dev分支git checkout dev// 创建dev分支后，切换到dev分支git checkout -b dev // 以某个commitId为起点创建分支git checkout -b new-branch-name commit-id 分支查看查看远程分支： git branch -r 12345678// 查看本地分支git branch// 查看远程分支git branch -r// 查看所有分支git branch -a 分支切换切换到某个分支: git checkout 0.10.7123&gt; git checkout 0.10.7Branch 0.10.7 set up to track remote branch 0.10.7 from origin.Switched to a new branch '0.10.7' 分支合并将master分支合并到0.10.7分支: git merge12345678&gt; git merge masterMerge made by the 'recursive' strategy. public/javascripts/app-qc.js | 83 +++++++++++++++++++++++++-- views/menu.html | 1 + views/qc-template-show-modal.html | 114 ++++++++++++++++++++++++++++++++++++++ views/qc-template.html | 7 ++- 4 files changed, 198 insertions(+), 7 deletions(-) create mode 100644 views/qc-template-show-modal.html 分支删除12345// 删除远程dev分支git push --delete origin dev// 删除本地dev分支git branch -D dev 版本对比12345678// 查看尚未暂存的文件更新了哪些部分git diff// 查看某两个版本之间的差异git diff commitID1 commitID2 // 查看某两个版本的某个文件之间的差异git diff commitID1:filename1 commitID2:filename2 日志查看12git log git short-log 参考文献 git 命令参考 《Pro Git 中文版》 廖雪峰 git教程 猴子都能懂的GIT入门]]></content>
      <tags>
        <tag>git</tag>
        <tag>oh-my-zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令使用场景总结]]></title>
    <url>%2Flinux-common-cmds.html</url>
    <content type="text"><![CDATA[lsof: 根据端口号查监听的进程号参考 使用模型：lsof -i :port 已知某服务占用8088端口，请查出使用该端口的进程号 1lsof -i :8088 lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。lsof命令详情 grep: 搜索神器参考： GNU Grep 3.0123456789101112131415161718--color:高亮显示匹配到的字符串-v：显示不能被pattern匹配到的-i：忽略字符大小写-o：仅显示匹配到的字符串-q：静默模式，不输出任何信息-A#：after，匹配到的后#行-B#：before，匹配到的前#行-C#：context，匹配到的前后各#行-E：使用ERE，支持使用扩展的正则表达式－c：只输出匹配行的计数。－I：不区分大 小写(只适用于单字符)。－h：查询多文件时不显示文件名。－l：查询多文件时只输出包含匹配字符的文件名。－n：显示匹配行及 行号。- m: 匹配多少个关键词之后就停止搜索－s：不显示不存在或无匹配文本的错误信息。－v：显示不包含匹配文本的所有行。 ##普通：搜索trace.log 中含有ERROR字段的日志grep ERROR trace.log ##输出文件：可以将日志输出文件中grep ERROR trace.log &gt; error.log ##反向：搜索不包含ERROR字段的日志grep -v ERROR trace.log ##向前：搜索包含ERROR,并且显示ERROR前10行的日志grep -B 10 ERROR trace.log ##向后：搜索包含ERROR字段，并且显示ERROR后10行的日志grep -A 10 ERROR trace.log ##上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志grep -C 10 ERROR trace.log ##多字段：搜索包含ERROR和DEBUG字段的日志gerp -E &#39;ERROR|DEBUG&#39; trace.log ##多文件：从多个.log文件中搜索含有ERROR的日志grep ERROR *.log ##省略文件名：从多个.log文件中搜索ERROR字段日志，并不显示日志文件名从多个文件中搜索的日志默认每行会带有日志文件名 grep -h ERROR *.log ##时间范围： 按照时间范围搜索日志awk &#39;$2&gt;&quot;17:30:00&quot; &amp;&amp; $2&lt;&quot;18:00:00&quot;&#39; trace.log日志形式如下, $2代表第二列即11:44:58, awk需要指定列111-21 16:44:58 /user/info/ ##有没有：搜索到第一个匹配行后就停止搜索grep -m 1 ERROR trace.log 行数统计: 统计ERROR出现了多少行grep -c ERROR trace.log 单词统计：统计ERROR出现了多少次grep -c ERROR trace.log | wc -w wc：单词统计参考文献 Linux工具快速教程]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猴子都能懂的教程：向kindle推送电子书]]></title>
    <url>%2Fsend-book-to-kindle.html</url>
    <content type="text"><![CDATA[原文链接 读书，嗯，读书 教程目的 通过邮件向kindle推送一本电子书 前期准备 一台可以上网的电脑 一个电子书 一个kindle 你的kindle邮箱是什么？ 登录亚马逊，地址：https://www.amazon.cn/ref=nav_logo 鼠标移动到导航栏上的我的账户 点击下拉框中的：管理我的内容和设备 会出现下面tab页面 =&gt; 设置 =&gt; 个人文档设置 =&gt; 里面会有电子邮件地址 里面的邮箱即为你邮件发送的收件方地址。例如：abcd@kindle.cc 如何设置邮箱白名单？并不是所有邮件都能发送到abcd@kindle.cc, 需要在上一步的同一个页面设置已认可的发件人电子邮箱, 只有来自认可的邮箱的电子书，亚马逊才会接受。你需要添加认可的电子邮箱。例如发件的邮箱写为：abcd@qq.com 邮件该怎么写？必须使用上一步白名单里面的邮箱来发送 收件人写你的kindle邮箱 主题写：Convert 在邮件的附件中添加准备好的电子书 点击发送 在哪里查找已经发送的电子书？ 还是在管理我的内容和设备页面 点击我的内容 在显示中选择：个人文档 例如你可以在截图中看到，我刚刚上传的一本：you dont konw js 如果没有找到你已经发送的书籍，请再次检查一下，你的kindle邮箱和白名单中的邮箱是否正确 如何向kindle推送电子书紧接着上一步. 选择要发送的书籍 点击发送 在出现的弹出框中，在下拉框中选择你的kindle设备 点击发送 kindle链接WiFi，进入我的图书馆，点击设备，同步 使用体验的思考？之前用多看阅读，WIFI传书非常方便。kindle的上传图书其实蛮复杂的，过程中可能直接过滤掉一些用户。 我在想为什么亚马逊不在：管理我的内容和设备页面添加一个上传图书的按钮呢？ 重点划线 一封电子邮件最多只能包含25个附件，并且最多只能发送至15个不同的〖发送至Kindle〗电子邮箱。文档的总大小不得超过50MB。 在电子邮件主题中输入“Convert”以将您的文档转换为Kindle格式，然后再将其发送至您的设备以及【管理我的内容和设备】页面中的【我的内容】 如果您的设备或阅读软件暂时无法连接无线网络，我们最多可以为您保存个人文档60天 Kindle个人文档服务支持以下文件类型： Kindle格式（.MOBI、.AZW） Microsoft Word（.DOC、.DOCX） HTML（.HTML、.HTM） RTF (.RTF) Text (.TXT) (Kindle X 咪咕电子书阅读器不支持) JPEG（.JPEG、.JPG） GIF (.GIF) PNG (.PNG) BMP (.BMP) PDF (.PDF) 建议您在发送文件之前将文件名改成英文 参考文档 使用您的〖发送至Kindle〗电子邮箱 添加用于接收文档的电子邮箱 Kindle个人文档服务 Kindle个人文档服务使用条件]]></content>
      <tags>
        <tag>kindle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查询字符串的最小数据集]]></title>
    <url>%2Fquery-string-mds.html</url>
    <content type="text"><![CDATA[什么是查询字符串？给个例子： 1https://en.wikipedia.org/w/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector 查询字符串是url中问号后边的部分，形式如：key1=value1&amp;key2=value2&amp;key3=value3。这部分称为查询(query)组件。 查询组件的最小数据集 参数名： 是否必须： 是否是精确查询： 描述： 示例：必须要有，比如说如果查询的是一个时间。那么时间的格式有很多种，务必给出示例 约束： 字符串：最小长度，最大长度。[3,10] 数值型：取值区间。[4, 10] 枚举型：枚举字符串。1代表男，0代表女 举例说明：一个用户查询的接口 参数名 是否必须 是否是精确查询 描述 示例 约束 email 否 是 邮箱 test@tt.cc 长度：[6, 10] age 否 是 年龄 18 取值：[0, 110] gender 否 是 性别 1 1代表男，0代表女 userName 否 否 用户名 alex 长度：[4, 40] token 是 是 认证令牌 90sdflkajf0asdflkja 长度：60 registerBeginTime 否 是 开始注册时间，返回的结果都是该时间以后的数据 2018-09-20 17:23:00 长度：19 很多资源 参考 wikipedia:Query_string]]></content>
      <tags>
        <tag>docs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写好接口文档？]]></title>
    <url>%2Fhow-to-write-better-api-docs.html</url>
    <content type="text"><![CDATA[HTTP携带信息的方式 url headers body: 包括请求体，响应体 分离通用信息一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数 路径中的参数表达式URL中参数表达式使用{}的形式，参数包裹在大括号之中{paramName} 例如： /api/user/{userId} /api/user/{userType}?age={age}&amp;gender={gender} 数据模型定义数据模型定义包括： 路径与查询字符串参数模型 请求体参数模型 响应体参数模型 数据模型的最小数据集： 名称 是否必须 说明 “最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。 一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。 另外：数据模型非常建议使用表格来表现。 举个栗子🌰： 名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 age 否 用户年龄 gender 否 用户性别。1表示男，0表示女 请求示例123456789101112131415// general POST http://www.testapi.com/api/user// request payload&#123; "name": "qianxun", "age": 14, "like": ["music", "reading"], "userType": "vip"&#125;// response&#123; "id": "asdkfjalsdkf"&#125; 异常处理异常处理最小数据集 状态码 说明 解决方案 举个栗子🌰： 状态码 说明 解决方案 401 用户名密码错误 检查用户名密码是否正确 424 超过最大在线数量 请在控制台修改最大在线数量 之前我一直不想把解决方案加入异常处理的最小数据集，但是对于很多开发者来说，即使它知道424代表超过最大在线数量。如果你不告诉如果解决这个问题，那么他们可能就会直接来问你。所以最好能够一步到位，直接告诉他应该如何解决，这样省时省力。 如何组织？一个创建用户的例子：创建用户1 请求示例1234567891011121314// general POST http://www.testapi.com/api/user/vip/?token=abcdefg// request payload&#123; "name": "qianxun", "age": 14, "like": ["music", "reading"]&#125;// response&#123; "id": "asdkfjalsdkf"&#125; 2 路径与查询字符串参数模型 POST http://www.testapi.com/api/user/{userType}/?token={token} 名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 token 是 认证令牌 3 请求体参数模型 名称 是否必须 说明 name 是 用户名。4-50个字符 age 否 年龄 like 否 爱好。最多20个 4 响应体参数模型 名称 说明 id 用户id 5 异常处理 状态码 说明 解决方案 401 token过期 请重新申请token 424 超过最大在创建人数 请在控制台修改最大创建人数 这样组织的原因 请求示例: 请求示例放在第一位的原因是，要用最快的方式告诉开发者，这个接口应该如何请求 路径与查询字符串参数模型： 使用mustache包裹参数 请求体参数模型：如果没有请求体，可以不写 响应体参数模型： 异常处理 文档提供的形式文档建议由一下两种形式，在线文档，pdf文档。 在线文档 更新方便 易于随时阅读 易于查找 pdf文档 内容表现始终如一，不依赖文档阅读器 文档只读，不会被轻易修改 其中由于是面对第三方开发者，公开的在线文档必须提供；由于某些特殊的原因，可能需要提供文件形式的文档，建议提供pdf文档。当然，以下的文档形式是非常不建议提供的： word文档 markdown文档 word文档和markdown文档有以下缺点： 文档的表现形式非常依赖文档查看器：各个版本的word文档对word的表现形式差异很大，可能在你的电脑上内容表现很好的文档，到别人的电脑上就会一团乱麻；另外markdown文件也是如此。而且markdown中引入文件只能依靠图片链接，如果文档中含有图片，很可能会出现图片丢失的情况。 文档无法只读：文档无法只读，就有可能会被第三方开发者在不经意间修改，那么文档就无法保证其准确性了。 总结一下，文档形式的要点： 只读性：保证文档不会被开发者轻易修改 一致性：保证文档在不同设备，不同文档查看器上内容表现始终如一 易于版本管理：文档即软件（DAAS: Document as a Software），一般意义上说软件 = 数据 + 算法, 但是我认为文档也是一种组成软件的重要形式。既然软件需要版本管理，文档的版本管理也是比不可少的。]]></content>
      <tags>
        <tag>接口文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费服务的盈利模式]]></title>
    <url>%2Fhow-free-server-make-money.html</url>
    <content type="text"><![CDATA[免费产品的盈利模式有四种 投放广告 增值服务：先把羊养肥，再慢慢割羊毛，现在大部分都是互联网服务都是这种 交叉补贴: A服务免费，再用户使用A服务时，通过提供B服务来盈利 零边际成本：免费提供A服务，但是用户需要用物品去交换A服务，服务提供者通过加工物品来盈利]]></content>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ztree-note]]></title>
    <url>%2Fztree-note.html</url>
    <content type="text"><![CDATA[ztree获得顶层节点1treeObj.getNodesByParam('level',0,null);]]></content>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkpad 系列恢复F1-F12原始功能，切换ctrl和fn的位置]]></title>
    <url>%2Fthinkpad-f1-f12.html</url>
    <content type="text"><![CDATA[1 实验准备 T450笔记本 2 进入BIOS 重启电脑 一直不停按enter 按F1 选择Keyboard/mouse 3 恢复F1-F2恢复原始功能:fn and ctrl key swap [enabled] 4 切换ctrl和ctrl的位置:F1-F12 as primary function [enabled] 5 保存，退出]]></content>
      <tags>
        <tag>thinkpad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚌埠出入境管理局电话以及相关注意事项]]></title>
    <url>%2Fgoverment-info.html</url>
    <content type="text"><![CDATA[1 相关地址信息1.1 蚌埠市公安局出入境接待大厅办公地址：蚌埠市南湖路600号咨询电话：0552-2089266投诉电话：0552-2089269节假日值班电话：0552-2089266工作时间：周一至周五：上午8:00-12:00，下午14:30-17:30； 1.2 蚌埠市五河县公安局出入境接待大厅办公地址：五河县城关镇淮河路40号咨询电话：0552-5057155投诉电话：0552-5057155节假日值班电话：0552-5057155工作时间：周一至周五：上午8：00-12：00，下午：14：30-17：30 1.3 蚌埠市怀远县公安局出入境接待大厅办公地址：怀远县禹王路中段咨询电话：0552-8027123投诉电话：0552-8027123节假日值班电话：0552-8027123工作时间：周一至周五：上午8：00-12：00，下午：14：30-17：30； 1.4 蚌埠市固镇县公安局出入境接待大厅办公地址：固镇县谷阳路中段咨询电话：0552-6075830投诉电话：0552-6075830节假日值班电话：0552-6075830工作时间：周一至周五：上午8:00-12:00，下午14:30-17:30； 2 注意事项2.1 准备材料 身份证 银行卡(有些费用只能用银行卡支付) 零钱 2.2 其他事项 一般来说签证10天后才能办好，可以申请寄送服务 不要在将近中午的时候去办证，他们中午休息时间蛮长的 办证前，可以打电话问问本地是支持团签还是个签 3 注意以上信息不能保证时效性，如果电话或者地址不存在，请自行查询。]]></content>
      <tags>
        <tag>蚌埠</tag>
        <tag>出入境管理局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win7 ie11 开发者工具打开后一片空白]]></title>
    <url>%2Fie11-without-devtool.html</url>
    <content type="text"><![CDATA[解决方法安装Windows7补丁：KB3008923；下载地址：http://www.microsoft.com/en-us/download/details.aspx?id=45134 （32位）http://www.microsoft.com/zh-CN/download/details.aspx?id=45154 （64位）]]></content>
      <tags>
        <tag>ie11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 服务管理指令]]></title>
    <url>%2Fcentos7-service-manager.html</url>
    <content type="text"><![CDATA[功能 命令 使服务开启启动 systemctl enable httpd.service 关闭服务开机启动 systemctl disabled httpd.service 检查服务状态 systemctl status httpd.service 查看所有已启动的服务 systemctl list-units –type=service 启动服务 systemctl start httpd.service 停止服务 systemctl stop httpd.service 重启服务 systemctl restart httpd.service]]></content>
      <tags>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSTA 呼叫模型简介]]></title>
    <url>%2Fcsta-call-model-overview.html</url>
    <content type="text"><![CDATA[内容概要 CSTA协议与标准概述 CSTA OpenScape 语音架构概述 CSTA协议标准什么是CSTA ? CSTA：电脑支持通讯程序(Computer Supported TelecommunicationsApplications) 基本的呼叫模型在1992建立，后来随着行业发展，呼叫模型也被加强和扩展，例如新的协议等等 CSTA是一个应用层接口，用来监控呼叫，设备和网络 CSTA创建了一个通讯程序的抽象层: CSTA并不依赖任何底层的信令协议 E.g.H.323,SIP,Analog,T1,ISDN,etc. CSTA并不要求用户必须使用某些设备 E.g.intelligentendpoints,low-function/stimulusdevices,SIPSignalingmodels-3PCC vs. Peer/Peer 适用不同的操作模式 第三方呼叫控制 一方呼叫控制 CSTA的设计目标是为了提高各种CSTA实现之间的移植性 规范化呼叫模型和行为 完成服务、事件定义 规范化标准 CSTA 标准的进化史 阶段1 (发布于 June ’92) 40 特性, 66 页 (服务定义) 专注于呼叫控制 阶段2 (发布于 Dec. ’94) 77 特性, 145 页 (服务定义) I/O &amp; 语音单元服务, 更多呼叫控制服务 阶段3 - CSTA Phase II Features &amp; versit CTI Technology 发布于 Dec. ‘98 136 特性, 650 页 (服务定义) 作为ISO 标准发布于 July 2000 发布 CSTA XML (ECMA-323) June 2004 发布 “Using CSTA with Voice Browsers” (TR/85) Dec. 02 发布 CSTA WSDL (ECMA-348) June 2004 June 2004: 发布对象模型 TR/88 June 2004: 发布 “Using CSTA for SIP Phone User Agents (uaCSTA)” TR/87 June 2004: 发布 “Application Session Services” (ECMA-354) June 2005: 发布 “WS-Session: WSDL for ECMA-354”(ECMA-366) December 2005 : 发布 “Management Notification and Computing FunctionServices” December 2005 : Session Management, Event Notification, Amendements for ECMA-348” (TR/90) December 2006 : Published new editions of ECMA-269, ECMA-323, ECMA-348 CSTA 标准文档 CSTA 标准扩展 新的特性可以被加入标准通过发布新版本的标准 新的参数，新的值可以被加入通过发布新版本的标准 未来的新版本必须下向后兼容 具体的实施可以增加属性通过CSTA自带的扩展机制(e.g. ONS – One Number Service) CSTA 操作模型 CSTA操作模型由计算域和转换域组成，是CSTA定义在两个域之间的接口 CSTA标准规定了消息（服务以及事件上报）,还有与之相关的行为 计算域是CSTA程序的宿主环境，用来与转换域交互与控制 转换域 - CSTA模型提供抽象层，程序可以观测并控制的。转换渔包括一些对象例如CSTA呼叫，设备，链接。 CSTA 操作模型：呼叫，设备，链接 相关说明是的的的的 参考 CSTAoverview CSTA_introduction_and_overview]]></content>
      <tags>
        <tag>csta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh 无密码登录远程服务器]]></title>
    <url>%2Fssh-login-without-password.html</url>
    <content type="text"><![CDATA[1 前提说明A(本机 mac item2)B(远程机器 ip:a.b.c.d centos) 2 过程12.1 生成public_key与private_key在本机上输入，可以一路回车，不用说明1ssh-keygen -t rsa 最终会在~/.ssh/下生成两个文件12id_rsaid_rsa.pub 2.2 将public_key上传到远程服务器注意：在本机上输入12// 回车之后，需要输入远程主机B的登录密码scp ~/.ssh/id_rsa.pub root@a.b.c.d:/root/.ssh 2.3 登录远程主机在本机上输入1234567891011// 需要输入远程主机的密码ssh root@a.b.c.d// 进到远程主机~/.ssh/目录下, 此目录下应该已经有了之前上传的id_rsa.pub文件// 如果目录下没有authorized_keys文件，那么将id_rsa.pub改名成authorized_keysmv id_rsa.pub authorized_keys// 如果远程目录下已经存在authorized_keys文件，可以将id_rsa.pub追加进去cat id_rsa.pub &gt;&gt; authorized_keys 2.4 本机配置注意，此时需要退出ssh, 在本机上执行以下命令123456789vi ~/.ssh/config在config文件中追加以下内容，并保存退出Host serverNameHostname a.b.c.dPort 22User rootIdentityFile ~/.ssh/id_rsa 然后试一下，只需要ssh serverName, 就可以直接登录远程服务器，是不是很爽 3 参考文献 scp 命令教程 mac用iterm2实现ssh，怎么像SecureCRT一样保存IP和账号密码？ 4 精华推荐最后推荐一本非常好的linux常用命令手册，非常不错哦。 Linux下有很多命令行工具供我们使用，每个工具总是提供了大量参数供我们选择； 实际工作中，我们用到的工具，最常用的总是那么几个参数组合； 为此，我写了这本书相对实用的书； 这本书专注于Linux工具的最常用用法，以便读者能以最快时间掌握，并在工作中应用； 《Linux工具快速教程》]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组织在召唤：如何免费获取一个js.org的二级域名]]></title>
    <url>%2Fhow-to-get-jsorg-sub-domain.html</url>
    <content type="text"><![CDATA[之前我是使用wangduanduan.github.io作为我的博客地址，后来觉得麻烦，有把博客关了。最近有想去折腾折腾。先看效果：wdd.js.org 如果你不了解js.org可以看看我的这篇文章:一个值得所有前端开发者关注的网站js.org 前提 已经有了github pages的一个博客，并且博客中有内容，没有内容会审核不通过的。我第一次申请域名，就是因为内容太少而审核不通过。 想好自己要什么域名？比如你想要一个：wdd.js.org的域名，你先在浏览器里访问这个地址，看看有没有人用过，如果已经有人用过，那么你就只能想点其他的域名了。 fork js.org的项目，添加自己的域名1 fork https://github.com/js-org/dns.js.org2 修改你fork后的仓库中的cnames_active.js文件，加上自己的一条域名，最好要按照字母顺序 如下图所示，我在第1100行加入。注意，不要在该行后加任何注释。1"wdd": "wangduanduan.github.io", 3 commit 加入CNAME文件我是用hexo和next主题作为博客的模板。其中我在gh-pages分支写博客，然后部署到master分支。 我在我的gh-pages分支的source目录下加入CNAME文件, 内容只有一行 1wdd.js.org 将博客再次部署好，如果CNAME生效的话，你已经无法从原来的地址访问：wangduanduan.github.io， 这个博客了。 向js.org项目发起pull-request找到你fork后的项目，点击 new pull request, 向原来的项目发起请求。 然后你可以在js-org/dns.js.org项目的pull requests看到你的请求，当这个请求被合并时，你就拥有了js.org的二级域名。]]></content>
      <tags>
        <tag>jsorg</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不常用却很有妙用的事件及方法]]></title>
    <url>%2Fbrowser-events.html</url>
    <content type="text"><![CDATA[visibilitychange事件触发条件：浏览器标签页被隐藏或显示的时候会触发visibilitychange事件. 使用场景：当标签页显示或者隐藏时，触发一些业务逻辑 123document.addEventListener("visibilitychange", function() &#123; console.log( document.visibilityState );&#125;); storage事件触发条件：使用localStorage or sessionStorage存储或者修改某个本地存储时 使用场景：标签页间通信 123456789// AB页面同源// 在A 页面window.addEventListener('storage', (e) =&gt; &#123;console.log(e)&#125;)// 在B 页面，向120打个电话localStorage.setItem('makeCall','120')// 然后可以在A页面间有输出, 可以看出A页面 收到了B页面的通知...key: "makeCall", oldValue: "119", newValue: "120", ... beforeunload事件触发条件：当页面的资源将要卸载(及刷新或者关闭标签页前). 当页面依然可见，并且该事件可以被取消只时 使用场景：关闭或者刷新页面时弹窗确认，关闭页面时向后端发送报告等 123456window.addEventListener("beforeunload", function (e) &#123; var confirmationMessage = "\o/"; e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+ return confirmationMessage; // Gecko, WebKit, Chrome &lt;34&#125;); navigator.sendBeacon这个方法主要用于满足 统计和诊断代码 的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。过早的发送数据可能导致错过收集数据的机会。然而， 对于开发者来说保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在卸载事件处理器中产生的异步 XMLHttpRequest 。 使用 sendBeacon() 方法，将会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：使它可靠，异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单！ 注意：该方法在IE和safari没有实现 使用场景：发送崩溃报告 12345window.addEventListener('unload', logData, false);function logData() &#123; navigator.sendBeacon("/log", analyticsData);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nodejs 服务端框架合集(78个)]]></title>
    <url>%2Fnodejs-server-frameworks.html</url>
    <content type="text"><![CDATA[没有什么事情是一个框架解决不了的，如果有，就再找一个。 Photo by 贝莉儿 NG on Unsplash 1 MVC frameworks1.1 Sinatra-like这些框架提供了丰富的配置，比Rails-like或full-stack少。 Express hapi flatiron locomotive total.js koa.js TWEE.IO diet.js Flicker.js ZinkyJS 1.2 Rails-like正确呈现您的项目。从包含的模板创建自己的艺术 Nodal Strapi CompoundJS geddy Sails.js Adonis RhapsodyJS ThinkJS Trails KambojaJS JS-Web 2 Full-stack frameworks这就是Node.js真正闪耀的地方。全栈MVC框架与脚手架，模板引擎，websocket和持久性库捆绑在一起，允许您构建实时可伸缩的Web应用程序。 Catberry.js AllcountJS Derby Feathers SocketCluster SocketStream MEAN.js MEAN.io Meteor Meatier TWEE.IO Mojito Seeds.js SANE COKE Sleekjs Danf Catberry Nuke.js We.js seneca.js Keystone.js Horizon Apogeu 3 REST API frameworks对于那些使用富客户端/前端MVC框架（或不）的客户，只需要启动一个快速的Node.js REST API服务器即可。 Ivy Restocat actionHero.js Frisby restling restify restmvc percolator LoopBack Fortune.js facet Raddish Restberry Gugamarket Nest microlet Moleculer 4 Other libraries中间件，库和静态站点生成器。 Connect Kraken ewdGateway2 Wintersmith docpad Blacksmith romulus Petrify Tower.js Impress Rendr Backnode Sequelize Cylon.js Virgilio.js SHPS]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[You-Dont-Need 你不需要系列]]></title>
    <url>%2Fyou-dont-need.html</url>
    <content type="text"><![CDATA[You-Dont-Need-JavaScript CSS是强大的，你可以做很多事情没有JS。 本文教你使用原生CSS做下面的事情。 内容目录 手风琴/切换 圆盘传送带 检查复选框的计数器 翻转点击 Textfield上的浮动标签 字体（拉丁） 游戏 悬停/弹出信息 图片廊 菜单 移动菜单关闭画布 汉堡菜单 花式菜单 莫代尔/弹出 鼠标跟踪 视差滚动 标签 待办事项列表 提示 树视图 Twitter心动画 动态图像着色 连锁反应 响应式计数器显示不适合屏幕的项目数量 可以看一下纯CSS的例子 You-Dont-Need-Lodash-Underscore Lodash和Underscore是伟大的现代JavaScript实用程序库，它们被前端开发人员广泛使用。但是，如果您将目标锁定为现代浏览器，则可能会发现，许多方法已经得到ES5和ES6的原生支持。如果你想要你的项目需要更少的依赖，并且你清楚的知道你的目标浏览器，那么你可能不需要Lodash / Underscore。 来自开发者的声音 在代码变臃肿之前，请使用原生JS对象和数组工具函数. —Cody Lindley, Author of jQuery Cookbook and JavaScript Enlightenment 你可能不需要lodash. 有许多好用的原生方法了. —Daniel Lamb, Computer Scientist, Technical Reviewer of Secrets of the JavaScript Ninja and Functional Programming in JavaScript 我想不是，但我想要它. —Tero Parviainen, Author of build-your-own-angular 我承认，我曾经过度使用lodash. —@therebelrobot, Maker of web things, Facilitator for Node.js/io.js 内容目录 Array _.compact _.concat _.fill _.find _.findIndex _.first _.flatten _.flattenDeep .head and .tail _.indexOf _.join _.last _.lastIndexOf _.reverse _.without _.slice _.isArray Collection _.each _.every _.filter _.groupBy _.includes _.map .minBy and .maxBy _.pluck _.range _.reduce _.reduceRight _.size _.some Function _.after Lang _.isNaN Object _.assign _.keys _.toPairs _.values String _.repeat _.template _.toLower _.toUpper _.trim _.replace You-Dont-Need-jQuery纯JavaScript的例子, 实现做jQuery与查询，样式，dom，ajax，事件等 前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10 以上浏览器。 内容目录 Translations Query Selector CSS &amp; Style DOM Manipulation Ajax Events Utilities Promises Animation Alternatives Browser Support You-Dont-Need-GUI图形用户界面对计算机用户非常友好。它们被引入以响应命令行界面（CLI）感知的陡峭学习曲线。 但是，他们往往需要更多的资源，功能不强，难以通过脚本自动化。 作为计算机专家，我们希望更高效，更好地完成工作。我们知道命令字可能不容易被发现或助记符，所以我们尝试列出一些您可能试图在GUI中执行的常见任务。 内容目录 复制一个文件 复制一个文件 复制一个文件夹 复制一个文件夹 移动一个文件 重命名一个文件 移动一个文件夹 重命名文件夹 合并文件夹 创建一个新的文件 新建一个文件夹 显示文件/文件夹大小 用默认程序打开一个文件 压缩一个文件夹 解压缩文件夹 删除一个文件 删除一个文件夹 列出文件夹内容 树查看文件夹及其子文件夹 找到一个陈旧的文件 显示一个日历 找到未来的日期 使用计算器 强制退出程序]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nodejs alpine 基础docker镜像构建]]></title>
    <url>%2Fnodejs-alpine-docker.html</url>
    <content type="text"><![CDATA[系统环境 centos7 内核：3.10.0-514.26.2.el7.x86_64 安装docker要求内核版本不低于3.10 安装docker123yum install docker // 安装dockersystemctl start docker.service // 启动dockersystemctl enable docker.service // 设置开机启动 Nodejs 镜像选择 REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/node 9.2.1-slim 69c9f9292fa4 3 days ago 230 MB docker.io/node 9.2.1-alpine afdc3aaaf748 3 days ago 67.46 MB docker.io/node latest 727b047a1f4e 3 days ago 675.6 MB docker.io/iron/node latest 9ca501065d18 20 months ago 18.56 MB 选择镜像的标准 官方的 经常维护的 体积小的 要有yarn 和 npm node版本要高 最终选择 node:9.2.1-alpine, 该镜像体积很小，已经内置npm(5.5.1), yarn(1.3.2) 时区配置node:9.2.1-alpine的时区默认不是国内的，需要在build时，配置时区。 1234567891011FROM node:9.2.1-alpine# Install base packages and set timezone ShangHaiRUN apk update &amp;&amp; apk add bash tzdata \ &amp;&amp; cp -r -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime.........CMD [ "node" ] 验证：123456789➜ node-dockerfile git:(master) docker run -it e595 sh / # yarn -v1.3.2/ # npm -v5.5.1/ # node -vv9.2.1/ # dateTue Dec 12 17:33:26 CST 2017]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vscode中用standard style 风格去验证 vue文件]]></title>
    <url>%2Fvscode-vue-standardjs.html</url>
    <content type="text"><![CDATA[JavaScript Standard Style简介本工具通过以下三种方式为你（及你的团队）节省大量时间： 无须配置。 史上最便捷的统一代码风格的方式，轻松拥有。 自动代码格式化。 只需运行 standard –fix 从此和脏乱差的代码说再见。 提前发现风格及程序问题。 减少代码审查过程中反反复复的修改过程，节约时间。 无须犹豫。再也不用维护 .eslintrc, .jshintrc, or .jscsrc 。开箱即用。 安装：1npm i standard -g 关于JavaScript 代码规范, 你可以点击链接看一下。 如何在vscode中用JavaScript Standard Style风格去验证 vue文件实际上JavaScript Standard Style有一个FAQ, 说明了如何使用。 但是有一点非常重要的作者没有提到，就是eslint-plugin-html这个插件必须要安装3.x.x版本的, 现在eslint-plugin-html, 已经升级到4.x版本，默认不写版本号安装的就是4.x版本的，所以会出现问题。参考 ESLint v4 is only supported by eslint-plugin-html v3, so you can’t use eslint-plugin-html v1.5.2 with it (I should add a warning about this when trying to use the plugin with an incompatible version on ESLint). If you do not use ESLint v4, please provide more information (package.json, a gist to reproduce, …) 1234567891011121314151617181920212223242526// FAQHow to lint script tag in vue or html files?You can lint them with eslint-plugin-html, just install it first, then enable linting for those file types in settings.json with: "standard.validate": [ "javascript", "javascriptreact", "html" ], "standard.options": &#123; "plugins": ["html"] &#125;, "files.associations": &#123; "*.vue": "html" &#125;,If you want to enable autoFix for the new languages, you should enable it yourself: "standard.validate": [ "javascript", "javascriptreact", &#123; "language": "html", "autoFix": true &#125; ], "standard.options": &#123; "plugins": ["html"] &#125; 综上， 整理一下安装思路需要安装哪些包？ npm i -g standard npm i -g eslint-plugin-html@3.2.2 必须是3x版本 npm i -g eslint以上三个包都是全局安装的，如果你想看看全局安装了哪些包可以用npm list -g --depth=0查看 vscode config 如何写？1234567891011121314"standard.validate": [ "javascript", "javascriptreact", &#123; "language": "html", "autoFix": true &#125;],"standard.options": &#123; "plugin": ["html"]&#125;,"files.associations": &#123; "*.vue": "html"&#125;, 如何在保存文件时，自动使用standard格式化vue文件1"standard.autoFixOnSave": true 如果还不行怎么办？ 重启一下vscode 重启一下电脑 在此文后追加评论]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>vue</tag>
        <tag>standardjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[油猴子脚本 - 我的地盘我做主]]></title>
    <url>%2Ftampermonkey.html</url>
    <content type="text"><![CDATA[当你用浏览器访问某个网页时，你可曾想过，你看到的这个网页，实际上是属于你自己的。 打个比喻：访问某个网站就好像是网购了一筐鸡蛋，鸡蛋虽然是养鸡场生产的，但是这个蛋我怎么吃，你养鸡场管不着。 当然了，对于很多人来说，鸡蛋没有别的吃法，鸡蛋只能煮着吃。 你可以看如下的页面：当你在某搜索引擎上搜索前端开发时 大多数人看到的页面是这样的, 满屏的广告，满屏的推广，满屏的排名，满屏的中间地址跳转，满屏的流量劫持, 还有莆田系 但是有些人的页面却是这样的：清晰，自然，链接直达，清水出芙蓉，天然去雕饰 这就是油猴子脚本干的事情， 当然，它能干的事情，远不止如此。它是齐天大圣孙悟空，有七十二变。 什么是油猴子脚本？ Greasemonkey，简称GM，中文俗称为“油猴”，是Firefox的一个附加组件。它让用户安装一些脚本使大部分HTML为主的网页于用户端直接改变得更方便易用。随着Greasemonkey脚本常驻于浏览器，每次随着目的网页打开而自动做修改，使得运行脚本的用户印象深刻地享受其固定便利性。 Greasemonkey可替网页加入些新功能（例如在亚马逊书店嵌入商品比价功能）、修正网页错误、组合来自不同网页的数据、或者数繁不及备载的其他功能。写的好的Greasemonkey脚本甚至可让其输出与被修改的页面集成得天衣无缝，像是原本网页里的一部分。 来自维基百科 如何安装油猴子插件？在google商店搜索Tampermonkey, 安装量最高的就是它。 如何写油猴子脚本？油猴子脚本有个新建脚本页面，在此页面可以创建脚本。具体教程可以参考。 中文 GreaseMonkey 用户脚本开发手册 GreaseMonkey（油猴子）脚本开发 深入浅出 Greasemonkey Greasemonkey Hacks/Getting Started 如何使用他人的脚本？greasyfork网站提供很多脚本，它仿佛是代码界的github, 可以在该网站搜到很多有意思的脚本。 有哪些好用的脚本？ 有哪些超神的油猴脚本? 或者你可以在greasyfork网站查看一些下载量排行]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】一个值得所有前端开发者关注的网站 js.org]]></title>
    <url>%2Fjs-org.html</url>
    <content type="text"><![CDATA[二十年后，域js.org第一次注册，它终于服务于其明显的目的 - JavaScript社区。 从一开始，对JavaScript的看法各不相同 - 有些人喜欢的语言，有人讨厌它。但是，对于使JavaScript成为最受欢迎的编程语言之一的社区的威力，应该毫无疑问。为了与社区的自由开放的心态保持一致，JS.ORG为开发人员及其项目免费提供了子域名。自第一步以来，我们还专注于跟踪JavaScript趋势并传播有关它的新闻。 贡献是欢迎：如果你有热情开始一个合作项目，或者如果你想成为JS.ORG的成员，并贡献JS.ORG，随时与我联系。 DNS 如果您是JavaScript开发人员，您可能已经听说过 - 或者甚至已经使用GitHub页面来托管您的内容。 DNS.JS.ORG补充GitHub提供的免费网络空间，并提供了一个适合您项目的自由和时尚的网址。 STARTS STATS.JS.ORG获取GitHub上最重要的JavaScript项目的统计参数，并将它们填充到10k行的巨型表中。这个项目旨在使JavaScript的趋势可见。 NEWS你有什么东西要与社区分享或想阅读其他JavaScript爱好者的东西吗？ NEWS.JS.ORG提供了一种方便的传播，消费和讨论JavaScript项目。 WASMWebAssembly（或简称wasm）是一种用于Web平台上的低级代码的新的二进制语法。 WASM.NEWS是JS.ORG计划的一个分支，并作为这个即将到来的主题的新闻聚合。]]></content>
      <tags>
        <tag>js.org</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[追本溯源：substr与substring历史漫话]]></title>
    <url>%2Fsubstr-and-substring-history.html</url>
    <content type="text"><![CDATA[引子： 很多时候，当我要字符串截取时，我会想到substr和substring的方法，但是具体要怎么传参数时，我总是记不住。哪个应该传个字符串长度，哪个又应该传个开始和结尾的下标，如果我不去查查这两个函数，我始终不敢去使用它们。所以我总是觉得，这个两个方法名起的真是蹩脚。然而事实是这样的吗？ 看来是时候扒一扒这两个方法的历史了。 1 基因追本溯源 在编程语言的历史长河中，曾经出现过很多编程语言。然而大浪淘沙，铅华洗尽之后，很多早已折戟沉沙，有些却依旧光彩夺目。那么stubstr与substring的DNA究竟来自何处？ 1950与1960年代 1954 - FORTRAN 1958 - LISP 1959 - COBOL 1964 - BASIC 1970 - Pascal 1967-1978：确立了基础范式 1972 - C语言 1975 - Scheme 1978 - SQL (起先只是一种查询语言，扩充之后也具备了程序结构) 1980年代：增强、模块、性能 1983 - C++ (就像有类别的C) 1988 - Tcl 1990年代：互联网时代 1991 - Python 1991 - Visual Basic 1993 - Ruby 1995 - Java 1995 - Delphi (Object Pascal) 1995 - JavaScript 1995 - PHP 2009 - Go 2014 - Swift (编程语言) 1.1 在C++中首次出现substr() 在c语言中，并没有出现substr或者substring方法。然而在1983，substr()方法已经出现在C++语言中了。然而这时候还没有出现substring, 所以可以见得：substr是stustring的老大哥 1string substr (size_t pos = 0, size_t len = npos) const; 从C++的方法定义中可以看到, substr的参数是开始下标，以及字符串长度。 12std::string str="We think in generalities, but we live in details.";std::string str2 = str.substr (3,5); // "think" 1.2 在Java中首次出现substring() 距离substr()方法出现已经有了将近十年之隔，此间涌现一批后起之秀，如: Python, Ruby, VB之类，然而他们之中并没有stustring的基因，在Java的String类中，我们看到两个方法。从这两个方法之中我们可以看到：substring方法基本原型的参数是开始和结束的下标。 1234String substring(int beginIndex) // 返回一个新的字符串，它是此字符串的一个子字符串。String substring(int beginIndex, int endIndex)// 返回一个新字符串，它是此字符串的一个子字符串。 1.3 JavaScript的历史继承 1995年，网景公司招募了Brendan Eich，目的是将Scheme编程语言嵌入到Netscape Navigator中。在开始之前，Netscape Communications与Sun Microsystems公司合作，在Netscape Navigator中引入了更多的静态编程语言Java，以便与微软竞争用户采用Web技术和平台。网景公司决定，他们想创建的脚本语言将补充Java，并且应该有一个类似的语法，排除采用Perl，Python，TCL或Scheme等其他语言。为了捍卫对竞争性提案的JavaScript的想法，公司需要一个原型。 1995年5月，Eich在10天内写完。 上帝用七天时间创造万物, Brendan Eich用10天时间创造了一门语言。或许用创造并不合适，因为JavaScript是站在了Perl，Python，TCL或Scheme等其他巨人的肩膀上而产生的。 JavaScript并不像C那样出身名门，在贝尔实验室精心打造，但是JavaScript在往后的自然选择中，并没有因此萧条，反而借助于C,C++, Java, Perl，Python，TCL, Scheme优秀基因，进化出更加强大强大的生命力。 因此可以想象，在10天之内，当Brendan Eich写到String的substr和substring方法时，或许他并没困惑着两个方法的参数应该如何设置，因为在C++和Java的实现中，已经有了类似的定义。 如果你了解历史，你就不会困惑现在。 2 所以，substr和substring究竟有什么不同？如下图所示：substr和substring都接受两个参数，他们的第一个参数的含义是相同的，不同的是第二个参数。substr的第二个参数是到达结束点的距离，substring是结束的位置。 3 参考文献 维基百科：程式語言歷史 C++ std::string::substr JavaScript 如有不正确的地方，欢迎指正。]]></content>
      <tags>
        <tag>substr</tag>
        <tag>substring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熟练使用使用jQuery Promise (Deferred)]]></title>
    <url>%2Fjquery-deferred.html</url>
    <content type="text"><![CDATA[1 情景再现以前用nodejs写后端程序时，遇到Promise这个概念，这个东西好呀！不用谢一层一层回调，直接用类似于jQuery的连缀方式。后来遇到bluebird这个库，它就是Promise库中很有名的。我希望可以把Promise用在前端的ajax请求上，但是我不想又引入bluebird。后来发现，jquery本身就具有类似于Promise的东西。于是我就jquery的Promise写一些异步请求。 2 不堪回首看看一看我以前写异步请求的方式12345678910111213141516171819202122// 函数定义function sendRequest(req,successCallback,errorCallback)&#123; $.ajax(&#123; ... ... success:function(res)&#123; successCallback(res); &#125;, error:function(res)&#123; errorCallback(res); &#125; &#125;);&#125;// 函数调用,这个函数的匿名函数写的时候很容易出错，而且有时候难以理解sendRequest(req,function(res)&#123; //请求成功 ...&#125;,function(res)&#123; //请求失败 ...&#125;); 3 面朝大海下面是我希望的异步调用方式123456789sendRequest(req).done(function(res)&#123; //请求成功 ...&#125;).fail(function(req)&#123; //请求失败 ...&#125;); 4 废话少说，放‘码’过来 talk is cheap, show me the code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 最底层的发送异步请求，做成Promise的形式App.addMethod('_sendRequest',function(path,method,payload)&#123; var dfd = $.Deferred(); $.ajax(&#123; url:path, type:method || "get", headers:&#123; sessionId:session.id || '' &#125;, data:JSON.stringify(payload), dataType:"json", contentType : 'application/json; charset=UTF-8', success:function(data)&#123; dfd.resolve(data); &#125;, error:function(data)&#123; dfd.reject(data); &#125; &#125;); return dfd.promise();&#125;);//根据callId查询录音文件，不仅仅是异步请求可以做成Promise形式，任何函数都可以做成Promise形式App.addMethod('_getRecordingsByCallId',function(callId)&#123; var dfd = $.Deferred(), path = '/api/tenantcalls/'+callId+'/recordings'; App._sendRequest(path) .done(function(res)&#123;dfd.resolve(res);&#125;) .fail(function(res)&#123;dfd.reject(res);&#125;); return dfd.promise();&#125;);// 获取录音App.addMethod('getCallDetailRecordings',function(callId)&#123; App._getRecordingsByCallId(callId) .done(function(res)&#123; // 获取结果后渲染数据 App.renderRecording(res); &#125;) .fail(function(res)&#123; App.error(res); &#125;);&#125;); 5 注意事项 jQuery的Promise主要是用了jQquery的$.Derferred()方法，一些老版本的jquery并不支持此方法。 jQuery版本必须大于等于1.5，推荐使用1.11.3 6 参考文献 jquery官方api文档 jquery维基百科文档 7 最后以上文章仅供参考，不包完全正确。欢迎评论，3q。]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的JavaScript最佳实践]]></title>
    <url>%2Fjs-best-practices.html</url>
    <content type="text"><![CDATA[可维护性 很多时候，我们不是从零开始，开发新代码。而是去维护别人的代码，以他人的工作成果为基础。确保自己的代码可维护，是赠人玫瑰，手留余香的好事。一方面让别人看的舒服，另一方面也防止自己长时间没看过自己的代码，自己都难以理解。 什么是可维护代码可维护的代码的一些特征 可理解易于理解代码的用途 可适应数据的变化，不需要完全重写代码 可扩展要考虑未来对核心功能的扩展 可调试给出足够的信息，让调试的时候，确定问题所在 不可分割函数的功能要单一，功能粒度不可分割，可复用性增强 代码约定可读性 统一的缩进方式 注释 空白行 缩进： 一般使用4个空格 不用制表符的原因是它在不同编辑器里显示效果不同 注释：哪些地方需要注释？ 函数和方法 大段代码 复杂的算法 hack 空白行：哪些地方需要空白行？ 方法之间 方法里的局部变量和第一个语句之间 单行或者多行注释 方法内衣个逻辑单元之间1234567891011121314151617// Goodif (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125;&#125; 变量名和函数名 There are only two hard problem in Computer Science cache invalidation and naming things.—Phil Karlton 驼峰式命名 变量名以名词开头 方法名以动词开头 常量全部大写 构造函数以大写字母开头 jQuery对象以”$”符号开头 自定义事件处理函数以“on”开头 1234567891011121314151617181920212223242526272829303132333435363738// Goodvar count = 10;var myName = "wdd";var found = true;// Bad: Easily confused with functionsvar getCount = 10;var isFound = true;// Goodfunction getName() &#123; return myName;&#125;// Bad: Easily confused with variablefunction theName() &#123; return myName;&#125;// Bad:var btnOfSubmit = $('#submit');// Good:var $btnOfSubmit = $('#submit');// Bad:给App添加一个处理聊天事件的函数，一般都是和websocket服务端推送消息相关App.addMethod('createChat',function(res)&#123; App.log(res);&#125;);// Bad: 此处调用,这里很容易误以为这个函数是处理创建聊天的逻辑函数App.createChat();// Good: App.addMethod('onCreateChat',function(res)&#123; App.log(res);&#125;);// Good：此处调用App.onCreateChat(); 变量命名不仅仅是一种科学，更是一种艺术。总之，要短小精悍，见名知意。有些名词可以反应出变量的类型。 变量名 名词 数据类型含义 count, length,size 数值 name, title,message 字符串 i, j, k 用来循环 car,person,student,user 对象 success,fail 布尔值 payload post数据的请求体 method 请求方式 函数名 动词 含义 can Function returns a boolean has Function returns a boolean is Function returns a boolean get Function returns a nonboolean set Function is used to save a value 一些与函数名搭配的常用动词 动词 用法 send 发送 resend 重发 validate 验证 query 查询 create 创建 add 添加 delete 删除 remove 移除 insert 插入 update 更新，编辑 copy 复制 render 渲染 close 关闭 open 开启 clear 清除 edit 编辑 query 查询 on 当事件发生 list 渲染一个列表，如用户列表renderUsersList() content 渲染内容，如用户详情的页面 renderUserContent() 接口常用的动词对于http请求的最常用的四种方法，get,post,put,delete，有一些常用的名词与其对应 含义 请求方法 词语 栗子 增加 post create createUser,createCall 删除 delete delete deleteUser 修改 put update updateUser,updateProfile 查询 get get,query getUser,queryUser(无条件查询使用get，有条件查询使用query) 学会使用单复数命名函数 函数名 含义 getUser() 获取一个用户，一般是通过唯一的id来获取 getUsers() 获取一组用户，一般是通过一些条件来获取 createUser() 创建一个用户 createUsers() 创建一组用户 常量12var MAX_COUNT = 10;var URL = "http://www.nczonline.net/"; 构造函数12345678// Goodfunction Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var me = new Person("wdd"); 底层http请求接口函数 建议使用“_”开头，例如App._getUsers();而对于接口函数的封装，例如App.getUsers(),内部逻辑调用App._getUsers(); 文件名 全部使用小写字母 单词之间的间隔使用“-” eg：123app-main.jsapp-event.jsapp-user-manger.js 文件归类自己写的js文件最好和引用的一些第三方js分别放置在不同的文件夹下。 千万别用alertalert的缺点 如果你用alert来显示提醒消息，那么用户除了点击alert上的的确定按钮外，就只能点击上面的关闭，或者选择禁止再选择对话框，除此以外什么都不能操作。 有些浏览器如果禁止了alert的选项，那么你的alert是不会显示的 如果你在try catch语句里使用alert，那么console里将不会输出错误信息，你都没办法查看错误的详细原因，以及储出错的位置。 更优雅的提醒方式 console.log() 普通提示消息 console.error() 错误提示消息 console.info() 信息提示消息 console.warn() 警告提示消息 松散耦合 html文件中尽可能避免写js语句 尽量避免在js更改某个css类的属性，而使用更改类的方法 不要在css中写js的表达式 解耦应用逻辑和事件处理程序 将应用逻辑和事件处理程序的解耦1234567891011//一般事件订阅的写法，以jQuery的写法为栗子$(document).on('click','#btn-get-users',function(event)&#123; event.stopPropagation(); //下面的省略号表示执行获取所有用于并显示在页面上的逻辑 // Bad ... ... ... //&#125;); 如果增加了需求，当点击另外一个按钮的时候，也要执行获取所有用户并显示在页面上，那么上面省略的代码又要复制一份。如果接口有改动，那么需要在两个不同的地方都要修改。所以，应该这样。12345678$(document).on('click','#btn-get-users',function(event)&#123; event.stopPropagation(); //将应用逻辑分离在其他个函数中 // Good App.getUsers(); App.renderUsers();&#125;); 松散解耦规则 不要将event对象传给其他方法，只传递来自event对象中的某些数据 任何事件处理程序都应该只处理事件，然后把处理转交给应用逻辑。 将异步请求和数据处理解耦123456789101112// BadReqApi.tenant.queryUsers(&#123;&#125;,function(res)&#123; if(!res.success)&#123; console.error(res); return; &#125; //对数据的处理 ... ... ...&#125;); 上面代码对数据的处理直接写死在异步请求里面，如果换了一个请求，但是数据处理方式是一样的，那么又要复制一遍数据处理的代码。最好的方式是将数据处理模块化成为一个函数。12345678910// GoodReqApi.tenant.queryUsers(&#123;&#125;,function(res)&#123; if(!res.success)&#123; console.error(res); return; &#125; //对数据的处理 App.renderUsers(res.data);&#125;); 异步请求只处理请求，不处理数据。函数的功能要专一，功能粒度不可分割。 不要将某个变量写死在函数中，尽量使用参数传递进来如果你需要一个函数去验证输入框是否是空，如下。这种方式就会绑定死了这个只能验证id为test的输入框，换成其他的就不行123456789101112131415161718192021// badfunction checkInputIsEmpty()&#123; var value = $('#test').val(); if(value)&#123; return true; &#125; else&#123; return false; &#125;&#125;// good function isEmptyInput(id)&#123; var value = $('#'+id).val(); if(value)&#123; return true; &#125; else&#123; return false; &#125;&#125; 编程实践尊总对象所有权javascript动态性质是的几乎任何东西在任何时间都能更改，这样就很容易覆写了一些默认的方法。导致一些灾难性的后果。如果你不负责或者维护某个对象，那么你就不能对它进行修改。 不要为实例或原型添加属性 不要为实例或者原型添加方法 不要重定义存已存在的方法 避免全局变量避免全局变量的深层原因在于避免作用域污染。 作用域就像空气，你时时刻刻不在呼吸，但你往往感觉不到它的存在。一旦它本污染。你就会感到窒息12345678910111213// Bad 两个全局变量var name = "wdd";funtion getName()&#123; console.log(name);&#125;// Good 一个全局变量var App = &#123; name:"wdd", sayName:funtion()&#123; console.log(this.name);//如果这个函数当做回调数使用，这个this可能指向window, &#125;&#125;; 单一的全局变量便是命名空间的概念，例如雅虎的YUI,jQuery的$等。 避免与null进行比较123456funtion sortArray(values)&#123; // 避免 if(values != null)&#123; values.sort(comparator); &#125;&#125; 123456function sortArray(values)&#123; // 推荐 if(values instanceof Array)&#123; values.sort(compartor); &#125;&#125; 与null进行比较的代码，可以用以下技术进行替换 如果值是一个应用类型，使用instanceof操作符，检查其构造函数 如果值是基本类型，使用typeof检查其类型 如果是希望对象包含某个特定的方法名，则只用typeof操作符确保指定名字的方法存在于对象上。 代码中与null比较越少，就越容易确定代码的目的，消除不必要的错误。 从代码中分离配置文件配置数据是一些硬代码(hardcoded)，看下面的栗子123456function validate(value)&#123; if(!value)&#123; alert('Invalid value'); location.href = '/errors/invalid.php'; &#125;&#125; 上面代码里有两个配置数据，一个是UI字符串(‘Invalid value’),另一个是一个Url(‘/error/invalid.php’)。如果你把他们写死在代码里，那么如果当你需要修改这些地方的时候，那么你必须一处一处的检查并修改，而且还可能会遗漏。 所以第一步是要区分，哪些代码应该写成配置文件的形式？ 显示在UI元素中的字符串 URL 一些重复的唯一值 一些设置变量 任何可能改变的值 一些例子1234var Config = &#123; "MSG_INVALID_VALUE":"Invalid value", "URL_INVALID":"/errors/invalid.php"&#125; 调试信息开关在开发过程中，可能随处留下几个console.log,或者alert语句，这些语句在开发过程中是很有价值的。但是项目一旦进入生产环境，过多的console.log可能影响到浏览器的运行效率，过多的alert会降低程序的用户体验。而我们最好不要在进入生产环境前，一处一处像扫雷一样删除或者注释掉这些调试语句。 最好的方式是设置一个开关。123456789101112131415161718192021//全局命令空间var App = &#123; debug:true, log:function(msg)&#123; if(debug)&#123; console.log(msg); &#125; &#125;, alert:function(msg)&#123; if(debug)&#123; alert(msg); &#125; &#125;&#125;;//使用App.log('获取用户信息成功');App.alert('密码不匹配');//关闭日志输出与alertApp.debug = false; 使用jQuery Promise没使用promise之前的回调函数写法1234567891011121314151617181920212223242526272829// bad：没使用promise之前的回调函数写法function sendRequest(req,successCallback,errorCallback)&#123; var inputData = req.data || &#123;&#125;; inputData = JSON.stringify(inputData); $.ajax(&#123; url:req.base+req.destination, type:req.type || "get", headers:&#123; sessionId:session.id &#125;, data:inputData, dataType:"json", contentType : 'application/json; charset=UTF-8', success:function(data)&#123; successCallback(data); &#125;, error:function(data)&#123; console.error(data); errorCallback(data); &#125; &#125;);&#125;//调用sendRequest(req,function(res)&#123; ...&#125;,function(res)&#123; ...&#125;); 使用promise之后12345678910111213141516171819202122232425262728293031323334function sendRequest(req)&#123; var dfd = $.Deferred(); var inputData = req.data || &#123;&#125;; inputData = JSON.stringify(inputData); $.ajax(&#123; url:req.base+req.destination, type:req.type || "get", headers:&#123; sessionId:session.id &#125;, data:inputData, dataType:"json", contentType : 'application/json; charset=UTF-8', success:function(data)&#123; dfd.resolve(data); &#125;, error:function(data)&#123; dfd.reject(data); &#125; &#125;); return dfd.promise();&#125;//调用sendRequest(req).done(function()&#123; //请求成功 ...&#125;).fail(function()&#123; //请求失败 ...&#125;); 显示错误提醒，不要给后端接口背锅假如前端要去接口获取用户信息并显示出来，如果你的请求格式是正确的，但是接口返回400以上的错误，你必须通过提醒来告知测试，这个错误是接口的返回错误，而不是前端的逻辑错误。 REST化接口请求 对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。 对应方式 请求类型 接口前缀 GET .get, POST .create 或者 .get PUT .update DELETE .delete 说明 有些接口虽然是获取某一个资源，但是它使用的却是POST请求，所以建议使用.get比较好 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 与用户相关的接口App.api.user = &#123;&#125;;// 获取一个用户: 一般来说是一个指定的Id，例如userIdApp.api.user.getUser = function()&#123; ...&#125;;// 获取一组用户: 一般来说是一些条件，获取条件下的用户，筛选符合条件的用户App.api.user.getUsers = function()&#123; ...&#125;;// 创建一个用户App.api.user.createUser = function()&#123; &#125;;// 创建一组用户App.api.user.createUsers = function()&#123; &#125;;// 更新一个用户App.api.user.updateUser = function()&#123; &#125;;// 更新一组用户App.api.user.updateUsers = function()&#123; &#125;;// 更新一个用户App.api.user.updateUser = function()&#123; &#125;;// 更新一组用户App.api.user.updateUsers = function()&#123; &#125;;// 删除一个用户App.api.user.deleteUser = function()&#123; &#125;;// 删除一组用户App.api.user.deleteUsers = function()&#123; &#125;; 性能注意作用域 避免全局查找 避免with语句 选择正确的方法 优化循环 减值迭代：从最大值开始，在循环中不断减值的迭代器更加高效 简化终止条件：由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是避免其他属性查找 简化循环体：由于循环体是执行最多的，所以要确保其最大限度地优化。 展开循环 避免双重解释： 12345678// **Bad** 某些代码求值eval("alert('hello')");// **Bad** 创建新函数var sayHi = new Function("alert('hello')");// **Bad** 设置超时setTimeout("alert('hello')"); 性能的其他注意事项 原生方法较快 switch语句较快：可以适当的替换ifelse语句case 的分支不要超过128条 位运算符较快 最小化语句数多个变量声明(废弃)1234567891011// 方式1：Badvar count = 5;var name = 'wdd';var sex = 'male';var age = 10;// 方式2：Goodvar count = 5, name = 'wdd', sex = 'male', age = 10; 2017-03-07 理论上方式2可能要比方式1性能高一点。但是我在实际使用中，这个快一点几乎是没什么感受的。就像你无法感受到小草的生长一样。反而可读性更为重要。所以，每行最好只定义一个变量，并且每行都有一个var,并用分号结尾。 插入迭代值12// Goodvar name = values[i++]; 使用数组和对象字面量1234567// Goodvar values = ['a','b','c'];var person = &#123; name:'wdd', age:10&#125;; 只要有可能，尽量使用数组和对象字面量的表达式来消除不必要的语句 优化DOM交互 在JavaScript各个方面中，DOM无疑是最慢的一部分。DOM操作与交互要消耗大量的时间。因为他们往往需要重新渲染整个页面或者某一部分。进一步说，看似细微的操作也可能花很久来执行。因为DOM要处理非常多的信息。理解如何优化与DOM的交互可以极大的提高脚本完成的速度。 使用dom缓存技术 最小化现场更新 使用innerHTML插入大段html 使用事件代理 Dom缓存技术调用频率非常高的dom查找，可以将DOM缓存在于一个变量中1234567// 最简单的dom缓存var domCache = &#123;&#125;;function myGetElement(tag)&#123; return domCache[tag] = domCache[tag] || $(tag);&#125; 避免过长的属性查找，设置一个快捷方式12345678910// 先看下面的极端情况app.user.mother.parent.home.name = 'wdd'app.user.mother.parent.home.adderess = '上海'app.user.mother.parent.home.weather = '晴天'// 更优雅的方式var home = app.user.mother.parent.home;home.name = 'wdd';home.address = '上海',home.weather = '晴天' 注意使用上面的方式是有前提的，必须保证app.user.mather.parent.home是一个对象，因为对象是传递的引用。如果他的类型是一个基本类型，例如：number,string,boolean，那么复制操作仅仅是值传递，新定义的home的改变，并不会影响到app.user.mather.parent.home的改变。 快捷方式字符串转数字1+'4.1' === 4.1 数字转字符14.1+'' === '4.1' 字符串取整1'4.99' | 0 === 4 推荐深度阅读关于技术 《编写可读代码的艺术》 《编写可维护的JavaScript》 《JavaScript忍者秘籍》 《JavaScript: The Good Parts》 Writing Fast, Memory-Efficient JavaScript JavaScript 秘密花园 You-Dont-Know-JS 《HTTP权威指南》 Caching Tutorial for Web Authors and Webmasters 技术之外 《筑巢引凤-高黏度社会化网站设计秘诀》 《黑客与画家》 《大秦帝国》 参考文献 JavaScript高级程序设计(第3版) 【美】尼古拉斯·泽卡斯 Maintainable JavaScript (英文版) Nicholas C. Zakas(其实和上边那本书应该是同一个人) JavaScript忍者秘籍 John Resig / Bear Bibeault （John Resig 大名鼎鼎jQuery的创造者） 百度前端研发部 文档与源码编写风格]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>

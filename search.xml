<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何去获取一个js.org的二级域名]]></title>
    <url>%2F2018%2F01%2F29%2Fhow-to-get-jsorg-sub-domain%2F</url>
    <content type="text"><![CDATA[之前我是使用wangduanduan.github.io作为我的博客地址，后来觉得麻烦，有把博客关了。最近有想去折腾折腾。先看效果：wdd.js.org 前提 已经有了github pages的一个博客，并且博客中有内容，没有内容会审核不通过的。我第一次申请域名，就是因为内容太少而审核不通过。 想好自己要什么域名？比如你想要一个：wdd.js.org的域名，你先在浏览器里访问这个地址，看看有没有人用过，如果已经有人用过，那么你就只能想点其他的域名了。 fork js.org的项目，添加自己的域名1 fork https://github.com/js-org/dns.js.org2 修改你fork后的仓库中的cnames_active.js文件，加上自己的一条域名，最好要按照字母顺序 如下图所示，我在第1100行加入。注意，不要在该行后加任何注释。1"wdd": "wangduanduan.github.io", 3 commit 加入CNAME文件我是用hexo和next主题作为博客的模板。其中我在gh-pages分支写博客，然后部署到master分支。 我在我的gh-pages分支的source目录下加入CNAME文件, 内容只有一行 1wdd.js.org 将博客再次部署好，如果CNAME生效的话，你已经无法从原来的地址访问：wangduanduan.github.io， 这个博客了。 向js.org项目发起pull-request找到你fork后的项目，点击 new pull request, 向原来的项目发起请求。 然后你可以在js-org/dns.js.org项目的pull requests看到你的请求，当这个请求被合并时，你就拥有了js.org的二级域名。]]></content>
      <tags>
        <tag>jsorg</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不常用却很有妙用的事件及方法]]></title>
    <url>%2F2018%2F01%2F29%2Fbrowser-events%2F</url>
    <content type="text"><![CDATA[visibilitychange事件触发条件：浏览器标签页被隐藏或显示的时候会触发visibilitychange事件. 使用场景：当标签页显示或者隐藏时，触发一些业务逻辑 123document.addEventListener("visibilitychange", function() &#123; console.log( document.visibilityState );&#125;); storage事件触发条件：使用localStorage or sessionStorage存储或者修改某个本地存储时 使用场景：标签页间通信 123456789// AB页面同源// 在A 页面window.addEventListener('storage', (e) =&gt; &#123;console.log(e)&#125;)// 在B 页面，向120打个电话localStorage.setItem('makeCall','120')// 然后可以在A页面间有输出, 可以看出A页面 收到了B页面的通知...key: "makeCall", oldValue: "119", newValue: "120", ... beforeunload事件触发条件：当页面的资源将要卸载(及刷新或者关闭标签页前). 当页面依然可见，并且该事件可以被取消只时 使用场景：关闭或者刷新页面时弹窗确认，关闭页面时向后端发送报告等 123456window.addEventListener("beforeunload", function (e) &#123; var confirmationMessage = "\o/"; e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+ return confirmationMessage; // Gecko, WebKit, Chrome &lt;34&#125;); navigator.sendBeacon这个方法主要用于满足 统计和诊断代码 的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。过早的发送数据可能导致错过收集数据的机会。然而， 对于开发者来说保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在卸载事件处理器中产生的异步 XMLHttpRequest 。 使用 sendBeacon() 方法，将会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：使它可靠，异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单！ 注意：该方法在IE和safari没有实现 使用场景：发送崩溃报告 12345window.addEventListener('unload', logData, false);function logData() &#123; navigator.sendBeacon("/log", analyticsData);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nodejs 服务端框架合集(78个)]]></title>
    <url>%2F2018%2F01%2F29%2Fnodejs-server-frameworks%2F</url>
    <content type="text"><![CDATA[没有什么事情是一个框架解决不了的，如果有，就再找一个。 Photo by 贝莉儿 NG on Unsplash 1 MVC frameworks1.1 Sinatra-like这些框架提供了丰富的配置，比Rails-like或full-stack少。 Express hapi flatiron locomotive total.js koa.js TWEE.IO diet.js Flicker.js ZinkyJS 1.2 Rails-like正确呈现您的项目。从包含的模板创建自己的艺术 Nodal Strapi CompoundJS geddy Sails.js Adonis RhapsodyJS ThinkJS Trails KambojaJS JS-Web 2 Full-stack frameworks这就是Node.js真正闪耀的地方。全栈MVC框架与脚手架，模板引擎，websocket和持久性库捆绑在一起，允许您构建实时可伸缩的Web应用程序。 Catberry.js AllcountJS Derby Feathers SocketCluster SocketStream MEAN.js MEAN.io Meteor Meatier TWEE.IO Mojito Seeds.js SANE COKE Sleekjs Danf Catberry Nuke.js We.js seneca.js Keystone.js Horizon Apogeu 3 REST API frameworks对于那些使用富客户端/前端MVC框架（或不）的客户，只需要启动一个快速的Node.js REST API服务器即可。 Ivy Restocat actionHero.js Frisby restling restify restmvc percolator LoopBack Fortune.js facet Raddish Restberry Gugamarket Nest microlet Moleculer 4 Other libraries中间件，库和静态站点生成器。 Connect Kraken ewdGateway2 Wintersmith docpad Blacksmith romulus Petrify Tower.js Impress Rendr Backnode Sequelize Cylon.js Virgilio.js SHPS]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[You-Dont-Need 你不需要系列]]></title>
    <url>%2F2018%2F01%2F29%2Fyou-dont-need%2F</url>
    <content type="text"><![CDATA[You-Dont-Need-JavaScript CSS是强大的，你可以做很多事情没有JS。 本文教你使用原生CSS做下面的事情。 内容目录 手风琴/切换 圆盘传送带 检查复选框的计数器 翻转点击 Textfield上的浮动标签 字体（拉丁） 游戏 悬停/弹出信息 图片廊 菜单 移动菜单关闭画布 汉堡菜单 花式菜单 莫代尔/弹出 鼠标跟踪 视差滚动 标签 待办事项列表 提示 树视图 Twitter心动画 动态图像着色 连锁反应 响应式计数器显示不适合屏幕的项目数量 可以看一下纯CSS的例子 You-Dont-Need-Lodash-Underscore Lodash和Underscore是伟大的现代JavaScript实用程序库，它们被前端开发人员广泛使用。但是，如果您将目标锁定为现代浏览器，则可能会发现，许多方法已经得到ES5和ES6的原生支持。如果你想要你的项目需要更少的依赖，并且你清楚的知道你的目标浏览器，那么你可能不需要Lodash / Underscore。 来自开发者的声音 在代码变臃肿之前，请使用原生JS对象和数组工具函数. —Cody Lindley, Author of jQuery Cookbook and JavaScript Enlightenment 你可能不需要lodash. 有许多好用的原生方法了. —Daniel Lamb, Computer Scientist, Technical Reviewer of Secrets of the JavaScript Ninja and Functional Programming in JavaScript 我想不是，但我想要它. —Tero Parviainen, Author of build-your-own-angular 我承认，我曾经过度使用lodash. —@therebelrobot, Maker of web things, Facilitator for Node.js/io.js 内容目录 Array _.compact _.concat _.fill _.find _.findIndex _.first _.flatten _.flattenDeep .head and .tail _.indexOf _.join _.last _.lastIndexOf _.reverse _.without _.slice _.isArray Collection _.each _.every _.filter _.groupBy _.includes _.map .minBy and .maxBy _.pluck _.range _.reduce _.reduceRight _.size _.some Function _.after Lang _.isNaN Object _.assign _.keys _.toPairs _.values String _.repeat _.template _.toLower _.toUpper _.trim _.replace You-Dont-Need-jQuery纯JavaScript的例子, 实现做jQuery与查询，样式，dom，ajax，事件等 前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10 以上浏览器。 内容目录 Translations Query Selector CSS &amp; Style DOM Manipulation Ajax Events Utilities Promises Animation Alternatives Browser Support You-Dont-Need-GUI图形用户界面对计算机用户非常友好。它们被引入以响应命令行界面（CLI）感知的陡峭学习曲线。 但是，他们往往需要更多的资源，功能不强，难以通过脚本自动化。 作为计算机专家，我们希望更高效，更好地完成工作。我们知道命令字可能不容易被发现或助记符，所以我们尝试列出一些您可能试图在GUI中执行的常见任务。 内容目录 复制一个文件 复制一个文件 复制一个文件夹 复制一个文件夹 移动一个文件 重命名一个文件 移动一个文件夹 重命名文件夹 合并文件夹 创建一个新的文件 新建一个文件夹 显示文件/文件夹大小 用默认程序打开一个文件 压缩一个文件夹 解压缩文件夹 删除一个文件 删除一个文件夹 列出文件夹内容 树查看文件夹及其子文件夹 找到一个陈旧的文件 显示一个日历 找到未来的日期 使用计算器 强制退出程序]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nodejs alpine 基础docker镜像构建]]></title>
    <url>%2F2018%2F01%2F29%2Fnodejs-alpine-docker%2F</url>
    <content type="text"><![CDATA[系统环境 centos7 内核：3.10.0-514.26.2.el7.x86_64 安装docker要求内核版本不低于3.10 安装docker123yum install docker // 安装dockersystemctl start docker.service // 启动dockersystemctl enable docker.service // 设置开机启动 Nodejs 镜像选择 REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/node 9.2.1-slim 69c9f9292fa4 3 days ago 230 MB docker.io/node 9.2.1-alpine afdc3aaaf748 3 days ago 67.46 MB docker.io/node latest 727b047a1f4e 3 days ago 675.6 MB docker.io/iron/node latest 9ca501065d18 20 months ago 18.56 MB 选择镜像的标准 官方的 经常维护的 体积小的 要有yarn 和 npm node版本要高 最终选择 node:9.2.1-alpine, 该镜像体积很小，已经内置npm(5.5.1), yarn(1.3.2) 时区配置node:9.2.1-alpine的时区默认不是国内的，需要在build时，配置时区。 1234567891011FROM node:9.2.1-alpine# Install base packages and set timezone ShangHaiRUN apk update &amp;&amp; apk add bash tzdata \ &amp;&amp; cp -r -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime.........CMD [ "node" ] 验证：123456789➜ node-dockerfile git:(master) docker run -it e595 sh / # yarn -v1.3.2/ # npm -v5.5.1/ # node -vv9.2.1/ # dateTue Dec 12 17:33:26 CST 2017]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vscode中用standard style 风格去验证 vue文件]]></title>
    <url>%2F2018%2F01%2F29%2Fvscode-vue-standardjs%2F</url>
    <content type="text"><![CDATA[JavaScript Standard Style简介本工具通过以下三种方式为你（及你的团队）节省大量时间： 无须配置。 史上最便捷的统一代码风格的方式，轻松拥有。 自动代码格式化。 只需运行 standard –fix 从此和脏乱差的代码说再见。 提前发现风格及程序问题。 减少代码审查过程中反反复复的修改过程，节约时间。 无须犹豫。再也不用维护 .eslintrc, .jshintrc, or .jscsrc 。开箱即用。 安装：1npm i standard -g 关于JavaScript 代码规范, 你可以点击链接看一下。 如何在vscode中用JavaScript Standard Style风格去验证 vue文件实际上JavaScript Standard Style有一个FAQ, 说明了如何使用。 但是有一点非常重要的作者没有提到，就是eslint-plugin-html这个插件必须要安装3.x.x版本的, 现在eslint-plugin-html, 已经升级到4.x版本，默认不写版本号安装的就是4.x版本的，所以会出现问题。参考 ESLint v4 is only supported by eslint-plugin-html v3, so you can’t use eslint-plugin-html v1.5.2 with it (I should add a warning about this when trying to use the plugin with an incompatible version on ESLint). If you do not use ESLint v4, please provide more information (package.json, a gist to reproduce, …) 1234567891011121314151617181920212223242526// FAQHow to lint script tag in vue or html files?You can lint them with eslint-plugin-html, just install it first, then enable linting for those file types in settings.json with: "standard.validate": [ "javascript", "javascriptreact", "html" ], "standard.options": &#123; "plugins": ["html"] &#125;, "files.associations": &#123; "*.vue": "html" &#125;,If you want to enable autoFix for the new languages, you should enable it yourself: "standard.validate": [ "javascript", "javascriptreact", &#123; "language": "html", "autoFix": true &#125; ], "standard.options": &#123; "plugins": ["html"] &#125; 综上， 整理一下安装思路需要安装哪些包？ npm i -g standard npm i -g eslint-plugin-html@3.2.2 必须是3x版本 npm i -g eslint以上三个包都是全局安装的，如果你想看看全局安装了哪些包可以用npm list -g --depth=0查看 vscode config 如何写？1234567891011121314"standard.validate": [ "javascript", "javascriptreact", &#123; "language": "html", "autoFix": true &#125;],"standard.options": &#123; "plugin": ["html"]&#125;,"files.associations": &#123; "*.vue": "html"&#125;, 如何在保存文件时，自动使用standard格式化vue文件1"standard.autoFixOnSave": true 如果还不行怎么办？ 重启一下vscode 重启一下电脑 在此文后追加评论]]></content>
      <tags>
        <tag>vue</tag>
        <tag>standardjs</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[油猴子脚本 - 我的地盘我做主]]></title>
    <url>%2F2018%2F01%2F29%2Ftampermonkey%2F</url>
    <content type="text"><![CDATA[当你用浏览器访问某个网页时，你可曾想过，你看到的这个网页，实际上是属于你自己的。 打个比喻：访问某个网站就好像是网购了一筐鸡蛋，鸡蛋虽然是养鸡场生产的，但是这个蛋我怎么吃，你养鸡场管不着。 当然了，对于很多人来说，鸡蛋没有别的吃法，鸡蛋只能煮着吃。 你可以看如下的页面：当你在某搜索引擎上搜索前端开发时 大多数人看到的页面是这样的, 满屏的广告，满屏的推广，满屏的排名，满屏的中间地址跳转，满屏的流量劫持, 还有莆田系 但是有些人的页面却是这样的：清晰，自然，链接直达，清水出芙蓉，天然去雕饰 这就是油猴子脚本干的事情， 当然，它能干的事情，远不止如此。它是齐天大圣孙悟空，有七十二变。 什么是油猴子脚本？ Greasemonkey，简称GM，中文俗称为“油猴”，是Firefox的一个附加组件。它让用户安装一些脚本使大部分HTML为主的网页于用户端直接改变得更方便易用。随着Greasemonkey脚本常驻于浏览器，每次随着目的网页打开而自动做修改，使得运行脚本的用户印象深刻地享受其固定便利性。 Greasemonkey可替网页加入些新功能（例如在亚马逊书店嵌入商品比价功能）、修正网页错误、组合来自不同网页的数据、或者数繁不及备载的其他功能。写的好的Greasemonkey脚本甚至可让其输出与被修改的页面集成得天衣无缝，像是原本网页里的一部分。 来自维基百科 如何安装油猴子插件？在google商店搜索Tampermonkey, 安装量最高的就是它。 如何写油猴子脚本？油猴子脚本有个新建脚本页面，在此页面可以创建脚本。具体教程可以参考。 中文 GreaseMonkey 用户脚本开发手册 GreaseMonkey（油猴子）脚本开发 深入浅出 Greasemonkey Greasemonkey Hacks/Getting Started 如何使用他人的脚本？greasyfork网站提供很多脚本，它仿佛是代码界的github, 可以在该网站搜到很多有意思的脚本。 有哪些好用的脚本？ 有哪些超神的油猴脚本? 或者你可以在greasyfork网站查看一些下载量排行]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】一个值得所有前端开发者关注的网站 js.org]]></title>
    <url>%2F2018%2F01%2F29%2Fjs-org%2F</url>
    <content type="text"><![CDATA[二十年后，域js.org第一次注册，它终于服务于其明显的目的 - JavaScript社区。 从一开始，对JavaScript的看法各不相同 - 有些人喜欢的语言，有人讨厌它。但是，对于使JavaScript成为最受欢迎的编程语言之一的社区的威力，应该毫无疑问。为了与社区的自由开放的心态保持一致，JS.ORG为开发人员及其项目免费提供了子域名。自第一步以来，我们还专注于跟踪JavaScript趋势并传播有关它的新闻。 贡献是欢迎：如果你有热情开始一个合作项目，或者如果你想成为JS.ORG的成员，并贡献JS.ORG，随时与我联系。 DNS 如果您是JavaScript开发人员，您可能已经听说过 - 或者甚至已经使用GitHub页面来托管您的内容。 DNS.JS.ORG补充GitHub提供的免费网络空间，并提供了一个适合您项目的自由和时尚的网址。 STARTS STATS.JS.ORG获取GitHub上最重要的JavaScript项目的统计参数，并将它们填充到10k行的巨型表中。这个项目旨在使JavaScript的趋势可见。 NEWS你有什么东西要与社区分享或想阅读其他JavaScript爱好者的东西吗？ NEWS.JS.ORG提供了一种方便的传播，消费和讨论JavaScript项目。 WASMWebAssembly（或简称wasm）是一种用于Web平台上的低级代码的新的二进制语法。 WASM.NEWS是JS.ORG计划的一个分支，并作为这个即将到来的主题的新闻聚合。]]></content>
      <tags>
        <tag>js.org</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[追本溯源：substr与substring历史漫话]]></title>
    <url>%2F2018%2F01%2F29%2Fsubstr-and-substring-history%2F</url>
    <content type="text"><![CDATA[引子： 很多时候，当我要字符串截取时，我会想到substr和substring的方法，但是具体要怎么传参数时，我总是记不住。哪个应该传个字符串长度，哪个又应该传个开始和结尾的下标，如果我不去查查这两个函数，我始终不敢去使用它们。所以我总是觉得，这个两个方法名起的真是蹩脚。然而事实是这样的吗？ 看来是时候扒一扒这两个方法的历史了。 1 基因追本溯源 在编程语言的历史长河中，曾经出现过很多编程语言。然而大浪淘沙，铅华洗尽之后，很多早已折戟沉沙，有些却依旧光彩夺目。那么stubstr与substring的DNA究竟来自何处？ 1950与1960年代 1954 - FORTRAN 1958 - LISP 1959 - COBOL 1964 - BASIC 1970 - Pascal 1967-1978：确立了基础范式 1972 - C语言 1975 - Scheme 1978 - SQL (起先只是一种查询语言，扩充之后也具备了程序结构) 1980年代：增强、模块、性能 1983 - C++ (就像有类别的C) 1988 - Tcl 1990年代：互联网时代 1991 - Python 1991 - Visual Basic 1993 - Ruby 1995 - Java 1995 - Delphi (Object Pascal) 1995 - JavaScript 1995 - PHP 2009 - Go 2014 - Swift (编程语言) 1.1 在C++中首次出现substr() 在c语言中，并没有出现substr或者substring方法。然而在1983，substr()方法已经出现在C++语言中了。然而这时候还没有出现substring, 所以可以见得：substr是stustring的老大哥 1string substr (size_t pos = 0, size_t len = npos) const; 从C++的方法定义中可以看到, substr的参数是开始下标，以及字符串长度。 12std::string str="We think in generalities, but we live in details.";std::string str2 = str.substr (3,5); // "think" 1.2 在Java中首次出现substring() 距离substr()方法出现已经有了将近十年之隔，此间涌现一批后起之秀，如: Python, Ruby, VB之类，然而他们之中并没有stustring的基因，在Java的String类中，我们看到两个方法。从这两个方法之中我们可以看到：substring方法基本原型的参数是开始和结束的下标。 1234String substring(int beginIndex) // 返回一个新的字符串，它是此字符串的一个子字符串。String substring(int beginIndex, int endIndex)// 返回一个新字符串，它是此字符串的一个子字符串。 1.3 JavaScript的历史继承 1995年，网景公司招募了Brendan Eich，目的是将Scheme编程语言嵌入到Netscape Navigator中。在开始之前，Netscape Communications与Sun Microsystems公司合作，在Netscape Navigator中引入了更多的静态编程语言Java，以便与微软竞争用户采用Web技术和平台。网景公司决定，他们想创建的脚本语言将补充Java，并且应该有一个类似的语法，排除采用Perl，Python，TCL或Scheme等其他语言。为了捍卫对竞争性提案的JavaScript的想法，公司需要一个原型。 1995年5月，Eich在10天内写完。 上帝用七天时间创造万物, Brendan Eich用10天时间创造了一门语言。或许用创造并不合适，因为JavaScript是站在了Perl，Python，TCL或Scheme等其他巨人的肩膀上而产生的。 JavaScript并不像C那样出身名门，在贝尔实验室精心打造，但是JavaScript在往后的自然选择中，并没有因此萧条，反而借助于C,C++, Java, Perl，Python，TCL, Scheme优秀基因，进化出更加强大强大的生命力。 因此可以想象，在10天之内，当Brendan Eich写到String的substr和substring方法时，或许他并没困惑着两个方法的参数应该如何设置，因为在C++和Java的实现中，已经有了类似的定义。 如果你了解历史，你就不会困惑现在。 2 所以，substr和substring究竟有什么不同？如下图所示：substr和substring都接受两个参数，他们的第一个参数的含义是相同的，不同的是第二个参数。substr的第二个参数是到达结束点的距离，substring是结束的位置。 3 参考文献 维基百科：程式語言歷史 C++ std::string::substr JavaScript 如有不正确的地方，欢迎指正。]]></content>
      <tags>
        <tag>substr</tag>
        <tag>substring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熟练使用使用jQuery Promise (Deferred)]]></title>
    <url>%2F2018%2F01%2F29%2Fjquery-deferred%2F</url>
    <content type="text"><![CDATA[1 情景再现以前用nodejs写后端程序时，遇到Promise这个概念，这个东西好呀！不用谢一层一层回调，直接用类似于jQuery的连缀方式。后来遇到bluebird这个库，它就是Promise库中很有名的。我希望可以把Promise用在前端的ajax请求上，但是我不想又引入bluebird。后来发现，jquery本身就具有类似于Promise的东西。于是我就jquery的Promise写一些异步请求。 2 不堪回首看看一看我以前写异步请求的方式12345678910111213141516171819202122// 函数定义function sendRequest(req,successCallback,errorCallback)&#123; $.ajax(&#123; ... ... success:function(res)&#123; successCallback(res); &#125;, error:function(res)&#123; errorCallback(res); &#125; &#125;);&#125;// 函数调用,这个函数的匿名函数写的时候很容易出错，而且有时候难以理解sendRequest(req,function(res)&#123; //请求成功 ...&#125;,function(res)&#123; //请求失败 ...&#125;); 3 面朝大海下面是我希望的异步调用方式123456789sendRequest(req).done(function(res)&#123; //请求成功 ...&#125;).fail(function(req)&#123; //请求失败 ...&#125;); 4 废话少说，放‘码’过来 talk is cheap, show me the code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 最底层的发送异步请求，做成Promise的形式App.addMethod('_sendRequest',function(path,method,payload)&#123; var dfd = $.Deferred(); $.ajax(&#123; url:path, type:method || "get", headers:&#123; sessionId:session.id || '' &#125;, data:JSON.stringify(payload), dataType:"json", contentType : 'application/json; charset=UTF-8', success:function(data)&#123; dfd.resolve(data); &#125;, error:function(data)&#123; dfd.reject(data); &#125; &#125;); return dfd.promise();&#125;);//根据callId查询录音文件，不仅仅是异步请求可以做成Promise形式，任何函数都可以做成Promise形式App.addMethod('_getRecordingsByCallId',function(callId)&#123; var dfd = $.Deferred(), path = '/api/tenantcalls/'+callId+'/recordings'; App._sendRequest(path) .done(function(res)&#123;dfd.resolve(res);&#125;) .fail(function(res)&#123;dfd.reject(res);&#125;); return dfd.promise();&#125;);// 获取录音App.addMethod('getCallDetailRecordings',function(callId)&#123; App._getRecordingsByCallId(callId) .done(function(res)&#123; // 获取结果后渲染数据 App.renderRecording(res); &#125;) .fail(function(res)&#123; App.error(res); &#125;);&#125;); 5 注意事项 jQuery的Promise主要是用了jQquery的$.Derferred()方法，一些老版本的jquery并不支持此方法。 jQuery版本必须大于等于1.5，推荐使用1.11.3 6 参考文献 jquery官方api文档 jquery维基百科文档 7 最后以上文章仅供参考，不包完全正确。欢迎评论，3q。]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的JavaScript最佳实践]]></title>
    <url>%2F2018%2F01%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[可维护性 很多时候，我们不是从零开始，开发新代码。而是去维护别人的代码，以他人的工作成果为基础。确保自己的代码可维护，是赠人玫瑰，手留余香的好事。一方面让别人看的舒服，另一方面也防止自己长时间没看过自己的代码，自己都难以理解。 什么是可维护代码可维护的代码的一些特征 可理解易于理解代码的用途 可适应数据的变化，不需要完全重写代码 可扩展要考虑未来对核心功能的扩展 可调试给出足够的信息，让调试的时候，确定问题所在 不可分割函数的功能要单一，功能粒度不可分割，可复用性增强 代码约定可读性 统一的缩进方式 注释 空白行 缩进： 一般使用4个空格 不用制表符的原因是它在不同编辑器里显示效果不同 注释：哪些地方需要注释？ 函数和方法 大段代码 复杂的算法 hack 空白行：哪些地方需要空白行？ 方法之间 方法里的局部变量和第一个语句之间 单行或者多行注释 方法内衣个逻辑单元之间1234567891011121314151617// Goodif (wl &amp;&amp; wl.length) &#123; for (i = 0, l = wl.length; i &lt; l; ++i) &#123; p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) &#123; if (merge &amp;&amp; type == 'object') &#123; Y.mix(r[p], s[p]); &#125; else if (ov || !(p in r)) &#123; r[p] = s[p]; &#125; &#125; &#125;&#125; 变量名和函数名 There are only two hard problem in Computer Science cache invalidation and naming things.—Phil Karlton 驼峰式命名 变量名以名词开头 方法名以动词开头 常量全部大写 构造函数以大写字母开头 jQuery对象以”$”符号开头 自定义事件处理函数以“on”开头 1234567891011121314151617181920212223242526272829303132333435363738// Goodvar count = 10;var myName = "wdd";var found = true;// Bad: Easily confused with functionsvar getCount = 10;var isFound = true;// Goodfunction getName() &#123; return myName;&#125;// Bad: Easily confused with variablefunction theName() &#123; return myName;&#125;// Bad:var btnOfSubmit = $('#submit');// Good:var $btnOfSubmit = $('#submit');// Bad:给App添加一个处理聊天事件的函数，一般都是和websocket服务端推送消息相关App.addMethod('createChat',function(res)&#123; App.log(res);&#125;);// Bad: 此处调用,这里很容易误以为这个函数是处理创建聊天的逻辑函数App.createChat();// Good: App.addMethod('onCreateChat',function(res)&#123; App.log(res);&#125;);// Good：此处调用App.onCreateChat(); 变量命名不仅仅是一种科学，更是一种艺术。总之，要短小精悍，见名知意。有些名词可以反应出变量的类型。 变量名 名词 数据类型含义 count, length,size 数值 name, title,message 字符串 i, j, k 用来循环 car,person,student,user 对象 success,fail 布尔值 payload post数据的请求体 method 请求方式 函数名 动词 含义 can Function returns a boolean has Function returns a boolean is Function returns a boolean get Function returns a nonboolean set Function is used to save a value 一些与函数名搭配的常用动词 动词 用法 send 发送 resend 重发 validate 验证 query 查询 create 创建 add 添加 delete 删除 remove 移除 insert 插入 update 更新，编辑 copy 复制 render 渲染 close 关闭 open 开启 clear 清除 edit 编辑 query 查询 on 当事件发生 list 渲染一个列表，如用户列表renderUsersList() content 渲染内容，如用户详情的页面 renderUserContent() 接口常用的动词对于http请求的最常用的四种方法，get,post,put,delete，有一些常用的名词与其对应 含义 请求方法 词语 栗子 增加 post create createUser,createCall 删除 delete delete deleteUser 修改 put update updateUser,updateProfile 查询 get get,query getUser,queryUser(无条件查询使用get，有条件查询使用query) 学会使用单复数命名函数 函数名 含义 getUser() 获取一个用户，一般是通过唯一的id来获取 getUsers() 获取一组用户，一般是通过一些条件来获取 createUser() 创建一个用户 createUsers() 创建一组用户 常量12var MAX_COUNT = 10;var URL = "http://www.nczonline.net/"; 构造函数12345678// Goodfunction Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var me = new Person("wdd"); 底层http请求接口函数 建议使用“_”开头，例如App._getUsers();而对于接口函数的封装，例如App.getUsers(),内部逻辑调用App._getUsers(); 文件名 全部使用小写字母 单词之间的间隔使用“-” eg：123app-main.jsapp-event.jsapp-user-manger.js 文件归类自己写的js文件最好和引用的一些第三方js分别放置在不同的文件夹下。 千万别用alertalert的缺点 如果你用alert来显示提醒消息，那么用户除了点击alert上的的确定按钮外，就只能点击上面的关闭，或者选择禁止再选择对话框，除此以外什么都不能操作。 有些浏览器如果禁止了alert的选项，那么你的alert是不会显示的 如果你在try catch语句里使用alert，那么console里将不会输出错误信息，你都没办法查看错误的详细原因，以及储出错的位置。 更优雅的提醒方式 console.log() 普通提示消息 console.error() 错误提示消息 console.info() 信息提示消息 console.warn() 警告提示消息 松散耦合 html文件中尽可能避免写js语句 尽量避免在js更改某个css类的属性，而使用更改类的方法 不要在css中写js的表达式 解耦应用逻辑和事件处理程序 将应用逻辑和事件处理程序的解耦1234567891011//一般事件订阅的写法，以jQuery的写法为栗子$(document).on('click','#btn-get-users',function(event)&#123; event.stopPropagation(); //下面的省略号表示执行获取所有用于并显示在页面上的逻辑 // Bad ... ... ... //&#125;); 如果增加了需求，当点击另外一个按钮的时候，也要执行获取所有用户并显示在页面上，那么上面省略的代码又要复制一份。如果接口有改动，那么需要在两个不同的地方都要修改。所以，应该这样。12345678$(document).on('click','#btn-get-users',function(event)&#123; event.stopPropagation(); //将应用逻辑分离在其他个函数中 // Good App.getUsers(); App.renderUsers();&#125;); 松散解耦规则 不要将event对象传给其他方法，只传递来自event对象中的某些数据 任何事件处理程序都应该只处理事件，然后把处理转交给应用逻辑。 将异步请求和数据处理解耦123456789101112// BadReqApi.tenant.queryUsers(&#123;&#125;,function(res)&#123; if(!res.success)&#123; console.error(res); return; &#125; //对数据的处理 ... ... ...&#125;); 上面代码对数据的处理直接写死在异步请求里面，如果换了一个请求，但是数据处理方式是一样的，那么又要复制一遍数据处理的代码。最好的方式是将数据处理模块化成为一个函数。12345678910// GoodReqApi.tenant.queryUsers(&#123;&#125;,function(res)&#123; if(!res.success)&#123; console.error(res); return; &#125; //对数据的处理 App.renderUsers(res.data);&#125;); 异步请求只处理请求，不处理数据。函数的功能要专一，功能粒度不可分割。 不要将某个变量写死在函数中，尽量使用参数传递进来如果你需要一个函数去验证输入框是否是空，如下。这种方式就会绑定死了这个只能验证id为test的输入框，换成其他的就不行123456789101112131415161718192021// badfunction checkInputIsEmpty()&#123; var value = $('#test').val(); if(value)&#123; return true; &#125; else&#123; return false; &#125;&#125;// good function isEmptyInput(id)&#123; var value = $('#'+id).val(); if(value)&#123; return true; &#125; else&#123; return false; &#125;&#125; 编程实践尊总对象所有权javascript动态性质是的几乎任何东西在任何时间都能更改，这样就很容易覆写了一些默认的方法。导致一些灾难性的后果。如果你不负责或者维护某个对象，那么你就不能对它进行修改。 不要为实例或原型添加属性 不要为实例或者原型添加方法 不要重定义存已存在的方法 避免全局变量避免全局变量的深层原因在于避免作用域污染。 作用域就像空气，你时时刻刻不在呼吸，但你往往感觉不到它的存在。一旦它本污染。你就会感到窒息12345678910111213// Bad 两个全局变量var name = "wdd";funtion getName()&#123; console.log(name);&#125;// Good 一个全局变量var App = &#123; name:"wdd", sayName:funtion()&#123; console.log(this.name);//如果这个函数当做回调数使用，这个this可能指向window, &#125;&#125;; 单一的全局变量便是命名空间的概念，例如雅虎的YUI,jQuery的$等。 避免与null进行比较123456funtion sortArray(values)&#123; // 避免 if(values != null)&#123; values.sort(comparator); &#125;&#125; 123456function sortArray(values)&#123; // 推荐 if(values instanceof Array)&#123; values.sort(compartor); &#125;&#125; 与null进行比较的代码，可以用以下技术进行替换 如果值是一个应用类型，使用instanceof操作符，检查其构造函数 如果值是基本类型，使用typeof检查其类型 如果是希望对象包含某个特定的方法名，则只用typeof操作符确保指定名字的方法存在于对象上。 代码中与null比较越少，就越容易确定代码的目的，消除不必要的错误。 从代码中分离配置文件配置数据是一些硬代码(hardcoded)，看下面的栗子123456function validate(value)&#123; if(!value)&#123; alert('Invalid value'); location.href = '/errors/invalid.php'; &#125;&#125; 上面代码里有两个配置数据，一个是UI字符串(‘Invalid value’),另一个是一个Url(‘/error/invalid.php’)。如果你把他们写死在代码里，那么如果当你需要修改这些地方的时候，那么你必须一处一处的检查并修改，而且还可能会遗漏。 所以第一步是要区分，哪些代码应该写成配置文件的形式？ 显示在UI元素中的字符串 URL 一些重复的唯一值 一些设置变量 任何可能改变的值 一些例子1234var Config = &#123; "MSG_INVALID_VALUE":"Invalid value", "URL_INVALID":"/errors/invalid.php"&#125; 调试信息开关在开发过程中，可能随处留下几个console.log,或者alert语句，这些语句在开发过程中是很有价值的。但是项目一旦进入生产环境，过多的console.log可能影响到浏览器的运行效率，过多的alert会降低程序的用户体验。而我们最好不要在进入生产环境前，一处一处像扫雷一样删除或者注释掉这些调试语句。 最好的方式是设置一个开关。123456789101112131415161718192021//全局命令空间var App = &#123; debug:true, log:function(msg)&#123; if(debug)&#123; console.log(msg); &#125; &#125;, alert:function(msg)&#123; if(debug)&#123; alert(msg); &#125; &#125;&#125;;//使用App.log('获取用户信息成功');App.alert('密码不匹配');//关闭日志输出与alertApp.debug = false; 使用jQuery Promise没使用promise之前的回调函数写法1234567891011121314151617181920212223242526272829// bad：没使用promise之前的回调函数写法function sendRequest(req,successCallback,errorCallback)&#123; var inputData = req.data || &#123;&#125;; inputData = JSON.stringify(inputData); $.ajax(&#123; url:req.base+req.destination, type:req.type || "get", headers:&#123; sessionId:session.id &#125;, data:inputData, dataType:"json", contentType : 'application/json; charset=UTF-8', success:function(data)&#123; successCallback(data); &#125;, error:function(data)&#123; console.error(data); errorCallback(data); &#125; &#125;);&#125;//调用sendRequest(req,function(res)&#123; ...&#125;,function(res)&#123; ...&#125;); 使用promise之后12345678910111213141516171819202122232425262728293031323334function sendRequest(req)&#123; var dfd = $.Deferred(); var inputData = req.data || &#123;&#125;; inputData = JSON.stringify(inputData); $.ajax(&#123; url:req.base+req.destination, type:req.type || "get", headers:&#123; sessionId:session.id &#125;, data:inputData, dataType:"json", contentType : 'application/json; charset=UTF-8', success:function(data)&#123; dfd.resolve(data); &#125;, error:function(data)&#123; dfd.reject(data); &#125; &#125;); return dfd.promise();&#125;//调用sendRequest(req).done(function()&#123; //请求成功 ...&#125;).fail(function()&#123; //请求失败 ...&#125;); 显示错误提醒，不要给后端接口背锅假如前端要去接口获取用户信息并显示出来，如果你的请求格式是正确的，但是接口返回400以上的错误，你必须通过提醒来告知测试，这个错误是接口的返回错误，而不是前端的逻辑错误。 REST化接口请求 对资源的操作包括获取、创建、修改和删除资源，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。 对应方式 请求类型 接口前缀 GET .get, POST .create 或者 .get PUT .update DELETE .delete 说明 有些接口虽然是获取某一个资源，但是它使用的却是POST请求，所以建议使用.get比较好 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 与用户相关的接口App.api.user = &#123;&#125;;// 获取一个用户: 一般来说是一个指定的Id，例如userIdApp.api.user.getUser = function()&#123; ...&#125;;// 获取一组用户: 一般来说是一些条件，获取条件下的用户，筛选符合条件的用户App.api.user.getUsers = function()&#123; ...&#125;;// 创建一个用户App.api.user.createUser = function()&#123; &#125;;// 创建一组用户App.api.user.createUsers = function()&#123; &#125;;// 更新一个用户App.api.user.updateUser = function()&#123; &#125;;// 更新一组用户App.api.user.updateUsers = function()&#123; &#125;;// 更新一个用户App.api.user.updateUser = function()&#123; &#125;;// 更新一组用户App.api.user.updateUsers = function()&#123; &#125;;// 删除一个用户App.api.user.deleteUser = function()&#123; &#125;;// 删除一组用户App.api.user.deleteUsers = function()&#123; &#125;; 性能注意作用域 避免全局查找 避免with语句 选择正确的方法 优化循环 减值迭代：从最大值开始，在循环中不断减值的迭代器更加高效 简化终止条件：由于每次循环过程都会计算终止条件，所以必须保证它尽可能快。也就是避免其他属性查找 简化循环体：由于循环体是执行最多的，所以要确保其最大限度地优化。 展开循环 避免双重解释： 12345678// **Bad** 某些代码求值eval("alert('hello')");// **Bad** 创建新函数var sayHi = new Function("alert('hello')");// **Bad** 设置超时setTimeout("alert('hello')"); 性能的其他注意事项 原生方法较快 switch语句较快：可以适当的替换ifelse语句case 的分支不要超过128条 位运算符较快 最小化语句数多个变量声明(废弃)1234567891011// 方式1：Badvar count = 5;var name = 'wdd';var sex = 'male';var age = 10;// 方式2：Goodvar count = 5, name = 'wdd', sex = 'male', age = 10; 2017-03-07 理论上方式2可能要比方式1性能高一点。但是我在实际使用中，这个快一点几乎是没什么感受的。就像你无法感受到小草的生长一样。反而可读性更为重要。所以，每行最好只定义一个变量，并且每行都有一个var,并用分号结尾。 插入迭代值12// Goodvar name = values[i++]; 使用数组和对象字面量1234567// Goodvar values = ['a','b','c'];var person = &#123; name:'wdd', age:10&#125;; 只要有可能，尽量使用数组和对象字面量的表达式来消除不必要的语句 优化DOM交互 在JavaScript各个方面中，DOM无疑是最慢的一部分。DOM操作与交互要消耗大量的时间。因为他们往往需要重新渲染整个页面或者某一部分。进一步说，看似细微的操作也可能花很久来执行。因为DOM要处理非常多的信息。理解如何优化与DOM的交互可以极大的提高脚本完成的速度。 使用dom缓存技术 最小化现场更新 使用innerHTML插入大段html 使用事件代理 Dom缓存技术调用频率非常高的dom查找，可以将DOM缓存在于一个变量中1234567// 最简单的dom缓存var domCache = &#123;&#125;;function myGetElement(tag)&#123; return domCache[tag] = domCache[tag] || $(tag);&#125; 避免过长的属性查找，设置一个快捷方式12345678910// 先看下面的极端情况app.user.mother.parent.home.name = 'wdd'app.user.mother.parent.home.adderess = '上海'app.user.mother.parent.home.weather = '晴天'// 更优雅的方式var home = app.user.mother.parent.home;home.name = 'wdd';home.address = '上海',home.weather = '晴天' 注意使用上面的方式是有前提的，必须保证app.user.mather.parent.home是一个对象，因为对象是传递的引用。如果他的类型是一个基本类型，例如：number,string,boolean，那么复制操作仅仅是值传递，新定义的home的改变，并不会影响到app.user.mather.parent.home的改变。 快捷方式字符串转数字1+'4.1' === 4.1 数字转字符14.1+'' === '4.1' 字符串取整1'4.99' | 0 === 4 推荐深度阅读关于技术 《编写可读代码的艺术》 《编写可维护的JavaScript》 《JavaScript忍者秘籍》 《JavaScript: The Good Parts》 Writing Fast, Memory-Efficient JavaScript JavaScript 秘密花园 You-Dont-Know-JS 《HTTP权威指南》 Caching Tutorial for Web Authors and Webmasters 技术之外 《筑巢引凤-高黏度社会化网站设计秘诀》 《黑客与画家》 《大秦帝国》 参考文献 JavaScript高级程序设计(第3版) 【美】尼古拉斯·泽卡斯 Maintainable JavaScript (英文版) Nicholas C. Zakas(其实和上边那本书应该是同一个人) JavaScript忍者秘籍 John Resig / Bear Bibeault （John Resig 大名鼎鼎jQuery的创造者） 百度前端研发部 文档与源码编写风格]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>

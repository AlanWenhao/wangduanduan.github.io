<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebSocket断开原因分析]]></title>
    <url>%2Fwebsocket-close-reasons.html</url>
    <content type="text"><![CDATA[1. 把错误打印出来WebSocket断开的原因有很多，最好在WebSocket断开时，将错误打印出来。 在线demo地址：https://wdd.js.org/websocket-demos/ 1234ws.onerror = function (e) &#123; console.log('WebSocket发生错误: ' + e.code) console.log(e)&#125; 如果你想自己玩玩WebSocket, 但是你又不想自己部署一个WebSocket服务器，你可以使用ws = new WebSocket(&#39;wss://echo.websocket.org/&#39;), 你向echo.websocket.org发送消息，它会回复你同样的消息。 2. 重要信息错误状态码WebSocket断开时，会触发CloseEvent, CloseEvent会在连接关闭时发送给使用 WebSockets 的客户端. 它在 WebSocket 对象的 onclose 事件监听器中使用。CloseEvent的code字段表示了WebSocket断开的原因。可以从该字段中分析断开的原因。 3. 关闭状态码表一般来说1006的错误码出现的情况比较常见，该错误码一般出现在断网时。 状态码 名称 描述 0–999 保留段, 未使用. 1000 CLOSE_NORMAL 正常关闭; 无论为何目的而创建, 该链接都已成功完成任务. 1001 CLOSE_GOING_AWAY 终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开. 1002 CLOSE_PROTOCOL_ERROR 由于协议错误而中断连接. 1003 CLOSE_UNSUPPORTED 由于接收到不允许的数据类型而断开连接 (如仅接收文本数据的终端接收到了二进制数据). 1004 保留. 其意义可能会在未来定义. 1005 CLOSE_NO_STATUS 保留. 表示没有收到预期的状态码. 1006 CLOSE_ABNORMAL 保留. 用于期望收到状态码时连接非正常关闭 (也就是说, 没有发送关闭帧). 1007 Unsupported Data 由于收到了格式不符的数据而断开连接 (如文本消息中包含了非 UTF-8 数据). 1008 Policy Violation 由于收到不符合约定的数据而断开连接. 这是一个通用状态码, 用于不适合使用 1003 和 1009 状态码的场景. 1009 CLOSE_TOO_LARGE 由于收到过大的数据帧而断开连接. 1010 Missing Extension 客户端期望服务器商定一个或多个拓展, 但服务器没有处理, 因此客户端断开连接. 1011 Internal Error 客户端由于遇到没有预料的情况阻止其完成请求, 因此服务端断开连接. 1012 Service Restart 服务器由于重启而断开连接. 1013 Try Again Later 服务器由于临时原因断开连接, 如服务器过载因此断开一部分客户端连接. 1014 由 WebSocket 标准保留以便未来使用. 1015 TLS Handshake 保留. 表示连接由于无法完成 TLS 握手而关闭 (例如无法验证服务器证书). 1016–1999 由 WebSocket 标准保留以便未来使用. 2000–2999 由 WebSocket 拓展保留使用. 3000–3999 可以由库或框架使用.? 不应由应用使用. 可以在 IANA 注册, 先到先得. 4000–4999 可以由应用使用. 4. 参考 CloseEvent getting the reason why websockets closed with close code 1006 Defined Status Codes]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拜领域内最顶尖人物为师]]></title>
    <url>%2Flearn-from-the-top-master.html</url>
    <content type="text"><![CDATA[我很讨厌teacher, 我几乎所有做的噩梦都和上课，考试，老师有关。但是我渴望master, 特别是行业顶尖的master。我渴望从master哪里获取知识，但是master们往往都是很忙的，哪有时间教你。但是作为master, 几乎每个人都有基本领域公认的巨著。 例如学经济学，亚当斯密的国富论是必读的书；学心理学，弗洛伊德的《梦的解析》，古斯塔夫•勒庞的《乌合之众》也是必读的书。学前端，泽卡斯的《JavaScript高级程序设计》，弗兰纳根的《JavaScript权威指南》，这两本书如果你没读过，那么你几乎是一个不合格的前端。 但是，作为一个普通人，你无法接触到真的的大师，那么就把他们的巨著当做大师，从读书中汲取大师的知识，这未尝不是一件有意义的事情。 读书真的那么难吗？ 如何坚持下去？读哪些书？如何挑选挑书实际上是挑人，你 理论知识的重要性书评与积累只取一瓢不求甚解速读]]></content>
      <tags>
        <tag>读书</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的真值和假值]]></title>
    <url>%2Fjs-true-and-false-value.html</url>
    <content type="text"><![CDATA[无论什么语言，都需要逻辑，而逻辑中，能否判断出真假，是最基本也是最重要技能之一。 JS中的假值有6个 false ‘’ undefinded null 0, +0, -0 NaN 有点类似假值的真值有两个 {} [] 空对象和空数组，很多初学者都很用把这两个当做假值。但是实际上他们是真值，你只需要记住，除了null之外的所有对象类型的数据，都是真值。 1typeof null // 'object' 据说：typeof null返回对象这是一个js语言中的bug。实际上typeof null应该返回null才比较准确，但是这个bug已经存来好久了。几乎所有的代码里都这样去判断。如果把typeof null给改成返回null, 那么这必定会导致JS世界末日。 我们承认JS并不完美，她有很多小缺点，但是这并不妨碍她吸引万千开发者拜倒在她的石榴裙下。 就像一首歌唱的：有些人说不清哪里好 但就是谁都替代不了]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端之路 树根 树干 树叶]]></title>
    <url>%2Ffrontend-tree-root-trunk-leaf.html</url>
    <content type="text"><![CDATA[树根 向下扎实基本功树干 积累让身躯更坚实树叶 随风而去的好奇心]]></content>
  </entry>
  <entry>
    <title><![CDATA[一切皆有可能 IE5 支持WebSocket stompjs]]></title>
    <url>%2Feverything-is-possible-ie5-support-websocket.html</url>
    <content type="text"><![CDATA[web-socket-js让IE5支持WebSocketweb-socket-js基于flash技术, 让浏览器可以拥有类似原生的WebSocket的体验。只需要在服务端做少许的改动]]></content>
      <tags>
        <tag>未完成</tag>
        <tag>ie5</tag>
        <tag>websocket</tag>
        <tag>stompjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[需求文档写作规范]]></title>
    <url>%2Fdemand-docs-guideline-draft.html</url>
    <content type="text"><![CDATA[1. 项目创建一般情况，一个服务要有一个需求文档的git项目。即需要在gitlab docs 组织下建立与之对应的项目仓库 例如创建一个需求文档的项目。 文件结构2. 版本管理需求文档基于git分支进行版本管理。 默认情况下，创建一个git项目都会有一个master分支。我们并不在master分支上写任何需求。 我们根据项目的版本来创建分支。例如我们先创建一个v1.0.0的分支，我们在该分支上写需求文档。当v1.0.0版本发布后，我们基于v1.0.1分支。 而且我们能够自由的切换分支。 3. 需求状态需求有以下几种状态， 开始(draft), 草稿阶段 需求稳定(stable), 需求标记为stable, 开发才着手开始开发 需求修改(modified), 需求处于修改状态，则开发暂停 开发(dev), 开始开发 测试(test), 开始测试 发布(released), 测试通过，开始发布 4. 格式要求]]></content>
  </entry>
  <entry>
    <title><![CDATA[在实践中我遇到stompjs, websocket和nginx的问题与总结]]></title>
    <url>%2Fstomp-over-websocket.html</url>
    <content type="text"><![CDATA[1. AWS EC2 不支持WebSocket直达解决方案 英文版 简单说一下思路：WebSocket底层基于TCP协议的，如果你的服务器基于HTTP协议暴露80端口，那WebSocket肯定无法连接。你只要将HTTP协议修改成TCP协议就可以了。 然后是安全组的配置： 同样如果使用了NGINX作为反向代理，那么NGINX也需要做配置的。 123456789101112131415161718192021222324252627282930313233// https://gist.githubusercontent.com/unshift/324be6a8dc9e880d4d670de0dc97a8ce/raw/29507ed6b3c9394ecd7842f9d3228827cffd1c58/elasticbeanstalk_websocketsfiles: "/etc/nginx/conf.d/01_websockets.conf" : mode: "000644" owner: root group: root content : | upstream nodejs &#123; server 127.0.0.1:8081; keepalive 256; &#125; server &#123; listen 8080; location / &#123; proxy_pass http://nodejs; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125; "/opt/elasticbeanstalk/hooks/appdeploy/enact/41_remove_eb_nginx_confg.sh": mode: "000755" owner: root group: root content : | mv /etc/nginx/conf.d/00_elastic_beanstalk_proxy.conf /etc/nginx/conf.d/00_elastic_beanstalk_proxy.conf.old 2. NGINX做反向代理是需要注意的问题如果排除所有问题后，那剩下的问题可以考虑出在反向代理上，一下有几点是可以考虑的。 HTTP的版本问题: http有三个版本，http 1.0, 1.1, 2.0, 现在主流的浏览器都是使用http 1.1版本，为了保证更好的兼容性，最好转发时不要修改协议的版本号 NGINX具有路径重写功能，如果你使用了该功能，就要考虑问题可能出在这里，因为NGINX在路径重写时，需要对路径进行编解码，有可能在解码之后，没有编码就发送给后端的服务器，导致后端服务器无法对URL进行解码。 3. IE8 IE9 有没有简单方便支持WebSocket的方案目前测试下来，最简单方案是基于flash的。参考：https://github.com/gimite/web-socket-js, 注意该方案需要在WebSocket服务上的843端口, 提供socket_policy_files, 也可以参考：A PolyFill for WebSockets 网上也有教程是使用socket.io基于ajax长轮训的方案，如果服务端已经确定的情况下，一般是不会轻易改动服务端代码的。而且ajax长轮训也是有延迟，和disconnect时，无法回调的问题。 4. stompjs connected后，没有调用connect_callBack该问题主要是使用web-socket-js，在ie8,ie9上出现的 该问题还没有分析出原因，但是看了stompjs的源码不是太多，明天用源码调试看看原因。 问题已经找到，请参考：https://github.com/wangduanduan/stomp-websocket#about-ie8-ie9-use-websocket 5. 参考文献 STOMP Over WebSocket STOMP Protocol Specification, Version 1.1 Stomp Over Websocket文档,]]></content>
      <tags>
        <tag>websocket</tag>
        <tag>stompjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记 编写可读性代码的艺术]]></title>
    <url>%2Fart-of-readable-code.html</url>
    <content type="text"><![CDATA[1. 代码应当易于理解 唯一标准：让别人理解的时间最小 2. 把信息装到名字里 选择专业的词 避免泛泛的名字 使用具体的名字代替抽象的名字 为名字携带更多的信息 名字的作用域越大，最好名字越长 丢掉没用的词 单词 更多选择 send deliver, dispatch, announce, distribute,route find search, extract, locate, recover start launch, create, begin, open make create, set up, build, generate, compose, add ,new 3. 审美我之前学设计的时候看过一本书，写给大家看的设计书（第3版）将这本书中的设计审美原理应用到写代码上，真实十分贴切，如果你读过此书，你的审美能力会大幅提高。 对齐 重复 对比 亲密性 按照亲密关系分段 顺序 4. 写什么样的注释 不要写一眼就能看懂的注释，类似于此地无银三百两 与其写注释，不如把变量名函数名写好，可以从名字中理解 记录你的思想 加入评论 指出哪里有陷阱，需要注意 言简意赅，不要啰嗦 不要使用不明确的代词，不要像像算命先生，如何解释都对 5. 可读性控制流 追求最小理解时间，而不是最少代码行 尽可能提前return结果 少点嵌套，要尽可能扁平化 理解执行流程。有些是连续执行。有些是随时都可能执行，像事件回调 避免使用while, 一般我们循环都是为了遍历数组，为什么不用forEach呢？ 6. 拆分超长表达式 拆分超长的表达式 拆分巨大的语句 尽量把逻辑包裹在函数中，不要重复你自己 DRY 7. 变量与可读性 减少变量，变量越少越好 减少中间结果，垂直消费 减少用于控制流的变量 缩小变量的作用域 用到变量再定义，不要提前定义，不然还要随时想着，之前定义的变量是用干嘛的呢？ 8. 重构 抽取不相关的自子问题 抽取各种配置性的变量在一起，他们都是配置 尽量写纯函数 创建大量通用代码 打造自己的武器装备库 简化接口传参 过犹不及，不要太苛刻 9. 一次只做一件事10. 少写代码 最好的代码就是没有代码 别费神实现那个功能，你不会需要的 质疑和拆分的需求 保持小代码库 删除没用的代码 删除没有的注释 11. 调试 尽可能将错误打印出来，不要隐藏]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何高效地报告 Bug]]></title>
    <url>%2Fhow-to-report-bug-effective.html</url>
    <content type="text"><![CDATA[1. 自问自答 该问题是否是必现的？ 该问题出现多久了？ 问题出现前后有没有什么异常？ 例如几分钟之前启动了其他的服务，有其他服务在更新 2. 要事实，不要推测在bug报告里，要设法搞清什么是事实（例如：压测环境座席监控没有数据）。什么是推测（例如：我想问题可能出在XXX）。如果愿意的话，您可以省去推测，但是千万别省略事实。 3. 要精确，不要模糊3.1. 不要使用代词3.2. 不要使用”没有”4. 要详细，不要粗略5. 建议要提供的数据 建议 错误日志, 程序员最喜欢bug里的错误日志，错误日志能说明一切，非常建议你能提供错误日志 必须 操作步骤, 有利于程序员去重现bug 可选 错误截图, 在描述不清楚的时候，错误截图时更好的方法 6. 参考 如何有效地报告 Bug]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态码为200时 jQuery ajax报错]]></title>
    <url>%2Fstatus-code-200-jquery-ajax-failed.html</url>
    <content type="text"><![CDATA[1. 问题现象HTTP 状态码为 200 OK 时， jquery ajax报错 2. 问题原因jquery ajax的dataType字段包含：json, 但是服务端返回的数据不是规范的json格式，导致jquery解析json字符串报错，最终导致ajax报错。 jQuery ajax 官方文档上说明： “json”: Evaluates the response as JSON and returns a JavaScript object. Cross-domain “json” requests are converted to “jsonp” unless the request includes jsonp: false in its request options. The JSON data is parsed in a strict manner; any malformed JSON is rejected and a parse error is thrown. As of jQuery 1.9, an empty response is also rejected; the server should return a response of null or {} instead. (See json.org for more information on proper JSON formatting.) 设置dataType为json时，jquery就会去解析响应体为JavaScript对象。跨域的json请求会被转化成jsonp, 除非设置了jsonp: false。JSON数据会以严格模式去解析，任何不规范的JSON字符串都会解析异常并抛出错误。从jQuery 1.9起，一个空的响应也会被抛出异常。服务端应该返回一个null或者{}去代替空响应。参考json.org, 查看更多内容 3. 解决方案这个问题的原因是后端返回的数据格式不规范，所以后端在返回结果是，不要使用空的响应，也不应该去手动拼接JSON字符串，而应该交给响应的库来实现JSON序列化字符串工作。 4. 参考 Ajax request returns 200 OK, but an error event is fired instead of success jQuery.ajax]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端剪贴板复制功能实现原理]]></title>
    <url>%2Fclipboard-copy-tutorial.html</url>
    <content type="text"><![CDATA[1. 兼容情况如果想浏览器支持粘贴功能，那么浏览器必须支持，document.execCommand(‘copy’)方法，也可以根据document.queryCommandEnabled(‘copy’)，返回的true或者false判断浏览器是否支持copy命令。 从下表可以看出，主流的浏览器都支持execCommand命令 2. 复制的原理 查询元素 选中元素 执行复制命令 3. 代码展示1234567891011// html&lt;input id="username" value="123456"&gt;// 查询元素var username = document.getElementById(‘username’)// 选中元素username.select()// 执行复制document.execCommand('copy') 注意: 以上代码只是简单示意，在实践过程中还有几个要判断的情况 首要要去检测浏览器execCommand能力检测 选取元素时，有可能选取元素为空，要考虑这种情况的处理 4. 第三方方案clipboard.js是一个比较方便的剪贴板库，功能蛮多的。 1234567&lt;!-- Target --&gt;&lt;textarea id="bar"&gt;Mussum ipsum cacilds...&lt;/textarea&gt;&lt;!-- Trigger --&gt;&lt;button class="btn" data-clipboard-action="cut" data-clipboard-target="#bar"&gt; Cut to clipboard&lt;/button&gt; 官方给的代码里有上面的一个示例，如果你用了这个示例，但是不起作用，那你估计是没有初始化ClipboardJS示例的。 注意：下面的函数必须要主动调用，这样才能给响应的DOM元素注册事件。 ClipboardJS源代码压缩后大约有3kb，虽然很小了，但是如果你不需要它的这么多功能的话，其实你自己写几行代码就可以搞定复制功能。 1new ClipboardJS('.btn');]]></content>
      <tags>
        <tag>copy</tag>
        <tag>clipboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何成为从培训班里出来的牛人？]]></title>
    <url>%2Fhow-to-learn-form-trianing-class.html</url>
    <content type="text"><![CDATA[1. 培训行业的现状和问题 进入培训班学习可能有一下两个原因： 想转行 学校里学的东西太过时了，需要深入学习本行业的知识 培训的行业的核心思想都是：如何快速的让你能够面试通过 老师教的东西大多是一些面试必须要问的一些知识，做的项目也应该都是市面上比较火的项目。这么做的不利之处有以下几点： 局限性：知识局限于教师的授课范围，知识面窄 扩展性：快餐式学习管饱不管消化，很多知识吸收不高，无法举一反三 系统性：没有系统的整体知识体系 所以这些因素可能会让用人不太喜欢培训出来的应聘者，而往往希望刚毕业的应届生。但是，培训行业出来的应聘者，也不乏国士无双的牛逼人物。 2. 如何成为培训出来的牛人？ 无论在哪个行业，自学都是必不可少的事情。毕业不是学习的终点，而应该是起点。你和技术牛人之间的距离或许并不遥远，可能只是一个芭蕉扇的距离。 2.1. 读权威书籍，扎实理论基础 每个行业都有一些经历时间考验而熠熠生辉的经典数据，例如在前端行业。我认为下面两本书是必须要读完一本的。 基础 JavaScript高级程序设计 JavaScript权威指南 进阶 JavaScript语言精粹 JavaScript忍者秘籍 You Don’t Know JS JS函数式编程指南 2.2. 动手能力，闲话少说，放码过来 各种demo啊，效果啊，有时间自己都可以撸一遍，放在github上，又不收钱，还能提高动手能力。 2.3. 数据结构 差劲的程序员操心代码，牛逼的程序员操心数据结构和它们之间的关系。 一一Linus Torvalds, Linux 创始人 优秀的数据结构，可以节省你80%的编码时间。差劲的数据结构，你需要花大量的时间去做各种高难度动作的转换，一不小心，数据库就要累的气喘如牛，停机罢工。 2.4. 知识积累，从博客开始 如果你已经在某个行业工作个两三年，一篇像样的博客都没有。 那我觉得你可能是个懒人。因为几乎很少写东西。 我觉得你可以是个自私的人。因为做计算机行业的，谁没有用过别人造的轮子。即使你没有造轮子的能力，即使你给出一个问题应该如何解决的，至少你对计算机行业也作出了你的贡献。 2.5. 互联网的基石 TCP IP 计算机行业是分层的，就像大海一样，海面上的往往都是惊涛骇浪，暴风骤雨，各种框架层出不穷，争奇斗艳。当你深入海底，你会发现，那里是最平静的地方。而TCP IP等协议知识，就是整个互联网大航海时代的海底。互联网行业如此多娇，引无数框架竞折腰。浪潮之巅者成为行业热点，所有资源会喷薄涌入，失去优势被替代者，往往折戟沉沙铁未销。总之，越是上层，竞争越激烈，换代越快。 但是底层的TCP/IP之类的知识，往往几十年都不会有多大的改变。而且无论你从事什么语言开发，只要你涉及到通信了，你就需要TCP/IP的知识点，不过你不清楚这些知识点，你可以随时给自己埋下定时炸弹。 这个错误我也犯过，你可以看我的犯错记录：哑代理 - TCP链接高Recv-Q，内存泄露的罪魁祸首。 关于TCP/IP, 推荐一下书籍 基础 图解TCP/IP : 第5版 图解HTTP 进阶 HTTP权威指南 2.6. 工具的威力 你用刀，我用枪，谁说谁能打过谁。原始社会两个野蛮人相遇，块头大的，食物多，可以拥有更多的繁衍后代的权利。但是当一个野蛮人知道用刀的威力时，他就不会害怕胳膊比较粗的对手了。 举例来说，前端开发免不了有时需要一个静态文件服务器，如果你只知道阿帕奇，那你的工具也太落后了。你可以看看这篇文章：一行命令搭建简易静态文件http服务器 当你想要更偷懒，想要不安于现状时，你会找到更多的厉害的工具。 2.7. 英语阅读能力 IT行业还有一个现象，就是看英文文档如喝中药一般，总是捏着鼻子也看不下去。看中文文档放佛如喝王老吉，消火又滋润。 IT行业至今来说，放佛还是个舶来品。所有的最新的文档都是英文的。但是也不乏有好的中文翻译文档，但是都是需要花时间去等待。而且英文文档也随着翻译者的水平而参差不齐。 其实我们完全没必要去害怕英文文档，其实英文文档里最常用的单词往往是很固定的。又不是什么言情小说，总是让你摸不着头脑。 你不想看英文文档，从本质上说，还是因为你懒。 2.8. 文档能力 大多说程序的文档都是写给自己看的，或者说大多说的程序员的语文都是数学老师教的。这个其实很让看文档的人苦恼的。一个优秀的程序和框架，无一不是文档非常完善。因为文档的完善才能有利于文档的传播，才有利于解决问题。你的框架再牛逼，效率再如何高，没有人能看的懂，那是没用了。闭门造车永远也搞不出好东西。 关于如何写作文档，可以参考：如何写好技术文档? 3. 总结 开放的思维，敢于接纳一些新事物 不断学习，不舍昼夜 记笔记，写博客，要给所有的努力留下记录]]></content>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的专业化道路]]></title>
    <url>%2Ffeature-of-dangerous-professional-skill.html</url>
    <content type="text"><![CDATA[从分工到专业化分工提高生产效率，专业化提高个人价值。很多人都认为，一旦我们进入了某一行，我们就应该在这个行业深挖到底。例如我是做前端的，我就会去学习各种前端的知识点，各种层出不穷的框架。我总是在如饥似渴的希望自己能够保持在深入学习的状态，我不想哪一天自己突然out了。 专业化的危机在哪？以前我在上初中的时候，就稍稍的学习了一点点ActionScript的知识。可能有些人不知道ActionScript是干嘛的，它是在flash的环境中工作的，可以在flash里做一些动画和特效之类的。那时候flash是很火的技术，几乎所有的网站都是有flash的，所以会ActionScript语言的程序员，工资都不低。 但是，你现在还听过什么ActionScript吗？ 它的宿主环境flash都已经被淘汰了，皮之不存毛将焉附。可想而知，flash的淘汰，同时也让时长淘汰了一批在ActionScript的专家。 所以，专业化并不是一个安全的道路。准确来说，世界上本来就没有安全的路。大多说认为这条路安全，是因为他们总是以静态的眼光看这条路。说点题外话，如果你书读多了，你会发现，其实一直在你思想里的那些观念，那些故事，往往都是忽悠人的。你可以看看我的一个书单：2018年我的阅读计划。 从企业的角度考虑，每个老板都想招在某一方面专家。但是从个人的角度考虑，如果你在专业化的道路钻研的非常深，或许有时候你应该放慢脚步，找个长椅，坐着想一想，如果你前面马上就是死路了，你应该怎么办？ 我们应该怎么办？世界上没有安全的路，世界上也没有一直安全的职业。一个职业的火爆，往往因为这个行业的火爆。而永远也没有永远火爆的行业，当退潮时，将会有大批的弄潮儿会搁浅，干死，窒息…… 除去环境造成的扰动，人的身体也会随着年龄会慢慢老化。 你可以想象一下，当你四十多岁时。那些新来的实习生，比你要的工资低，比你更容易接受这个行业的前沿知识，比你更加能加班，比你能力更强时，比你更听话时。你的优势在哪里？我相信到那时候，你的领导会毫不犹豫开了你。 在此，你要改变。我给出以下几个角度，你可以自行延伸。 开始锻炼身体 这是一切的基石 搞一搞副业，学习一下你喜欢的东西，你可以去深入学学如何做菜，如何摄影等等 学习理财知识，这是学校从没教你的，但是却是非常重要的东西 读书，越多越好 参考文献 专业主义 日 大前研一 富爸爸穷爸爸 罗伯特·清崎 / 莎伦·莱希特 国富论 英 亚当·斯密 失控 乌合之众 法 古斯塔夫·勒庞 未来世界的幸存者 阮一峰 新生 七年就是一辈子 李笑来]]></content>
      <tags>
        <tag>职业规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome本地跨域origin-null-is-not-allowed问题分析与解决方案]]></title>
    <url>%2Forigin-null-is-not-allowed.html</url>
    <content type="text"><![CDATA[1. 问题表现以file:///xxx.html打开某个html文件，发送ajax请求时报错： 1Response to preflight request doesn't pass access control check: The 'Access-Control-Allow-Origin' header has a value 'null' that is not equal to the supplied origin. Origin 'null' is therefore not allowed access. 2. 问题原因Origin null是本地文件系统，因此这表明您正在加载通过file：// URL进行加载调用的HTML页面（例如，只需在本地文件浏览器或类似文件中双击它）。不同的浏览器采用不同的方法将相同来源策略应用到本地文件。Chrome要求比较严格，不允许这种形势的跨域请求。而最好使用http:// 访问html. 3. 解决方案以下给出三个解决方案，第一个最快，第三个作为彻底。 3.1. 方案1 给Chrome快捷方式中增加 –allow-file-access-from-files打开Chrome快捷方式的属性中设置：右击Chrome浏览器快捷方式，选择“属性”，在“目标”中加”–allow-file-access-from-files”，注意前面有个空格，重启Chrome浏览器便可。 3.2. 方案2 启动一个简单的静态文件服务器, 以http协议访问html参见我的这篇文章: 一行命令搭建简易静态文件http服务器 3.3. 方案3 服务端响应修改Access-Control-Allow-Origin : *1response.addHeader("Access-Control-Allow-Origin","*") 4. 参考文章 如何解决XMLHttpRequest cannot load file~~~Origin ‘null’ is therefore not allowed access 让chrome支持本地Ajax请求,Ajax请求status cancel Origin null is not allowed by Access-Control-Allow-Origin Origin null is not allowed by Access-Control-Allow-Origin]]></content>
      <tags>
        <tag>chrome</tag>
        <tag>跨域</tag>
        <tag>origin-null-is-not-allowed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曲线救国 使用googler命令行搜索]]></title>
    <url>%2Fuse-googler-for-serarch.html</url>
    <content type="text"><![CDATA[之前因为有优惠政策，于是我在xx云上买了一台位于香港的最低配置的服务器，期限三年，主要用来搭建ss, 用来跨栏。 用了一段时间，感觉挺稳定的。后来一纸通知，收到了整改信息。于是我就把ss服务停了。 三年的主机不能浪费，于是我就思考一下曲线救国的思路。 即使用ssh链接上远程服务器后，使用googler命令进行搜索，然后点击链接，使用本地浏览器打开搜索结果 关于googler可以查看，https://github.com/jarun/googler#installation]]></content>
      <tags>
        <tag>谷歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端团队合作规范]]></title>
    <url>%2Ffront-end-team-work-blog.html</url>
    <content type="text"><![CDATA[1. 编程风格 代码风格 JavaScript Standard Style js最佳实践 JavaScript Standard Style 细则建议看看 2. 编辑器 vscode 3. git版本控制 分支管理 开发分支: master, 开发分支，用于拉取开发分支，尽量不要在此分支上写代码 生产分支: production, 和生产环境同步 特性分支：feature, 所有特性分支均已 f-开头， 如f-ocm-config, 特性分支用于开发，是暂时性分支，分支开发完毕后，可以合并到master分支。 4. 工程化与模块化 构件工具必须要有 模块化 5. 代码整洁 阅读代码整洁之道 参考笔记 编写可读性代码的艺术 单个文件代码行越少越好，尽量按模块分散 函数体代码行越少越好，职责单一 6. tcp ip 阅读http权威指南 图解tcp ip 7. es6 阮一峰 es6教程 8. 函数式编程 推荐阅读 mostly-adequate-guide-chinese中文版 9. vue编程风格 vue官方推荐风格 10. 硬性要求 2018年后的，单个文件代码行绝对不要超过500行，可以分割文件，可以使用构建工具 每个js文件在顶部务必写一些说明性的文字，描述该文件的功能 比较容易歧义，或者关键点，需要写注释给与说明 积累与深入学习 积累: 工作中会遇到许多问题，建议你可以写在博客里。对自己来说是一种知识沉淀，对整个行业来说，你也贡献了你的力量。如果别人也遇到和你相同的问题，对别人来说也是帮助。 深入: 不断学习，不断深入，扩展自己的阅历，包括专业方面的，健康方面，财富方面等等]]></content>
      <tags>
        <tag>规范</tag>
        <tag>前端团队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3入门书籍与在线资料]]></title>
    <url>%2Fpython-books-comments.html</url>
    <content type="text"><![CDATA[1. 书籍类1.1. 老太婆一样的罗里吧嗦： Python学习手册（第4版）这本书相当的啰嗦，讲的内容空洞乏力，一些概念蜻蜓点水，买了必定会后悔。 1.2. 很有意思：Python编程：从入门到实践这本书讲的知识点虽然不是很全面，但是要点都讲的很清晰，行文也很有意思，最后一些实践项目也很有趣。 1.3. 干货满满：Python语言及其应用这本书虽然不是非常有趣，但是都是干货满满，知识点讲解也是很到位，非常推荐初学者看看。 2. 免费在线资料2.1. 廖雪峰pthon3教程：中文，免费，零起点，完整示例，基于最新的Python 3版本 2.2. 菜鸟教程 python3 非常适合作为一个快速查找的手册 2.3. 进阶 Python Cookbook 3适合有一定python基础的同学看 2.4. 把这个放在枕头下面 The Python Standard LibraryPython官方标准库参考手册，有什么需要刨根问底的问题需要查的时候，此处务必需要查阅一下。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式在线工具集合]]></title>
    <url>%2Fregex-online-tools.html</url>
    <content type="text"><![CDATA[1. 功能最强：regex101优点： 支持多种语言, prec,php,javascript,python,golang 界面美观大方 支持错误提示，实时匹配 缺点： 有时候加载速度太慢 2. 可视化正则绘图: Regulex优点： 实时根据正则表达式绘图 页面加载速度快 3. 可视化正则绘图：regexper优点： 根据正则表达式绘图 页面加载速度快 缺点： 无法实时绘图，需要点击才可以 4. 专注于python正则：pyregex 专注python 页面加载速度快]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode Formatter yapf is not installed解决方法]]></title>
    <url>%2Fformatter-yapf-is-not-installed.html</url>
    <content type="text"><![CDATA[1. 判断你是否安装了yapf1yapf -v 如果你没有安装过，那么必须要安装。 2. 指定pathon路径有些系统，像macOS，自带python2, 如果你又安装了python3, 并且你使用pip3来安装的yapf， 那么你就需要指定pythonPath 12// user settings"python.pythonPath": "python3",]]></content>
      <tags>
        <tag>python</tag>
        <tag>yapf</tag>
        <tag>vscode</tag>
        <tag>Formatter yapf is not installed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试和笔试题目]]></title>
    <url>%2Ffront-end-interview-handbook.html</url>
    <content type="text"><![CDATA[1. 问答题1.1. HTML相关1.1.1. &lt;!DOCTYPE html&gt;的作用是什么？1.1.2. script, script async和script defer之间有什么区别？1.1.3. cookie, sessionStorage 和 localStorage之间有什么区别？1.1.4. 用过哪些html模板渲染工具？1.2. CSS相关1.2.1. 简述CSS盒子模型1.2.2. CSS有哪些选择器？1.2.3. CSS sprite是什么？1.2.4. 写一下你知道的前端UI框架？1.3. JS相关1.3.1. js有哪些数据类型？1.3.2. js有哪些假值？1.3.3. js数字和字符串之间有什么快速转换的写法？1.3.4. 经常使用哪些ES6的语法？1.3.5. 什么是同源策略？1.3.6. 跨域有哪些解决方法？1.3.7. 网页进度条实现的原理1.3.8. 请问console.log是同步的，还是异步的？1.3.9. 下面console输出的值是什么？123456789var scores = [10,11,12];var total = 0;for(var score in scores)&#123; total += score;&#125;var average = total/scores.length;console.log(average); 1.3.10. 请问下面的写法问题在哪？12345console.log(1)(function()&#123; console.log(1)&#125;)() 1.3.11. 请问s.length是多少，s[2]是多少12345var s = []s[3] = 4s.length ?s[2] ? 1.3.12. 说说你对setTimeout的深入理解？123setTimeout(function()&#123; console.log('hi')&#125;, 1000) 1.3.13. 解释闭包概念及其作用1.3.14. 如何理解js 函数first class的概念？1.3.15. 函数有哪些调用方式？不同this的会指向哪里？1.3.16. applly和call有什么区别？1.3.17. 函数的length属性的代表什么？1.3.18. 有用过哪些js编程风格1.3.19. 如何理解EventLoop?1.3.20. 使用过哪些构建工具？各有什么优缺点？1.4. 其它1.4.1. 平时使用什么搜索引擎查资料？1.4.2. 对翻墙有什么看法？如何翻墙？1.4.3. 个人有没有技术博客，地址是什么？1.4.4. github上有没有项目？1.5. 网络相关1.5.1. 请求状态码 1xx,2xx,3xx,4xx,5xx分别有什么含义？1.5.2. 发送某些post请求时，有时会多一些options请求，请问这是为什么？1.5.3. http报文有哪些组成部分？1.5.4. http端到端首部和逐跳首部有什么区别？1.5.5. http与https在同时使用时，有什么注意点？1.5.6. http, tcp, udp, websocket，分别位于7层网络的那一层？tcp和udp有什么不同？2. 编码题2.1. 写一个函数，返回一个数组中所有元素被第一个元素除后的结果2.2. 写一个函数，来判断变量是否是数组，至少使用两种写法2.3. 写一个函数，将秒转化成时分秒格式，如80转化成：00:01:203. 翻译题 Aggregation operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result. MongoDB provides three ways to perform aggregation: the aggregation pipeline, the map-reduce function, and single purpose aggregation methods.]]></content>
      <tags>
        <tag>面试</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyMongo学习笔记]]></title>
    <url>%2Fpymongo-tutorial-and-example.html</url>
    <content type="text"><![CDATA[1. 环境 mongodb 3.4 pymongo 3.6.0 macOS 2. 安装pymongo1pip3 install pymongo 3. 建立数据库链接12345from pymongo import MongoClientconn = MongoClient('localhost', 27017)// 或者 conn = MongoClient('mongodb://localhost:27017/') 4. 获取数据库123db = conn.db_name // 如果数据库不存在，则自动创建db = conn['db-name'] // 如果数据库名中有中划线，则需要使用中括号的形式 5. 获取集合123collection = db.test_users // 如果集合不存在，则自动创建// 或者 collection = db['test-users'] 注意：只有当数据库或者集合中有数据被插入时，集合才真正被创建。 An important note about collections (and databases) in MongoDB is that they are created lazily - none of the above commands have actually performed any operations on the MongoDB server. Collections and databases are created when the first document is inserted into them. 6. 插入单个文档 insert_one1234post = &#123;"name":"wangduanduan", "province":"shanghai", "age": 12&#125;db.collection.inser_one(post)5a8e90b83617b1a34a06d890 // 插入成功后会返回ObjectId 7. 查询一个文档 find_one如果你确定你的查询结果里只有一个，那么最好使用find_one来做查询 1db.find_one(&#123;"name":"wangduanduan"&#125;) 8. 按照ObjectId查询 ObjectId()ObjectId不是字符串，你绝对不能把它当做字符串来做查询，虽然它看起来像字符串。 12345// good db.find_one('_id': ObjectId("5a8e82af3617b1a035d10264"))// bad 这是查不到结果的db.find_one('_id': "5a8e82af3617b1a035d10264") 9. 关于Unicode字符串的注意事项MongoDB使用BSON格式来存储数据，而BSON是utf-8编码的，所以pymongo必须要确保字符串是utf-8格式的。 python3 unicode字符串深入阅读 10. 批量插入 insert_many()123db.test_users.insert_many([user1, user2])[ObjectId1, ObjectId] // 插入成功后会以数组形式返回ObjectId 11. 条件查询 find()12db.test_users.find()// 返回符合条件的集合 12. 统计文档数量 count()12db.test_users.find().count()1 // 返回文档的数量 13. 范围查询返回查询如大于小于不能与之类的，MongoDB都是支持的，详情参见 例如：查询日期小于2009年11月12号12点的文章，并按照作者排序12d = datetime.datetime(2009, 11, 12, 12) // posts.find(&#123;"date": &#123;"$lt": d&#125;&#125;).sort("author") 更多类似与$lt之类的用法，可以参考Query and Projection Operators 14. 索引以user_id建立索引后，profiles集合就有两个索引了，因为MongoDB自带_id索引。 下面设置的user_id索引，并将其设置成唯一值。123result = db.profiles.create_index([('user_id', pymongo.ASCENDING)], unique=True)sorted(list(db.profiles.index_information()))[u'_id_', u'user_id_1'] 如果插入重复的user_id，那么会插入不成功，这个功能可以避免数据重复。 123456&gt;&gt;&gt; new_profile = &#123;'user_id': 213, 'name': 'Drew'&#125;&gt;&gt;&gt; duplicate_profile = &#123;'user_id': 212, 'name': 'Tommy'&#125;&gt;&gt;&gt; result = db.profiles.insert_one(new_profile) # This is fine.&gt;&gt;&gt; result = db.profiles.insert_one(duplicate_profile)Traceback (most recent call last):DuplicateKeyError: E11000 duplicate key error index: test_database.profiles.$user_id_1 dup key: &#123; : 212 &#125; 关于索引，可以参考Indexes 15. 参考 PyMongo 3.6.0 Documentation ObjectId collection – Collection level operations]]></content>
      <tags>
        <tag>python</tag>
        <tag>mongodb</tag>
        <tag>pymongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express 代理中间件的写法]]></title>
    <url>%2Fexpress-proxy-middleware-demo.html</url>
    <content type="text"><![CDATA[1. 配置文件写法123456789101112131415161718192021222324252627282930313233343536373839404142// filename: config/default.js// 开发环境配置文件module.exports = &#123; 'ENV': 'dev', 'PORT': '8088', 'maxAge': 10, proxyTable: &#123; // 这里是http代理 // 含有路径重写功能 '/p/olap': &#123; target: 'http://192.168.40.231:30092', pathRewrite: &#123; '^/p/olap': '/olap' &#125; &#125;, // 这里是http代理 // 含有路径重写功能 '/p/qc': &#123; target: 'http://192.168.40.231:30088', pathRewrite: &#123; '^/p/qc': '/qc' &#125; &#125;, // 这是WebSocket代理 '/mvc/stomp': &#123; target: 'http://192.168.40.231:30412', changeOrigin: true, ws: true, logLevel: 'debug', onError: function (err, req, res) &#123; console.log('Something went wrong. And we are reporting a custom error message.') console.log(err) res.writeHead(500, &#123; 'Content-Type': 'text/plain' &#125;) res.end('Something went wrong. And we are reporting a custom error message.') &#125; &#125; &#125;&#125; 2. app.js写法1234567891011121314151617181920212223242526var express = require('express')var compression = require('compression')var path = require('path')// config会根据NODE_ENV环境变量自动去读取config目录下的文件，默认读取的default.js文件// 你可以在config目录下设置production.js, test.js等配置文件var config = require('config')var proxyMiddleware = require('http-proxy-middleware')// 这里可以获取到配置文件的proxyTablevar proxyTable = config.get('proxyTable')...var app = express()...// 这里是要点// 遍历proxyTable，将配置文件中的路径挂载到app上Object.keys(proxyTable).forEach(function (context) &#123; app.use(proxyMiddleware(context, proxyTable[context]))&#125;)...module.exports = app]]></content>
      <tags>
        <tag>proxy</tag>
        <tag>http</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[small is better than big 我的读书方法论]]></title>
    <url>%2Fsmall-is-better-than-big.html</url>
    <content type="text"><![CDATA[床底下秘密我是一个毅力不是很够的人。我曾经下定决心要锻炼身体，买了一些健身器材，例如瑜伽垫，仰卧起坐的器材，俯卧撑的器材。然而三分钟的热度过后，我把瑜伽垫卷了起来，塞到床底下。把仰卧起坐的器材拆开，也塞到了床底下。 所以每次我都不敢看床底下，那里塞满了我的羞愧。我常常想，我这不就是永远睡在羞愧之上吗？ 那么，是什么让我放弃了自己的目标，慢慢活成了自己讨厌的样子呢？ 之前和朋友聊天，我们有一段时间没见了。我突然觉得他也太能聊了，说了很多我不知道的新鲜事，还有一些可以让人茅塞顿开的想法。完了之后，他劝我让我多读书。我觉得这个想法很多。我是确实需要读书了。毕竟我的床底下已经没有空间再塞其他的东西了。 于是我在多看阅读上买了一下电子书，在京东上买了一些实体书，然后又买了一个kindle。在读书的过程中，有时候作者也会推荐你看一些其他的书。我给自己定了2018年我的阅读计划，给自己定下要看哪些书。 看书的方法当我决定要看书，并且为此付出了不少的金钱的情况下。我是非常不愿因让我的金钱的付出白白打水漂的，毕竟买书以及买设备，这不是免费的服务。于是我给自己指定了一个非常完善的定量阅读标准 读书方法v1.0.0 版 如下 每天至少看三本书 每本书看50页 人要有标准才能判断是否达标，没有标准，没有数字化的支撑，那是很难以持续的。比如说中国的菜谱，做某道菜中写了一句：加入少许盐。中国人看了会想，那我就按照口味随便加点盐吧。外国人就会被搞得非常迷糊，少许是多少克盐？ 20g, 30g? 完全没有标准嘛。 按照读书方法 v1.0.0版，我看了几天，这个效果是很好的。但是我很累，电子书50页可不是个小数目。有时候很难完成的。于是我必须要升级我的读书方法。 读书方法v1.0.1 版 如下 每天至少看三本书 每本书看10页 按照读书方法v1.0.1 版，我看了几天，虽然读书的进度很慢，但是我很容易有满足感，因为这个目标是很容易就达成的。因为你随便去上个厕所，看个10页电子书也是绰绰有余的。但是这个版本也有个问题。 如果我今天看的这本书看的流连忘返，一不小心忘记看页码了，居然不知不觉读了38页，那么是不是已经消耗了未来几天的阅读量呢，明天这本书要不要度呢？ 所以，我要升级我的读书方法。 读书方法v1.0.2版： 每天至少读三本书 每本书至少读10页 我按照这个方法，感觉做的不错。每天都有一定的阅读量要看，而且阅读量不是很大，不会让我觉得很累。而且当我完成了这个目标，我是会获得不小的满足感。 大目标分解成小目标去逐个击破，这是我这篇文章的核心观点。 冲量公式 I = F x T 冲量是力的时间累积效应的量度，是矢量。如果物体所受的力是大小和方向都不变的恒力F，冲量I就是F和作用时间t的乘积。冲量是描述力对物体作用的时间累积效应的物理量。力的冲量是一个过程量。在谈及冲量时，必须明确是哪个力在哪段时间上的冲量。 个人好习惯的养成，不是一蹴而就的，而是类似于物理学冲量的概念：力在一段时间内的累积，是过程量 三分钟的热度对应的冲量：I = F_max x T_min。使用很大的力，作用时间超短，基本上没啥效果，冲量趋近于零。 微习惯对应的冲量：I = F_min x T_max。使用很小的力，做长时间的积累。冲量不会趋近于零，而是会慢慢增长，然后趋近于一个稳定水平。比如你给自己规定每天看1页书，但是大多数情况下，如果你做了看书的动作，基本上你看书的页数一定会大于1页。 看什么样的书我自己喜欢看计算机，心理学，历史人文方面的出版书籍。而我的选择标准有两个，符合任一一个，我都会去看。 要有用。无论是对我的专业知识，还是对人际交往，金融理财等方面要用有益之处 要有趣。没趣的书我是断然不会去看的。 读书实际上是读人，一流作家写的一流的书，三流作家只能写出九流的书。]]></content>
      <tags>
        <tag>读书</tag>
        <tag>思想者</tag>
        <tag>微习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode控制字符引起的问题以及解决思路]]></title>
    <url>%2Fvscode-control-characters-problem.html</url>
    <content type="text"><![CDATA[1. 环境 macOS Sierra 10.12.5 vscode 1.20.0 最新版 2. 如何重现这个问题在使用中文输入法输入中文的时候，一直按后退键，例如输入sfsf，当你按了4下后退键时，你会发现，搜狗输入法弹出框虽然消失了，但是页面上还会剩下一个s, 这是你如何再次按一下后退的话，s就会变成bs, 变成隐藏字符。这个一般是右边有markdown渲染插件时才会出现。 从更确切的角度说，是你的编辑器一旦开了webview，就会出现这个问题，即使是vscode的欢迎页，也是webview，也会导致这个问题。所以最好在写代码时尽量关闭webview。 3. 如何让隐藏字符现身Mac版的vscode控制字符一般是不会显示出来的，可以用一下的方法让其显示出来 1"editor.renderControlCharacters": true 在编辑器中显示的像很小的BS, 表示backspace的意思。一般是在输入时，按了后退或者删除会偶尔出现这个字符。 4. 隐藏的控制字符会出现什么问题？4.1. 控制字符在github上会出现问号例如下图的的和同字之间就是出现一个隐藏字符，在github上就会出现一个带有背景的问号。 4.2. 控制字符在Hexo NexT Local Search 会导致search.xml渲染失败，搜索框一直在转圈如果你使用浏览器打开search.xml，会发现解析报错 5. 如何解决5.1. 手动删除隐藏字符可以使用替换，先复制一个隐藏字符，然后把隐藏字符替换成空 5.2. 使用插件 Remove backspace control characterRemove backspace control character 在本家chromium已被合并，因此，在8月上旬发行的vscode 1.15将会重新确定(vscode 1.15, electron 1.7.4)。事实上，到现在这个问题还是没解决的 特点 格式化程序，用于删除打开的文档中包含的控制字符。要被删除的控制字符默认如下。 1/[\u0000]|[\u0001]|[\u0002]|[\u0003]|[\u0004]|[\u0005]|[\u0006]|[\u0007]|[\u0008]|[\u000b]|[\u000c]|[\u000d]|[\u000e]|[\u000f]|[\u0010]|[\u0011]|[\u0012]|[\u0013]|[\u0014]|[\u0015]|[\u0016]|[\u0017]|[\u0018]|[\u0019]|[\u001a]|[\u001b]|[\u001c]|[\u001d]|[\u001e]|[\u001f]|[\u001c]|[\u007f]/gm 用法 “editor.formatOnSave”: true 如果被设定,保存时启动 “editor.formatOnType”: true 在被设定的情况下，进行变换时;输入时启动 5.3. 坐等官方给出更好的解决方案官方这个bug依然还是open状态。Using IME with markdown preview enabled, press ESC/BACKSPACE leads in control characters #37114 5.4. 关闭所有webview这个问题一般出现在标签页含有webview时发生，所以在升级到vscode最新版后，在写代码时要注意，不要开启任何有webview的标签页，其中包括 关闭markdown渲染插件实时渲染的功能 关闭vscode欢迎页标签页 6. 为什么官方不直接解决这个问题？ vscode底层使用了electron，这是electron的Backspace can not erase the last one character during Japanese IME conversion (macOS) #9173bug, electron不解决这个问题，vscode就不会解决。 electron底层使用了chromium， 这是chromium的Two backspaces required to delete last character in webview inputbug, chromium不解决，elctron就无法解决。 综上，截止文章写出之时，这个问题依然没解决。 7. 参考 Mac 上的 VSCode 编写 Markdown 总是出现隐藏字符？ Hexo next 主题的 local search 功能失效，点击搜索链接无法弹出叠加层 Backspace can not erase the last one character during Chinese/Japanese IME conversion (macOS) #24981 Backspace can not erase the last one character during Japanese IME conversion (macOS) #9173 Two backspaces required to delete last character in webview input 控制字符 Using IME with markdown preview enabled, press ESC/BACKSPACE leads in control characters #37114]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>控制字符</tag>
        <tag>Local Search 解析失败</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VI必备常用场景快捷操作]]></title>
    <url>%2Fvi-useful-expressions.html</url>
    <content type="text"><![CDATA[1. 【字符串替换】快速修改配置文件版本号语法：%s/str1/str2/g 将文件中所有的str1字符串替换成str2字符串。 示例：某个服务从43版本升级到44版本 12// vi某个配置文件， 进入vi命令模式，输入:%s/43/44/g 这样做的好处是不需要移动光标去查找，然后进入插入模式去修改版本，而是直接替换，这样比较快捷。 注意：务必确认要被替换的字符串只有一个，否则可能造成误替换。 更多用法： 语法 功能 示例 :s/str1/str2/ 替换当前行第一个str1为str2 :s/44/45 :s/str1/str2/g 替换当前行所有的str1为str2 :s/44/45/g :%s/str1/str2/ 替换每一行第一个str1为str2 :%s/44/45 :%s/str1/str2/g 替换每一行所有的str1为str2 :%s/44/45/g 2. 光标移动注意：可配合 :set nu显示行号 语法 功能 示例 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。 20G 则会移动到这个档案的第20行 gg 移动到这个档案的第一行 n&lt;Enter&gt; n 为数字 光标向下移动 n 行 3&lt;Enter&gt; 向下移动三行 3. vi快捷手册]]></content>
      <tags>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xmysql 一行命令从任何mysql数据库生成REST API]]></title>
    <url>%2Freadme-of-xmysql.html</url>
    <content type="text"><![CDATA[github向我推荐这个xmysql时候，我瞟了一眼它的简介One command to generate REST APIs for any MySql Database, 说实话这个介绍让我眼前一亮，想想每次向后端的同学要个接口的时候，他们总是要哼哧哼哧搞个半天给才能我。抱着试试看的心态，我试用了一个疗程，oh不是， 是安装并使用了一下。 说实话，体验是蛮不错的，但是体验一把过后，我想不到这个工具的使用场景，因为你不可能把数据库的所有表都公开出来，让前端随意读写, 但是试试看总是不错的. 1 来吧，冒险一次！ 安装与使用12345npm install -g xmysqlxmysql -h localhost -u mysqlUsername -p mysqlPassword -d databaseName浏览器打开：http://localhost:3000， 应该可以看到一堆json 2 特点 产生REST Api从任何mysql 数据库 🔥🔥 无论主键，外键，表等的命名规则如何，都提供API 🔥🔥 支持复合主键 🔥🔥 REST API通常使用：CRUD，List，FindOne，Count，Exists，Distinct批量插入，批量删除，批量读取 🔥 关联表 翻页 排序 按字段过滤 🔥 行过滤 🔥 综合功能 Group By, Having (as query params) 🔥🔥 Group By, Having (as a separate API) 🔥🔥 Multiple group by in one API 🔥🔥🔥🔥 Chart API for numeric column 🔥🔥🔥🔥🔥🔥 Auto Chart API - (a gift for lazy while prototyping) 🔥🔥🔥🔥🔥🔥 XJOIN - (Supports any number of JOINS) 🔥🔥🔥🔥🔥🔥🔥🔥🔥 Supports views Prototyping (features available when using local MySql server only) Run dynamic queries 🔥🔥🔥 Upload single file Upload multiple files Download file 3 API 概览 HTTP Type API URL Comments GET / Gets all REST APIs GET /api/tableName Lists rows of table POST /api/tableName Create a new row PUT /api/tableName Replaces existing row with new row POST :fire: /api/tableName/bulk Create multiple rows - send object array in request body GET :fire: /api/tableName/bulk Lists multiple rows - /api/tableName/bulk?_ids=1,2,3 DELETE :fire: /api/tableName/bulk Deletes multiple rows - /api/tableName/bulk?_ids=1,2,3 GET /api/tableName/:id Retrieves a row by primary key PATCH /api/tableName/:id Updates row element by primary key DELETE /api/tableName/:id Delete a row by primary key GET /api/tableName/findOne Works as list but gets single record matching criteria GET /api/tableName/count Count number of rows in a table GET /api/tableName/distinct Distinct row(s) in table - /api/tableName/distinct?_fields=col1 GET /api/tableName/:id/exists True or false whether a row exists or not GET /api/parentTable/:id/childTable Get list of child table rows with parent table foreign key GET :fire: /api/tableName/aggregate Aggregate results of numeric column(s) GET :fire: /api/tableName/groupby Group by results of column(s) GET :fire: /api/tableName/ugroupby Multiple group by results using one call GET :fire: /api/tableName/chart Numeric column distribution based on (min,max,step) or(step array) or (automagic) GET :fire: /api/tableName/autochart Same as Chart but identifies which are numeric column automatically - gift for lazy while prototyping GET :fire: /api/xjoin handles join GET :fire: /dynamic execute dynamic mysql statements with params GET :fire: /upload upload single file GET :fire: /uploads upload multiple files GET :fire: /download download a file GET /api/tableName/describe describe each table for its columns GET /api/tables get all tables in database 3 更多资料 项目地址：https://github.com/o1lab/xmysql]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vscode中用standard style 风格去验证 vue文件]]></title>
    <url>%2Fvscode-lint-vue-file-by-standard-style.html</url>
    <content type="text"><![CDATA[1 JavaScript Standard Style简介本工具通过以下三种方式为你（及你的团队）节省大量时间： 无须配置。 史上最便捷的统一代码风格的方式，轻松拥有。 自动代码格式化。 只需运行 standard –fix 从此和脏乱差的代码说再见。 提前发现风格及程序问题。 减少代码审查过程中反反复复的修改过程，节约时间。 无须犹豫。再也不用维护 .eslintrc, .jshintrc, or .jscsrc 。开箱即用。 安装：1npm i standard -g 关于JavaScript 代码规范, 你可以点击链接看一下。 2 如何在vscode中用JavaScript Standard Style风格去验证 vue文件实际上JavaScript Standard Style有一个FAQ, 说明了如何使用。 但是有一点非常重要的作者没有提到，就是eslint-plugin-html这个插件必须要安装3.x.x版本的, 现在eslint-plugin-html, 已经升级到4.x版本，默认不写版本号安装的就是4.x版本的，所以会出现问题。参考 ESLint v4 is only supported by eslint-plugin-html v3, so you can’t use eslint-plugin-html v1.5.2 with it (I should add a warning about this when trying to use the plugin with an incompatible version on ESLint). If you do not use ESLint v4, please provide more information (package.json, a gist to reproduce, …) 1234567891011121314151617181920212223242526// FAQHow to lint script tag in vue or html files?You can lint them with eslint-plugin-html, just install it first, then enable linting for those file types in settings.json with: "standard.validate": [ "javascript", "javascriptreact", "html" ], "standard.options": &#123; "plugins": ["html"] &#125;, "files.associations": &#123; "*.vue": "html" &#125;,If you want to enable autoFix for the new languages, you should enable it yourself: "standard.validate": [ "javascript", "javascriptreact", &#123; "language": "html", "autoFix": true &#125; ], "standard.options": &#123; "plugins": ["html"] &#125; 3 综上， 整理一下安装思路3.1 需要安装哪些包？ npm i -g standard npm i -g eslint-plugin-html@3.2.2 必须是3x版本 npm i -g eslint以上三个包都是全局安装的，如果你想看看全局安装了哪些包可以用npm list -g --depth=0查看 3.2 vscode config 如何写？1234567891011121314"standard.validate": [ "javascript", "javascriptreact", &#123; "language": "html", "autoFix": true &#125;],"standard.options": &#123; "plugin": ["html"]&#125;,"files.associations": &#123; "*.vue": "html"&#125;, 3.3 如何在保存文件时，自动使用standard格式化vue文件1"standard.autoFixOnSave": true 4. 如果还不行怎么办？ 重启一下vscode 重启一下电脑 在此文后追加评论]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>vue</tag>
        <tag>standard style</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 WebRTC 构建 Web SIP Phone]]></title>
    <url>%2Fwebrtc-web-sip-phone.html</url>
    <content type="text"><![CDATA[0 阅前须知 本文并不是教程，只是实现方案 我只是从WEB端考虑这个问题，实际还需要后端sip服务器的配合 jsSIP有个非常不错的在线demo, 可以去哪里玩耍，很好玩呢 try jssip 1. 技术简介 WebRTC: WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。它于2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准 SIP: 会话发起协议（Session Initiation Protocol，缩写SIP）是一个由IETF MMUSIC工作组开发的协议，作为标准被提议用于创建，修改和终止包括视频，语音，即时通信，在线游戏和虚拟现实等多种多媒体元素在内的交互式用户会话。2000年11月，SIP被正式批准成为3GPP信号协议之一，并成为IMS体系结构的一个永久单元。SIP与H.323一样，是用于VoIP最主要的信令协议之一。 一般来说，要么使用实体话机，要么在系统上安装基于sip的客户端程序。实体话机硬件成本高，基于sip的客户端往往兼容性差，无法跨平台，易被杀毒软件查杀。 而WebRTC或许是更好的解决方案，只要一个浏览器就可以实时语音视频通话，这是很不错的解决方案。WebSocket可以用来传递sip信令，而WebRTC用来实时传输语音视频流。 2. 前端WebRTC实现方案其实我们不需要去自己处理WebRTC的相关方法，或者去处理视频或者媒体流。市面上已经有不错的模块可供选择。 2.1 jsSIPjsSIP是JavaScript SIP 库 功能特点如下： 可以在浏览器或者Nodejs中运行 使用WebSocket传递SIP协议 视频音频实时消息使用WebRTC 非常轻量 100%纯JavaScript 使用简单并且具有强大的Api 服务端支持 OverSIP, Kamailio, Asterisk, OfficeSIP，reSIProcate，Frafos ABC SBC，TekSIP 是RFC 7118 and OverSIP的作者写的 下面是使用JsSIP打电话的例子，非常简单吧1234567891011121314151617181920212223242526272829303132333435// Create our JsSIP instance and run it:var socket = new JsSIP.WebSocketInterface('wss://sip.myhost.com');var configuration = &#123; sockets : [ socket ], uri : 'sip:alice@example.com', password : 'superpassword'&#125;;var ua = new JsSIP.UA(configuration);ua.start();// Register callbacks to desired call eventsvar eventHandlers = &#123; 'progress': function(e) &#123; console.log('call is in progress'); &#125;, 'failed': function(e) &#123; console.log('call failed with cause: '+ e.data.cause); &#125;, 'ended': function(e) &#123; console.log('call ended with cause: '+ e.data.cause); &#125;, 'confirmed': function(e) &#123; console.log('call confirmed'); &#125;&#125;;var options = &#123; 'eventHandlers' : eventHandlers, 'mediaConstraints' : &#123; 'audio': true, 'video': true &#125;&#125;;var session = ua.call('sip:bob@example.com', options); 2.2 SIP.jssip.js项目实际是fork自jsSIP的，这里主要介绍它的服务端支持情况。其他接口自己自行查阅 FreeSWITCH Asterisk OnSIP FreeSWITCH Legacy 3. 平台考量 由于WebRTC对浏览器有较高的要求，你可以看看下图，哪些浏览器支持WebRTC, 所有IE浏览器都不行，chrome系支持情况不错。 3.1 考量标准 跨平台 兼容性 体积 集成性 硬件要求 开发成本 3.2 考量表格 种类 适用平台 优点 缺点 基于electron开发的桌面客户端 window, mac, linux 跨平台，兼容好 要下载安装，体积大（压缩后至少48MB），对电脑性能有要求 开发js sdk 现代浏览器 体积小，容易第三方集成 兼容差(因为涉及到webRTC, IE11以及以都不行，对宿主环境要求高)，客户集成需要开发量 开发谷歌浏览器扩展 谷歌浏览器 体积小 兼容差（仅限类chrome浏览器） 4 参考文档 and 延伸阅读 and 动手实践 Js SIP Getting Started 120行代码实现 浏览器WebRTC视频聊天 SIP协议状态码： 5 常见问题422: “Session Interval Too Small”jsSIP默认携带Session-Expires: 90的头部信息，如果这个超时字段小于服务端的设定值，那么就会得到如下422的响应。参见SIP协议状态码：, 可以在call请求中设置sessionTimersExpires, 使其超过服务端的设定值即可1234call(targer, options)option.sessionTimersExpiresNumber (in seconds) for the default Session Timers interval (default value is 90, do not set a lower value). 6 最后，你我共勉]]></content>
      <tags>
        <tag>webrtc</tag>
        <tag>sip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[追本溯源 substr与substring历史漫话]]></title>
    <url>%2Fsubstr-substrig-history.html</url>
    <content type="text"><![CDATA[引子： 很多时候，当我要字符串截取时，我会想到substr和substring的方法，但是具体要怎么传参数时，我总是记不住。哪个应该传个字符串长度，哪个又应该传个开始和结尾的下标，如果我不去查查这两个函数，我始终不敢去使用它们。所以我总是觉得，这个两个方法名起的真是蹩脚。然而事实是这样的吗？ 看来是时候扒一扒这两个方法的历史了。 1 基因追本溯源 在编程语言的历史长河中，曾经出现过很多编程语言。然而大浪淘沙，铅华洗尽之后，很多早已折戟沉沙，有些却依旧光彩夺目。那么stubstr与substring的DNA究竟来自何处？ 1950与1960年代 1954 - FORTRAN 1958 - LISP 1959 - COBOL 1964 - BASIC 1970 - Pascal 1967-1978：确立了基础范式 1972 - C语言 1975 - Scheme 1978 - SQL (起先只是一种查询语言，扩充之后也具备了程序结构) 1980年代：增强、模块、性能 1983 - C++ (就像有类别的C) 1988 - Tcl 1990年代：互联网时代 1991 - Python 1991 - Visual Basic 1993 - Ruby 1995 - Java 1995 - Delphi (Object Pascal) 1995 - JavaScript 1995 - PHP 2009 - Go 2014 - Swift (编程语言) 1.1 在C++中首次出现substr() 在c语言中，并没有出现substr或者substring方法。然而在1983，substr()方法已经出现在C++语言中了。然而这时候还没有出现substring, 所以可以见得：substr是stustring的老大哥 1string substr (size_t pos = 0, size_t len = npos) const; 从C++的方法定义中可以看到, substr的参数是开始下标，以及字符串长度。 12std::string str="We think in generalities, but we live in details.";std::string str2 = str.substr (3,5); // "think" 1.2 在Java中首次出现substring() 距离substr()方法出现已经有了将近十年之隔，此间涌现一批后起之秀，如: Python, Ruby, VB之类，然而他们之中并没有stustring的基因，在Java的String类中，我们看到两个方法。从这两个方法之中我们可以看到：substring方法基本原型的参数是开始和结束的下标。 1234String substring(int beginIndex) // 返回一个新的字符串，它是此字符串的一个子字符串。String substring(int beginIndex, int endIndex)// 返回一个新字符串，它是此字符串的一个子字符串。 1.3 JavaScript的历史继承 1995年，网景公司招募了Brendan Eich，目的是将Scheme编程语言嵌入到Netscape Navigator中。在开始之前，Netscape Communications与Sun Microsystems公司合作，在Netscape Navigator中引入了更多的静态编程语言Java，以便与微软竞争用户采用Web技术和平台。网景公司决定，他们想创建的脚本语言将补充Java，并且应该有一个类似的语法，排除采用Perl，Python，TCL或Scheme等其他语言。为了捍卫对竞争性提案的JavaScript的想法，公司需要一个原型。 1995年5月，Eich在10天内写完。 上帝用七天时间创造万物, Brendan Eich用10天时间创造了一门语言。或许用创造并不合适，因为JavaScript是站在了Perl，Python，TCL或Scheme等其他巨人的肩膀上而产生的。 JavaScript并不像C那样出身名门，在贝尔实验室精心打造，但是JavaScript在往后的自然选择中，并没有因此萧条，反而借助于C,C++, Java, Perl，Python，TCL, Scheme优秀基因，进化出更加强大强大的生命力。 因此可以想象，在10天之内，当Brendan Eich写到String的substr和substring方法时，或许他并没困惑着两个方法的参数应该如何设置，因为在C++和Java的实现中，已经有了类似的定义。 如果你了解历史，你就不会困惑现在。 2 所以，substr和substring究竟有什么不同？如下图所示：substr和substring都接受两个参数，他们的第一个参数的含义是相同的，不同的是第二个参数。substr的第二个参数是到达结束点的距离，substring是结束的位置。 3 参考文献 维基百科：程式語言歷史 C++ std::string::substr JavaScript 如有不正确的地方，欢迎指正。]]></content>
      <tags>
        <tag>substr</tag>
        <tag>substring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回首2017 你其实是一个收集贝壳的孩子]]></title>
    <url>%2F2017-my-star-collection.html</url>
    <content type="text"><![CDATA[我不知道世上的人对我怎样评价。我却这样认为：我好像是在海上玩耍，时而发现了一个光滑的石子儿，时而发现一个美丽的贝壳而为之高兴的孩子。尽管如此，那真理的海洋还神秘地展现在我们面前。—— 牛顿 github也像是一片海海，2017年，我大约从这篇海中捡了200多个彩色的贝壳。在年底之前，挑一些精致美丽的贝壳，分享出来。 1. docsify：想让你的文档拥有Vue官方文档一样的颜值吗？我喜欢Vue的原因是Vue官方文档颜值很高 by me, 那么你想来一份吗？ 高颜值 非常简单 无需构建，写完文档直接发布 容易使用并且轻量 (~18kB gzipped) 智能的全文搜索 提供多套主题 丰富的 API 支持 Emoji 兼容 IE10+ 支持 SSR (example) 2. JavaScript Standard Style：一千个开发者只有一个风格还在为要不要分号争吵吗？ 还在为两个空格和四个空格犹豫吗？ 还在为各种格式检查的配置文件苦恼吗？ 其实，你需要的只是JavaScript Standard Style罢了，无数大牛公司在用，你还在犹豫什么？ 好多编辑器支持JavaScript Standard Style，安装过后，ctrl + s一下，哪怕shi一样的代码，也会瞬间华丽变身成维多利亚的秘密。 帅的人已经用了，不帅的还在犹豫 无须配置。 史上最便捷的统一代码风格的方式，轻松拥有。 自动代码格式化。 只需运行 standard –fix - 从此和脏乱差的代码说再见。 提前发现风格及程序问题。 - 减少代码审查过程中反反复复的修改过程，节约时间。 使用两个空格 – 进行缩进 无分号 – 这没什么不好。不骗你！ 查看更多 – 为何不试试 standard 规范呢！ 3. mitt: 纳米级别的事件订阅系统如果你看了mitt的源码，你应该会惊呼：WTF，人家接近50行代码也能获得2000多颗星！！！！ 纳米级别: 小于200B 相当有用: 用”*”可以去订阅所有事件 非常熟悉: 类似于Node’s EventEmitter 函数式: 方法不依赖this 4. faker.js: 最优雅的假数据生成器 Supports all Faker API Methods Full-Featured Microservice Hosted by hook.io 123var randomName = faker.name.findName(); // Caitlyn Kerlukevar randomEmail = faker.internet.email(); // Rusty@arne.infovar randomCard = faker.helpers.createCard(); // random contact card containing many properties 5. superstruct: 精准详细的runtime 数据验证工具 给出的错误提示很详细，非常容易定位bug 帮你做好那些数据验证的脏活累活 123456789101112131415161718192021222324const &#123; superstruct, struct &#125; = window.Superstructconst User = struct(&#123; id: 'number', name: 'string',&#125;)const data = &#123; id: 'invalid', name: 'Jane Smith',&#125;try &#123; const user = User(data) log('valid', user)&#125; catch (e) &#123; const &#123; message, path, data, type, value &#125; = e log('invalid', &#123; message, path, data, type, value &#125;)&#125;function log(type, data) &#123; document.body.className = type document.body.textContent = JSON.stringify(data, null, 2)&#125; 可以看一下她输出的错误信息123456789101112&#123; "message": "Expected a value of type `number` for `id` but received `\"invalid\"`.", "path": [ "id" ], "data": &#123; "id": "invalid", "name": "Jane Smith" &#125;, "type": "number", "value": "invalid"&#125; 6. uppy: 下一代开源文件上传插件Uppy是一款时尚，模块化的文件上传器，可以与任何应用程序无缝集成。这是快速，易于使用，让您担心比建立一个文件上传更重要的问题。 从本地磁盘，Google云端硬盘，Dropbox，Instagram获取文件，或使用相机捕捉和记录自拍; 用一个漂亮的界面预览和编辑元数据; 上传到最终目的地，可选择进行处理/编码 7. Inquirer.js: 在命令行里做问卷调查12345678910111213141516171819202122232425262728'use strict'var inquirer = require('inquirer')var questions = [ &#123; type: 'input', name: 'name', message: '请输入你的名字' &#125;, &#123; type: 'input', name: 'age', message: '请输入你的年龄', default: function () &#123; return '10' &#125; &#125;, &#123; type: 'list', name: 'sex', message: '请选择你的性别', choices: ['男', '女'] &#125;]inquirer.prompt(questions).then(answers =&gt; &#123; console.log(JSON.stringify(answers, null, ' '))&#125;) 123456789➜ src git:(master) ✗ node query.js? 请输入你的名字 wdd? 请输入你的年龄 23? 请选择你的性别 男&#123; "name": "wdd", "age": "23", "sex": "男"&#125;]]></content>
      <tags>
        <tag>star</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[you-dont-need-serial]]></title>
    <url>%2Fyou-dont-need-serial.html</url>
    <content type="text"><![CDATA[1 You-Dont-Need-JavaScript CSS是强大的，你可以做很多事情没有JS。 本文教你使用原生CSS做下面的事情。 内容目录 手风琴/切换 圆盘传送带 检查复选框的计数器 翻转点击 Textfield上的浮动标签 字体（拉丁） 游戏 悬停/弹出信息 图片廊 菜单 移动菜单关闭画布 汉堡菜单 花式菜单 莫代尔/弹出 鼠标跟踪 视差滚动 标签 待办事项列表 提示 树视图 Twitter心动画 动态图像着色 连锁反应 响应式计数器显示不适合屏幕的项目数量 可以看一下纯CSS的例子 2 You-Dont-Need-Lodash-Underscore Lodash和Underscore是伟大的现代JavaScript实用程序库，它们被前端开发人员广泛使用。但是，如果您将目标锁定为现代浏览器，则可能会发现，许多方法已经得到ES5和ES6的原生支持。如果你想要你的项目需要更少的依赖，并且你清楚的知道你的目标浏览器，那么你可能不需要Lodash / Underscore。 来自开发者的声音 在代码变臃肿之前，请使用原生JS对象和数组工具函数. —Cody Lindley, Author of jQuery Cookbook and JavaScript Enlightenment 你可能不需要lodash. 有许多好用的原生方法了. —Daniel Lamb, Computer Scientist, Technical Reviewer of Secrets of the JavaScript Ninja and Functional Programming in JavaScript 我想不是，但我想要它. —Tero Parviainen, Author of build-your-own-angular 我承认，我曾经过度使用lodash. —@therebelrobot, Maker of web things, Facilitator for Node.js/io.js 内容目录 Array _.compact _.concat _.fill _.find _.findIndex _.first _.flatten _.flattenDeep .head and .tail _.indexOf _.join _.last _.lastIndexOf _.reverse _.without _.slice _.isArray Collection _.each _.every _.filter _.groupBy _.includes _.map .minBy and .maxBy _.pluck _.range _.reduce _.reduceRight _.size _.some Function _.after Lang _.isNaN Object _.assign _.keys _.toPairs _.values String _.repeat _.template _.toLower _.toUpper _.trim _.replace 3 You-Dont-Need-jQuery纯JavaScript的例子, 实现做jQuery与查询，样式，dom，ajax，事件等 前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10 以上浏览器。 内容目录 Translations Query Selector CSS &amp; Style DOM Manipulation Ajax Events Utilities Promises Animation Alternatives Browser Support You-Dont-Need-GUI图形用户界面对计算机用户非常友好。它们被引入以响应命令行界面（CLI）感知的陡峭学习曲线。 但是，他们往往需要更多的资源，功能不强，难以通过脚本自动化。 作为计算机专家，我们希望更高效，更好地完成工作。我们知道命令字可能不容易被发现或助记符，所以我们尝试列出一些您可能试图在GUI中执行的常见任务。 内容目录 复制一个文件 复制一个文件 复制一个文件夹 复制一个文件夹 移动一个文件 重命名一个文件 移动一个文件夹 重命名文件夹 合并文件夹 创建一个新的文件 新建一个文件夹 显示文件/文件夹大小 用默认程序打开一个文件 压缩一个文件夹 解压缩文件夹 删除一个文件 删除一个文件夹 列出文件夹内容 树查看文件夹及其子文件夹 找到一个陈旧的文件 显示一个日历 找到未来的日期 使用计算器 强制退出程序]]></content>
  </entry>
  <entry>
    <title><![CDATA[不常用却很有妙用的事件及方法]]></title>
    <url>%2Fuseful-browser-events.html</url>
    <content type="text"><![CDATA[1 visibilitychange事件触发条件：浏览器标签页被隐藏或显示的时候会触发visibilitychange事件. 使用场景：当标签页显示或者隐藏时，触发一些业务逻辑 123document.addEventListener("visibilitychange", function() &#123; console.log( document.visibilityState );&#125;); 2 storage事件触发条件：使用localStorage or sessionStorage存储或者修改某个本地存储时 使用场景：标签页间通信 123456789// AB页面同源// 在A 页面window.addEventListener('storage', (e) =&gt; &#123;console.log(e)&#125;)// 在B 页面，向120打个电话localStorage.setItem('makeCall','120')// 然后可以在A页面间有输出, 可以看出A页面 收到了B页面的通知...key: "makeCall", oldValue: "119", newValue: "120", ... 3 beforeunload事件触发条件：当页面的资源将要卸载(及刷新或者关闭标签页前). 当页面依然可见，并且该事件可以被取消只时 使用场景：关闭或者刷新页面时弹窗确认，关闭页面时向后端发送报告等 123456window.addEventListener("beforeunload", function (e) &#123; var confirmationMessage = "\o/"; e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+ return confirmationMessage; // Gecko, WebKit, Chrome &lt;34&#125;); 4 navigator.sendBeacon这个方法主要用于满足 统计和诊断代码 的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。过早的发送数据可能导致错过收集数据的机会。然而， 对于开发者来说保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在卸载事件处理器中产生的异步 XMLHttpRequest 。 使用 sendBeacon() 方法，将会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：使它可靠，异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单！ 注意：该方法在IE和safari没有实现 使用场景：发送崩溃报告 12345window.addEventListener('unload', logData, false);function logData() &#123; navigator.sendBeacon("/log", analyticsData);&#125;]]></content>
      <tags>
        <tag>visibilitychange</tag>
        <tag>sendBeacon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xfire 简单优雅、高度可配置的fetch接口批量生成工具]]></title>
    <url>%2Foverview-of-xfire.html</url>
    <content type="text"><![CDATA[我曾写过两篇文章 jQuery进阶 用最优雅的方式写ajax请求, axios进阶 用最优雅的方式写ajax请求, 原理都是在将使用配置文件的方式，自动生成接口方法。 在多个项目中，我曾使用这种配置的方式批量生成ajax接口，但是每次都要造轮子是很繁琐的，索性自己发布一个npm包吧，于是xfire出来了。 xfire地址：https://github.com/wangduanduan/xfire， 觉得不错的话，可以给xfire点个赞或者开个issue，或者提个建议。谢谢。 1. xfire 非常简单，高度可配置的fetch接口批量生成工具。 2. 特点 :smile: 非常简单: 提供配置文件,自动生成接口 :triangular_ruler: 提前验证:支持请求体格式验证 :bug: 报错详细: 给出具体的报错位置,字段信息 3. 安装123npm install -S xfireyarn add xfire 4. demo首先需要一个配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243// api.config.jsexport default &#123; prefix: 'http://localhost:80', list: [ &#123; name: 'login', desp: 'sercurity login', path: '/agent/login', method: 'post', contentType: 'formData', bodyStruct: &#123; username: 'string', password: 'string', namespace: 'string' &#125;, defaultBody: &#123; password: 'Aa123456' &#125;, status: &#123; 401: 'username or password wrong' &#125; &#125;, &#123; name: 'heartBeat', path: '/sdk/api/csta/agent/heartbeat/&#123;&#123;agentId&#125;&#125;', &#125;, &#123; name: 'setAgentState', desp: 'set agent state', path: '/sdk/api/csta/agent/state/&#123;&#123;namespace&#125;&#125;', method: 'post', bodyStruct: &#123; agentId: 'string?', loginId: 'string', func: 'string', agentMode: 'string?', device: 'string?', password: 'string' &#125; &#125; ]&#125; 然后引入xfire1234import xfire from 'xfire'import apiConfig from './api.config.js'const API = xfire.init(apiConfig) POTST 发送formData类型的数据示例1234567891011API.login.fire(&#123;&#125;, &#123; username: 'wangduanduan', password: '123456', namespace: 'dd.com'&#125;).then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) GET 数据示例123456789API.heartBeat.fire(&#123; agentId: '5001@dd.com'&#125;).then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) POST json类型数据示例12345678910111213141516API.setAgentState.fire(&#123; namespace: 'windows'&#125;, &#123; agentId: '5001@dd.com', loginId: '5001@dd.com', func: 'login', agentMode: 'Ready', device: '8001@dd.com', password: '123456'&#125;).then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) 5. xfire API1const API = xfire.init(config) config 字段说明 注意:如果config无法通过下面的格式验证,则会直接报错 字段名 类型 是否必须 默认值 说明 config.prefix string 是 无 接口url公用的前缀 config.list array 是 无 接口数组 config list字段说明 字段名 类型 是否必须 默认值 说明 name string 是 无 接口名 desp string 否 无 接口描述 path string 是 无 接口路径 method enum string 否 get 请求方式: get, post, put, delete contentType enum string 否 json 请求体类型: json, formData。json会被渲染: application/json; charset=UTF-8, formData会被渲染成: application/x-www-form-urlencoded; charset=UTF-8 bodyStruct object 否 无 请求体格式验证结构, 如果bodyStruct存在,则使用bodyStruct验证body: 具体格式参考superstruct defaultBody object 否 无 默认请求体。bodyStruct存在的情况下才有效 status object 否 无 响应状态码及其含义 当某个list对象的 name 不存在时,config验证时的报错:1Uncaught StructError: Expected a value of type `string` for `name` but received `undefined`. 当发送请求时,请求体不符合bodyStruct时, 报错如下1234567891011121314151617181920...name: 'login',desp: 'sercurity login',path: '/agent/login',method: 'post',contentType: 'formData',bodyStruct: &#123; username: 'string', password: 'string', namespace: 'string'&#125;,...API.login.fire(&#123;&#125;, &#123; // username: '5001', password: 'Aa123456', namespace: 'zhen04.cc'&#125;)Uncaught StructError: Expected a value of type `string` for `username` but received `undefined`. 6. xfire 实例 APIxfire.init()方法会返回xfire实例对象,该对象上有一个特殊方法$setHeaders, 还有其他的由配置文件产生的方法。 1const API = xfire.init(apiConfig) 6.1. $setHeaders(): 设置请求头部信息$setHeaders()用来设置除了contentType以外的请求头, 一旦设置请求头部信息,所有的实例接口在发送请求时,都会带有该头部信息。1API.$setHeaders(&#123;sessionId: 'jfsldkf-sdflskdjf-sflskfjlsf'&#125;) 6.2. api方法: fire(pathParm, body)pathParm对象上的数据最终会被渲染到请求路径上, body是请求体。 12345678... &#123; name: 'heartBeat', desp: 'agent heart beat', path: '/sdk/api/csta/agent/heartbeat/&#123;&#123;agentId&#125;&#125;', method: 'post' &#125;,... 类似上面的对象,会产生一个以heartBeat为名称的方法,所有请求方法都是fire()方法。 1234567API.xxx.fire(pathParm, body)// 不需要请求体时, body可以不传API.xxx.fire(pathParm)// 不需要参数渲染到路径时,pathParm必须传空对象:&#123;&#125;API.xxx.fire(&#123;&#125;, body) 例子:123456789API.heartBeat(&#123; agentId: '5001@ee.com'&#125;).then((res) =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) 关于path和 fire的 pathParm参数:12345678// path 如下path: '/store/order/&#123;&#123;type&#125;&#125;/&#123;&#123;age&#125;&#125;'// 则pathParm应该是&#123; type: 'dog', aget: 14&#125; 注意: pathParm不支持复杂的数据类型。 12345678910111213141516// 原始数据类型 string, number, boolean 都是可以的&#123; key1: 'string', key2: number, key3: boolean&#125;// 复杂的数据类型,如数组和嵌套对象, 函数, 将导致渲染失败// bad&#123; key1: [1, 3, 3], key2: &#123; key3: 'string' &#125;, key4: function()&#123;&#125;&#125; 7. :warning: polyfillxfire底层使用了浏览器原生的Promise, fetch, Object.keys(), Object.assign() 所以对浏览器是有要求的。xfire本身不带有任何polyfill。 目前IE11以及以下是不支持Promise和fetch的。 在此给出两个方案: 7.1. 方案1: babel-polyfill通过引入babel-polyfill, 让浏览器支持xfire所需要的原生方法。 7.2. 方案2: polyfill.io 只需要为您的网站,为每个浏览器量身定制的polyfills。 复制代码释放魔法: 1&lt;script src="https://cdn.polyfill.io/v2/polyfill.min.js"&gt;&lt;/script&gt; Polyfill.io读取每个请求的User-Agent头并返回适合请求浏览器的polyfill。 根据您在应用中使用的功能量身定制响应,并查看我们的实例以快速入门。 8. ajax Vs fetch与其使用各种ajax第三方库，不如使用原始fetch 总结一下，Fetch 优点主要有： 语法简洁，更加语义化基于标准 Promise 实现，支持 async/await同构方便，使用 isomorphic-fetch –传统 Ajax 已死，Fetch 永生未来更容易扩展 – by me 我使用ajax经历过三个阶段：1、 jQuery时期，我用jQuery的ajax2、 类似Vue的现代框架时，使用axio3、 再后来我就使用浏览器原生的fetch Fetch API 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合乎逻辑的方式来跨网络异步获取资源。– MDN 这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如 CORS和HTTP的扩展。– MDN 从caniuse的数据来看，fetch方法除IE11不支持以外，大部分常用浏览器都支持了。 fetch接口示例：12345678910111213141516fetch('/users.json') .then(function(response) &#123; return response.json() &#125;).then(function(json) &#123; console.log('parsed json', json) &#125;).catch(function(ex) &#123; console.log('parsing failed', ex) &#125;) fetch('/users.html') .then(function(response) &#123; return response.text() &#125;).then(function(body) &#123; document.body.innerHTML = body &#125;) 9. fetch相关文章 传统 Ajax 已死，Fetch 永生 fetch 简介: 新一代 Ajax API fetch 没有你想象的那么美 10. fetch相关库 github/fetch]]></content>
      <tags>
        <tag>xfire</tag>
        <tag>fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[trim-everything trim所有数据类型]]></title>
    <url>%2Ftrim-every-thing.html</url>
    <content type="text"><![CDATA[trim-everythingtrim所有字段，因为底层使用的JSON.stringify作为遍历器，所以如果字段的值是function，那么会被trim掉。 项目地址：trim-everything 安装123npm i -S trim-everythingyarn add trim-everything 特点 trim undefined trim null trim number trim string trim object trim array 零依赖 开始下面使用jest做的测试用例，可以从中看出trim的用法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* global test, expect */const trim = require('trim-everything')test('trim undefined', () =&gt; &#123; expect(trim()).toBeUndefined()&#125;)test('trim null', () =&gt; &#123; expect(trim(null)).toBeNull()&#125;)test('trim number', () =&gt; &#123; expect(trim(12.12)).toBe(12.12)&#125;)test('trim string', () =&gt; &#123; expect(trim(' 12abcd ')).toBe('12abcd')&#125;)test('trim object', () =&gt; &#123; expect(trim(&#123; userName: ' wangdd ', age: 12, some: false, address: ' shanghai' &#125;)) .toEqual(&#123; userName: 'wangdd', age: 12, some: false, address: 'shanghai' &#125;)&#125;)test('trim array', () =&gt; &#123; expect(trim([ &#123; userName: ' wangdd ', age: 12, some: false, address: ' shanghai' &#125;, ' abcd ', false, 12.12, &#123; userName: ' wangdd ', age: 12, some: false, address: ' shanghai', child: &#123; userName: ' wangdd ', age: 12, some: false, address: ' shanghai' &#125; &#125; ])) .toEqual( [ &#123; userName: 'wangdd', age: 12, some: false, address: 'shanghai' &#125;, 'abcd', false, 12.12, &#123; userName: 'wangdd', age: 12, some: false, address: 'shanghai', child: &#123; userName: 'wangdd', age: 12, some: false, address: 'shanghai' &#125; &#125; ] )&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[mac vscode 更新失败 Permission denied解决办法]]></title>
    <url>%2Fmac-vscode-update-permission-denied.html</url>
    <content type="text"><![CDATA[0. 现象Could not create temporary directory: Permission denied 1. 问题起因在 /Users/username/Library/Caches/目录下，有以下两个文件， 可以看到，他们两个的用户是不一样的，一个是root一个username, 一般来说，我是以username来使用我的mac的。就是因为这两个文件的用户不一样，导致了更新失败。 12drwxr-xr-x 6 username staff 204B Jan 17 20:33 com.microsoft.VSCodedrwxr--r-- 2 root staff 68B Dec 17 13:51 com.microsoft.VSCode.ShipIt 2. 解决方法注意： 先把vscode 完全关闭 12345678// 1. 这一步是需要输入密码的sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/// 2. 这一步是不需要输入密码的, 如果不进行第一步，第二步会报错sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/*// 3. 更新xattrxattr -dr com.apple.quarantine /Applications/Visual\ Studio\ Code.app 3. 打开vscodeCode &gt; Check for Updates, 点击之后，你会发现Check for Updates已经变成灰色了，那么你需要稍等片刻，马上就可以更新，之后会跳出提示，让你重启vscode, 然后重启一下vscode, 就ok了。 4. 参考 joaomoreno commented on Feb 7, 2017 • edited]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建一个舒心高效的windows + shell 工作环境]]></title>
    <url>%2Fconfortable-windows-shell-env.html</url>
    <content type="text"><![CDATA[1 ConEmu命令行： 漂亮的不像实力派我曾这篇文章中《自从装了windows神器，再也不用羡慕mac了》，介绍过好几个命令行神器。 里面几个命令行我都有用过，但是最让我喜欢的是ConEmu，先说说它的特点。 平滑的窗口大小调整 标签和分裂（窗格） 窗口字体消除锯齿：标准，清除类型，禁用 快速的复制粘贴 可切换使用shell或者dos, 过着git bash等 你可以看看它完美的侧颜。 2 gow shell工具箱: 身材苗条却又肌肉发达我曾经想过，如果能在直接windows上用linux的grep, curl等命令，那该多好啊！我也曾试过Cygwin, 但是那哥斯拉般大小的体积让我只能望洋兴叹。 曾几何时，我遇到了Gow，她10MB版苗条的身材，却又能满足你80%的日常工作的需要。 当别人还有notepad++，慢慢吞吞加载一个30MB的日志的时候，你用grep命令，已经搜索到了想要的结果。所谓：天下武功，无坚不摧，唯快不破， 就是这个感觉。 Gow（Gnu On Windows）是Cygwin的轻量级替代品。 它使用了一个方便的Windows安装程序，安装了大约130个非常有用的开源UNIX应用程序，编译为本机win32二进制文件。 它被设计成尽可能小，大约10 MB，而Cygwin可以运行在100 MB以上，具体取决于选项。 这里有一些来自Gow用户的引用： “Gow是使Windows可以使用/可用的少数几件事之一” “我不断地使用Gow，太棒了。” “我只是想让你知道，GOW Suite非常棒 - 它比Cygwin工具轻得多，而且非常有用。 3 f.lux：我轻轻看一眼，这暖暖的感觉，她都有作为一个程序员，免不了长时间的面对电脑屏幕。结果经常会眼睛难受。然后我尝试了一下f.lux, 装上之后，配置了一下时区， 电脑屏幕马上变成屎黄色。抱着试试看的心态，我用了几天，几天过后，我实在受不了这颜色了。 然后就卸载了，没过多上时间，我觉得有点不对劲，不舒服。总是感觉缺点什么。 就放佛 张韶涵的歌《遗失的美好》：有些人说不清哪里好 但就是谁都替代不了, 然后我就又装上了f.lux。在我的影响下，我附近的几个小伙伴，也都装上了f.lux。 后来我换了mac, 但是我也装了f.lux。 f.lux让你的电脑屏幕看起来就像你所在的房间一样。 当日落时，它使您的电脑看起来像你的室内灯。 在早上，它使事情看起来像阳光。 告诉f.lux你有什么样的照明，以及你住的地方。 然后忘了它。 f.lux会自动完成剩下的工作。 4 visual studio code: 最好用的轻量编辑器 颜值很高 微软开源的产品，质量保证 集成git 插件很多，下载很快 免费 体积很小，占用内存很小，启动很快]]></content>
      <tags>
        <tag>windows</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE11 0x2ee4 bug 以及类似问题解决方法]]></title>
    <url>%2Fie11-0X2ee4-bug.html</url>
    <content type="text"><![CDATA[一千个IE浏览器访问同一个页面，可能报一千种错误。前端激进派对IE恨得牙痒痒，但是无论你爱，或者不爱，IE就在那里，不来不去。 一些银行，以及政府部门，往往都是指定必须使用IE浏览器。所以，一些仅在IE浏览器上出现的问题。总结起来问题的原因很简单：IE的配置不正确 下面就将一个我曾经遇到的问题: IE11 0x2ee4， 以及其他的问题的解决方案 1. IE11 SCRIPT7002: XMLHttpRequest: 网络错误 0x2ee4 背景介绍：在一个HTTPS域向另外一个HTTPS域发送跨域POTST请求时 这个问题在浏览器的输出内容如下，怪异的是，并不是所有IE11都会报这个错误。 1SCRIPT7002: XMLHttpRequest: 网络错误 0x2ee4, 由于出现错误 00002ee4 而导致此项操作无法完成 stackoverflow上有个答案，它的思路是：在post请求发送之前，先进行一次get操作 这个方式我试过，是可行的。但是深层次的原因我不是很明白。 然而真相总有大白的一天，其实深层次的原因是，IE11的配置。 去掉检查证书吊销的的检查，解决0x2ee4的问题 解决方法 去掉check for server certificate revocation*， 也有可能你那边是中文翻译的：叫检查服务器证书是否已吊销 去掉检查发型商证书是否已吊销 点击确定 重启计算机 2 其他常规设置2.1 去掉兼容模式， 使用Edge文档模式 下图中红色框里的按钮也要取消勾选 2.2 有些使用activeX，还是需要检查是否启用的 2.3 允许跨域如果你的接口跨域了，还要检查浏览器是否允许跨域，否则浏览器可能默认就禁止跨域的 设置方法 internet选项 安全 自定义级别 启用通过跨域访问数据源 启用跨域浏览窗口和框架 确定 然后重启电脑]]></content>
      <tags>
        <tag>IE11</tag>
        <tag>12004</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac版：上传图片到远程图床哪家强？]]></title>
    <url>%2Ftool-upload-img-to-cloud.html</url>
    <content type="text"><![CDATA[markdown写文档虽然如行云流水，但是一旦需要引入图片了。往往需要四五步操作，如果图片仅仅保存在本地，那么复制markdown时，图片路径往往都不对了，还要重新上传一遍图片，很是麻烦。 因此，最好把图片直接上传到图床上，然后通过公网链接来引入图片。图床选择上，我选择七牛云。 我在网上找到了3个不错的工具，在此记录一下。 1. 三个工具分析一览这些工具在上传图片成功后，会把链接保存在剪贴板中，在markdown文件中只需要粘贴一下就可以了。 名称 收费标准 优点 缺点 推荐指数 说明 下载地址 ipic 50元/年 支持很多的云服务，压缩，拖拽上传 死贵, 免费版只能用新浪图床，图片很可能会丢失 A 功能很多，价钱死贵 可通过mac app store 下载 UCQCloud 免费 免费，支持压缩，拖拽上传，截图上传 仅支持七牛，服务器仅支持华东和华北 AAA 免费，功能够用 UCQCloud1.3.3.dmg cuImage 终身1元 剪贴板上传，压缩上传，拖拽上传，快捷键上传，自动把链接转成markdown的形式 仅支持七牛 AAAA cuImage的压缩率要比UCQCloud高很多 可通过mac app store 下载 总体来说：如果你用七牛图床，cuImage是性价比最高, 用户体验最好的 2. 三个工具操作截图与简介3. cuImage 图片上传完成后自动复制URL。 在“上传历史”中查看已上传图片。 批量上传图片。 通过截图或复制上传图片。 通过拖拽上传图片。 通过”服务“菜单上传图片。 通过全局快捷键上传图片。 上传之前压缩图片。 支持BMP/JPEG/PNG/GIF/TIFF等多种文件格式。 只支持七牛云，已兼容七牛云华东、华北、华南及北美的存储区域。 4. UCQCloud1、文件上传(带上传进度) 支持软件面板拖放、选择文件(任意二进制文件)上传 支持状态栏粘贴板图片上传 支持状态栏拖放文件上传2、图片高质量压缩 本地图片上传使用Tinypng在线高质量无损压缩 粘贴板图片上传使用开源库pngquant压缩 正常情况压缩节省50%以上空间,大幅提高博客图片加载速度，节约网盘存储空间。3、上传历史记录管理 文件预览查看，删除，拷贝上传外链地址等 4、支持文件夹批量处理 直接拖入文件夹，或文件批量处理 作者：huluo666链接：https://www.jianshu.com/p/694dad59f20c來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 5. ipic图床神器 iPic 可自动上传图片、保存 Markdown 链接，给你前所未有的插图体验。 上传前压缩图片 通过拖拽上传图片 通过服务上传图片 [Command + U… 6. 参考文献 iPic - 图床神器 Mac七牛图床与文件批量上传工具: UCQCloud1.3.3 cuImage - 图床利器]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 凯文 凯利 《失控》]]></title>
    <url>%2Fbooknote-out-of-control.html</url>
    <content type="text"><![CDATA[失控这本书在刚开始看时，立马让我联想到黑客帝国里人被种植在营养液中的情形，我不太清楚，这本书和这个电影之间有什么联系。 这本书真实能让人脑洞大开。 人造与天生的联姻正是本书的主题 读到这里，我立马有一个预想：多年以后，会有一家公司，把人的思想从肉体从抽取出来。让人的思想，脱离肉体而存在。 蜂群思维 分布式管理 有点像SVN之与GIT 蜂群思维的神奇之处，看似没有一只蜜蜂在控制它。但是有一只看不见的手，在控制着整个群体 低层级的存在无法推断出高层级的复杂性 就像，tcp无法推断出HTTP协议]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>失控</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-大前研一 专业主义]]></title>
    <url>%2Fbooknote-professionalism.html</url>
    <content type="text"><![CDATA[1. 你够专业吗？ p20 控制情绪，理性行动 专业知识，专业技能 客户第一 好奇心 进取心 严格遵守记录]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>未完成</tag>
        <tag>主页主义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue+ElementUI 手把手教你做一个audio组件]]></title>
    <url>%2Fvue-elementui-audio-component.html</url>
    <content type="text"><![CDATA[1. 简介1.1. 相关技术 Vue Vue-cli ElementUI yarn (之前我用npm, 并使用cnpm的源，但是用了yarn之后，我发现它比cnpm的速度还快，功能更好，我就毫不犹豫选择yarn了) Audio相关API和事件 1.2. 从本教程你会学到什么？ Vue单文件组件开发知识 Element UI基本用法 Audio原生API及Audio相关事件 音频播放器的基本原理 音频的播放暂停控制 更新音频显示时间 音频进度条控制与跳转 音频音量控制 音频播放速度控制 音频静音控制 音频下载控制 个性化配置与排他性播放 一点点ES6语法 2. 学前准备基本上不需要什么准备，但是如果你能先看一下Aduio相关API和事件将会更好 Audio: 如果你愿意一层一层剥开我的心 使用 HTML5 音频和视频 3. 在线demon没有在线demo的教程都是耍流氓 查看在线demon 项目地址 4. 开始编码5. 项目初始化12345678910111213141516171819➜ test vue init webpack element-audio A newer version of vue-cli is available. latest: 2.9.2 installed: 2.9.1? Project name element-audio? Project description A Vue.js project? Author wangdd &lt;wangdd@xxxxxx.com&gt;? Vue build standalone? Install vue-router? No? Use ESLint to lint your code? No? Set up unit tests No? Setup e2e tests with Nightwatch? No? Should we run `npm install` for you after the project has been created? (recommended) npm➜ test cd element-audio ➜ element-audio npm run dev 浏览器打开 http://localhost:8080/, 看到如下界面，说明项目初始化成功 5.1. 安装ElementUI并插入audio标签5.1.1. 安装ElementUI1yarn add element-ui // or npm i element-ui -S 5.1.2. 在src/main.js中引入Element UI12345678910111213141516// filename: src/main.jsimport Vue from 'vue'import ElementUI from 'element-ui'import App from './App'import 'element-ui/lib/theme-chalk/index.css'Vue.config.productionTip = falseVue.use(ElementUI)/* eslint-disable no-new */new Vue(&#123; el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 5.1.3. 创建src/components/VueAudio.vue123456789101112131415161718// filename: src/components/VueAudio.vue&lt;template&gt; &lt;div&gt; &lt;audio src="http://devtest.qiniudn.com/secret base~.mp3" controls="controls"&gt;&lt;/audio&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 5.1.4. 修改src/App.vue, 并引入VueAudio.vue组件123456789101112131415161718192021222324// filename: src/App.vue&lt;template&gt; &lt;div id="app"&gt; &lt;VueAudio /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import VueAudio from './components/VueAudio'export default &#123; name: 'app', components: &#123; VueAudio &#125;, data () &#123; return &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 打开：http://localhost:8080/，你应该能看到如下效果，说明引入成功，你可以点击播放按钮看看，音频是否能够播放 5.2. 音频的播放暂停控制我们需要用一个按钮去控制音频的播放与暂停，这里调用了audio的两个api,以及两个事件 audio.play() audio.pause() play事件 pause事件 修改src/components/VueAudio.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// filename: src/components/VueAudio.vue&lt;template&gt; &lt;div&gt; &lt;!-- 此处的ref属性，可以很方便的在vue组件中通过 this.$refs.audio获取该dom元素 --&gt; &lt;audio ref="audio" @pause="onPause" @play="onPlay" src="http://devtest.qiniudn.com/secret base~.mp3" controls="controls"&gt;&lt;/audio&gt; &lt;!-- 音频播放控件 --&gt; &lt;div&gt; &lt;el-button type="text" @click="startPlayOrPause"&gt;&#123;&#123;audio.playing | transPlayPause&#125;&#125;&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; audio: &#123; // 该字段是音频是否处于播放状态的属性 playing: false &#125; &#125; &#125;, methods: &#123; // 控制音频的播放与暂停 startPlayOrPause () &#123; return this.audio.playing ? this.pause() : this.play() &#125;, // 播放音频 play () &#123; this.$refs.audio.play() &#125;, // 暂停音频 pause () &#123; this.$refs.audio.pause() &#125;, // 当音频播放 onPlay () &#123; this.audio.playing = true &#125;, // 当音频暂停 onPause () &#123; this.audio.playing = false &#125; &#125;, filters: &#123; // 使用组件过滤器来动态改变按钮的显示 transPlayPause(value) &#123; return value ? '暂停' : '播放' &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 5.3. 音频显示时间音频的时间显示主要有两部分，音频的总时长和当前播放时间。可以从两个事件中获取 loadedmetadata:代表音频的元数据已经被加载完成，可以从中获取音频总时长 timeupdate: 当前播放位置作为正常播放的一部分而改变，或者以特别有趣的方式，例如不连续地改变，可以从该事件中获取音频的当前播放时间，该事件在播放过程中会不断被触发 要点代码：整数格式化成时:分:秒12345678910111213141516function realFormatSecond(second) &#123; var secondType = typeof second if (secondType === 'number' || secondType === 'string') &#123; second = parseInt(second) var hours = Math.floor(second / 3600) second = second - hours * 3600 var mimute = Math.floor(second / 60) second = second - mimute * 60 return hours + ':' + ('0' + mimute).slice(-2) + ':' + ('0' + second).slice(-2) &#125; else &#123; return '0:00:00' &#125;&#125; 要点代码： 两个事件的处理12345678910111213// 当timeupdate事件大概每秒一次，用来更新音频流的当前播放时间onTimeupdate(res) &#123; console.log('timeupdate') console.log(res) this.audio.currentTime = res.target.currentTime &#125;,// 当加载语音流元数据完成后，会触发该事件的回调函数// 语音元数据主要是语音的长度之类的数据onLoadedmetadata(res) &#123; console.log('loadedmetadata') console.log(res) this.audio.maxTime = parseInt(res.target.duration)&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;template&gt; &lt;div&gt; &lt;!-- 此处的ref属性，可以很方便的在vue组件中通过 this.$refs.audio获取该dom元素 --&gt; &lt;audio ref="audio" @pause="onPause" @play="onPlay" @timeupdate="onTimeupdate" @loadedmetadata="onLoadedmetadata" src="http://devtest.qiniudn.com/secret base~.mp3" controls="controls"&gt;&lt;/audio&gt; &lt;!-- 音频播放控件 --&gt; &lt;div&gt; &lt;el-button type="text" @click="startPlayOrPause"&gt;&#123;&#123;audio.playing | transPlayPause&#125;&#125;&lt;/el-button&gt; &lt;el-tag type="info"&gt;&#123;&#123; audio.currentTime | formatSecond&#125;&#125;&lt;/el-tag&gt; &lt;el-tag type="info"&gt;&#123;&#123; audio.maxTime | formatSecond&#125;&#125;&lt;/el-tag&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 将整数转换成 时：分：秒的格式function realFormatSecond(second) &#123; var secondType = typeof second if (secondType === 'number' || secondType === 'string') &#123; second = parseInt(second) var hours = Math.floor(second / 3600) second = second - hours * 3600 var mimute = Math.floor(second / 60) second = second - mimute * 60 return hours + ':' + ('0' + mimute).slice(-2) + ':' + ('0' + second).slice(-2) &#125; else &#123; return '0:00:00' &#125;&#125;export default &#123; data () &#123; return &#123; audio: &#123; // 该字段是音频是否处于播放状态的属性 playing: false, // 音频当前播放时长 currentTime: 0, // 音频最大播放时长 maxTime: 0 &#125; &#125; &#125;, methods: &#123; // 控制音频的播放与暂停 startPlayOrPause () &#123; return this.audio.playing ? this.pause() : this.play() &#125;, // 播放音频 play () &#123; this.$refs.audio.play() &#125;, // 暂停音频 pause () &#123; this.$refs.audio.pause() &#125;, // 当音频播放 onPlay () &#123; this.audio.playing = true &#125;, // 当音频暂停 onPause () &#123; this.audio.playing = false &#125;, // 当timeupdate事件大概每秒一次，用来更新音频流的当前播放时间 onTimeupdate(res) &#123; console.log('timeupdate') console.log(res) this.audio.currentTime = res.target.currentTime &#125;, // 当加载语音流元数据完成后，会触发该事件的回调函数 // 语音元数据主要是语音的长度之类的数据 onLoadedmetadata(res) &#123; console.log('loadedmetadata') console.log(res) this.audio.maxTime = parseInt(res.target.duration) &#125; &#125;, filters: &#123; // 使用组件过滤器来动态改变按钮的显示 transPlayPause(value) &#123; return value ? '暂停' : '播放' &#125;, // 将整数转化成时分秒 formatSecond(second = 0) &#123; return realFormatSecond(second) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 打开浏览器可以看到，当音频播放时，当前时间也在改变。 5.4. 音频进度条控制进度条主要有两个控制，改变进度的原理是：改变audio.currentTime属性值 音频播放后，当前时间改变，进度条就要随之改变 拖动进度条，可以改变音频的当前时间 1234567891011121314151617181920// 进度条ui&lt;el-slider v-model="sliderTime" :format-tooltip="formatProcessToolTip" @change="changeCurrentTime" class="slider"&gt;&lt;/el-slider&gt;// 拖动进度条，改变当前时间，index是进度条改变时的回调函数的参数0-100之间，需要换算成实际时间changeCurrentTime(index) &#123; this.$refs.audio.currentTime = parseInt(index / 100 * this.audio.maxTime)&#125;,// 当音频当前时间改变后，进度条也要改变onTimeupdate(res) &#123; console.log('timeupdate') console.log(res) this.audio.currentTime = res.target.currentTime this.sliderTime = parseInt(this.audio.currentTime / this.audio.maxTime * 100)&#125;,// 进度条格式化toolTipformatProcessToolTip(index = 0) &#123; index = parseInt(this.audio.maxTime / 100 * index) return '进度条: ' + realFormatSecond(index)&#125;, 5.5. 音频音量控制音频的音量控制和进度控制差不多，也是通过拖动滑动条，去修改aduio.volume属性值，此处不再啰嗦 5.6. 音频播放速度控制音频播放速度控制和进度控制差不多，也是点击按钮，去修改aduio.playbackRate属性值，该属性代表音量的大小，取值范围是0 - 1，用滑动条的时候，也是需要换算一下值，此处不再啰嗦 5.7. 音频静音控制静音的控制是点击按钮，去修改aduio.muted属性，该属性有两个值: true(静音)，false(不静音)。 注意，静音的时候，音频的进度条还是会继续往前走的。 5.8. 音频下载控制音频下载是一个a链接，记得加上download属性，不然浏览器会在新标签打开音频，而不是下载音频1&lt;a :href="url" v-show="!controlList.noDownload" target="_blank" class="download" download&gt;下载&lt;/a&gt; 5.9. 个性化配置音频的个性化配置有很多，大家可以自己扩展，通过父组件传递响应的值，可以做到个性化设置。 1234567891011121314151617181920212223 controlList: &#123; // 不显示下载 noDownload: false, // 不显示静音 noMuted: false, // 不显示音量条 noVolume: false, // 不显示进度条 noProcess: false, // 只能播放一个 onlyOnePlaying: false, // 不要快进按钮 noSpeed: false&#125;setControlList () &#123; let controlList = this.theControlList.split(' ') controlList.forEach((item) =&gt; &#123; if(this.controlList[item] !== undefined)&#123; this.controlList[item] = true &#125; &#125;)&#125;, 例如父组件这样123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div id="app"&gt; &lt;div v-for="item in audios" :key="item.url"&gt; &lt;VueAudio :theUrl="item.url" :theControlList="item.controlList"/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import VueAudio from './components/VueAudio'export default &#123; name: 'app', components: &#123; VueAudio &#125;, data () &#123; return &#123; audios: [ &#123; url: 'http://devtest.qiniudn.com/secret base~.mp3', controlList: 'onlyOnePlaying' &#125;, &#123; url: 'http://devtest.qiniudn.com/回レ！雪月花.mp3', controlList: 'noDownload noMuted onlyOnePlaying' &#125;,&#123; url: 'http://devtest.qiniudn.com/あっちゅ～ま青春!.mp3', controlList: 'noDownload noVolume noMuted onlyOnePlaying' &#125;,&#123; url: 'http://devtest.qiniudn.com/Preparation.mp3', controlList: 'noDownload noSpeed onlyOnePlaying' &#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 5.10. 一点点ES6语法大多数时候，我们希望页面上播放一个音频时，其他音频可以暂停。[...audios]可以把一个类数组转化成数组，这个是我常用的。 12345678910111213141516171819onPlay (res) &#123; console.log(res) this.audio.playing = true this.audio.loading = false if(!this.controlList.onlyOnePlaying)&#123; return &#125; let target = res.target let audios = document.getElementsByTagName('audio'); // 如果设置了排他性，当前音频播放是，其他音频都要暂停 [...audios].forEach((item) =&gt; &#123; if(item !== target)&#123; item.pause() &#125; &#125;)&#125;, 5.11. 完成后的文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244//filename: VueAudio.vue&lt;template&gt; &lt;div class="di main-wrap" v-loading="audio.waiting"&gt; &lt;!-- 这里设置了ref属性后，在vue组件中，就可以用this.$refs.audio来访问该dom元素 --&gt; &lt;audio ref="audio" class="dn" :src="url" :preload="audio.preload" @play="onPlay" @error="onError" @waiting="onWaiting" @pause="onPause" @timeupdate="onTimeupdate" @loadedmetadata="onLoadedmetadata" &gt;&lt;/audio&gt; &lt;div&gt; &lt;el-button type="text" @click="startPlayOrPause"&gt;&#123;&#123;audio.playing | transPlayPause&#125;&#125;&lt;/el-button&gt; &lt;el-button v-show="!controlList.noSpeed" type="text" @click="changeSpeed"&gt;&#123;&#123;audio.speed | transSpeed&#125;&#125;&lt;/el-button&gt; &lt;el-tag type="info"&gt;&#123;&#123; audio.currentTime | formatSecond&#125;&#125;&lt;/el-tag&gt; &lt;el-slider v-show="!controlList.noProcess" v-model="sliderTime" :format-tooltip="formatProcessToolTip" @change="changeCurrentTime" class="slider"&gt;&lt;/el-slider&gt; &lt;el-tag type="info"&gt;&#123;&#123; audio.maxTime | formatSecond &#125;&#125;&lt;/el-tag&gt; &lt;el-button v-show="!controlList.noMuted" type="text" @click="startMutedOrNot"&gt;&#123;&#123;audio.muted | transMutedOrNot&#125;&#125;&lt;/el-button&gt; &lt;el-slider v-show="!controlList.noVolume" v-model="volume" :format-tooltip="formatVolumeToolTip" @change="changeVolume" class="slider"&gt;&lt;/el-slider&gt; &lt;a :href="url" v-show="!controlList.noDownload" target="_blank" class="download" download&gt;下载&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; function realFormatSecond(second) &#123; var secondType = typeof second if (secondType === 'number' || secondType === 'string') &#123; second = parseInt(second) var hours = Math.floor(second / 3600) second = second - hours * 3600 var mimute = Math.floor(second / 60) second = second - mimute * 60 return hours + ':' + ('0' + mimute).slice(-2) + ':' + ('0' + second).slice(-2) &#125; else &#123; return '0:00:00' &#125; &#125; export default &#123; props: &#123; theUrl: &#123; type: String, required: true, &#125;, theSpeeds: &#123; type: Array, default () &#123; return [1, 1.5, 2] &#125; &#125;, theControlList: &#123; type: String, default: '' &#125; &#125;, name: 'VueAudio', data() &#123; return &#123; url: this.theUrl || 'http://devtest.qiniudn.com/secret base~.mp3', audio: &#123; currentTime: 0, maxTime: 0, playing: false, muted: false, speed: 1, waiting: true, preload: 'auto' &#125;, sliderTime: 0, volume: 100, speeds: this.theSpeeds, controlList: &#123; // 不显示下载 noDownload: false, // 不显示静音 noMuted: false, // 不显示音量条 noVolume: false, // 不显示进度条 noProcess: false, // 只能播放一个 onlyOnePlaying: false, // 不要快进按钮 noSpeed: false &#125; &#125; &#125;, methods: &#123; setControlList () &#123; let controlList = this.theControlList.split(' ') controlList.forEach((item) =&gt; &#123; if(this.controlList[item] !== undefined)&#123; this.controlList[item] = true &#125; &#125;) &#125;, changeSpeed() &#123; let index = this.speeds.indexOf(this.audio.speed) + 1 this.audio.speed = this.speeds[index % this.speeds.length] this.$refs.audio.playbackRate = this.audio.speed &#125;, startMutedOrNot() &#123; this.$refs.audio.muted = !this.$refs.audio.muted this.audio.muted = this.$refs.audio.muted &#125;, // 音量条toolTip formatVolumeToolTip(index) &#123; return '音量条: ' + index &#125;, // 进度条toolTip formatProcessToolTip(index = 0) &#123; index = parseInt(this.audio.maxTime / 100 * index) return '进度条: ' + realFormatSecond(index) &#125;, // 音量改变 changeVolume(index = 0) &#123; this.$refs.audio.volume = index / 100 this.volume = index &#125;, // 播放跳转 changeCurrentTime(index) &#123; this.$refs.audio.currentTime = parseInt(index / 100 * this.audio.maxTime) &#125;, startPlayOrPause() &#123; return this.audio.playing ? this.pausePlay() : this.startPlay() &#125;, // 开始播放 startPlay() &#123; this.$refs.audio.play() &#125;, // 暂停 pausePlay() &#123; this.$refs.audio.pause() &#125;, // 当音频暂停 onPause () &#123; this.audio.playing = false &#125;, // 当发生错误, 就出现loading状态 onError () &#123; this.audio.waiting = true &#125;, // 当音频开始等待 onWaiting (res) &#123; console.log(res) &#125;, // 当音频开始播放 onPlay (res) &#123; console.log(res) this.audio.playing = true this.audio.loading = false if(!this.controlList.onlyOnePlaying)&#123; return &#125; let target = res.target let audios = document.getElementsByTagName('audio'); [...audios].forEach((item) =&gt; &#123; if(item !== target)&#123; item.pause() &#125; &#125;) &#125;, // 当timeupdate事件大概每秒一次，用来更新音频流的当前播放时间 onTimeupdate(res) &#123; // console.log('timeupdate') // console.log(res) this.audio.currentTime = res.target.currentTime this.sliderTime = parseInt(this.audio.currentTime / this.audio.maxTime * 100) &#125;, // 当加载语音流元数据完成后，会触发该事件的回调函数 // 语音元数据主要是语音的长度之类的数据 onLoadedmetadata(res) &#123; console.log('loadedmetadata') console.log(res) this.audio.waiting = false this.audio.maxTime = parseInt(res.target.duration) &#125; &#125;, filters: &#123; formatSecond(second = 0) &#123; return realFormatSecond(second) &#125;, transPlayPause(value) &#123; return value ? '暂停' : '播放' &#125;, transMutedOrNot(value) &#123; return value ? '放音' : '静音' &#125;, transSpeed(value) &#123; return '快进: x' + value &#125; &#125;, created() &#123; this.setControlList() &#125; &#125;&lt;/script&gt;&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt; .main-wrap&#123; padding: 10px 15px; &#125; .slider &#123; display: inline-block; width: 100px; position: relative; top: 14px; margin-left: 15px; &#125; .di &#123; display: inline-block; &#125; .download &#123; color: #409EFF; margin-left: 15px; &#125; .dn&#123; display: none; &#125;&lt;/style&gt; 6. 感谢 如果你需要一个小型的vue音乐播放器，你可以试试vue-aplayer, 该播放器不仅仅支持vue组件，非Vue的也支持，你可以看看他们的demo]]></content>
      <tags>
        <tag>audio</tag>
        <tag>vue</tag>
        <tag>ElementUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何从浏览器导出HTTPS证书]]></title>
    <url>%2Fexport-https-certificate-in-browser.html</url>
    <content type="text"><![CDATA[以谷歌浏览器为栗子 1. 打开一个HTTPS网站，例如https://segmentfault.com/2. F12 -&gt; Secutity -&gt; 点击View certificate 3. 详细信息 -&gt; 复制到文件 4. 证书导出向导 这一步要给证书文件起个名字，后缀名就不用了。 然后在你的桌面上就多了一个证书文件。]]></content>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇技淫巧：css实现整个表单只读 form readonly]]></title>
    <url>%2Fcss-form-readonly.html</url>
    <content type="text"><![CDATA[一般的方法往往给表单的各个input、select等加上readonly，但是这个方法有很多缺点。此处就不一一赘述。 我说的方法只需要给表单加上一个类，就可以让表单只读。1&lt;form class="form-readonly"&gt;&lt;/form&gt; 1. 方法1: 用:before给form做个看不见的蒙版，遮住下面所有的元素，使之不响应任何事件123456789101112.form-readonly&#123; position: relative;&#125;.form-readonly:before&#123; content: ""; z-index: 1; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125; 2. 方法2: 用pointer-events:none, 让所有事件穿透form123.form-readonly&#123; pointer-events:none;&#125; 关于pointer-events属性，可以看看这个介绍：https://segmentfault.com/a/1190000011182335]]></content>
      <tags>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JSON.stringify()妙用]]></title>
    <url>%2Fjson-stringify-powerful.html</url>
    <content type="text"><![CDATA[1. 语法1JSON.stringify(value[, replacer[, space]]) 一般用法：12345var user = &#123;name: 'andy', isDead: false, age: 11, addr: 'shanghai'&#125;;JSON.stringify(user);"&#123;"name":"andy","isDead":false,"age":11,"addr":"shanghai"&#125;" 2. 扩展用法2.1. replacerreplacer可以是函数或者是数组。 功能1: 改变属性值将isDead属性的值翻译成0或1，0对应false,1对应true12345678910var user = &#123;name: 'andy', isDead: false, age: 11, addr: 'shanghai'&#125;;JSON.stringify(user, function(key, value)&#123; if(key === 'isDead')&#123; return value === true ? 1 : 0; &#125; return value;&#125;);"&#123;"name":"andy","isDead":0,"age":11,"addr":"shanghai"&#125;" 功能2：删除某个属性将isDead属性删除，如果replacer的返回值是undefined,那么该属性会被删除。12345678910var user = &#123;name: 'andy', isDead: false, age: 11, addr: 'shanghai'&#125;;JSON.stringify(user, function(key, value)&#123; if(key === 'isDead')&#123; return undefined; &#125; return value;&#125;);"&#123;"name":"andy","age":11,"addr":"shanghai"&#125;" 功能3: 通过数组过滤某些属性只需要name属性和addr属性，其他不要。 12345var user = &#123;name: 'andy', isDead: false, age: 11, addr: 'shanghai'&#125;;JSON.stringify(user, ['name', 'addr']);"&#123;"name":"andy","addr":"shanghai"&#125;" 2.2. spacespace可以是数字或者是字符串, 如果是数字则表示属性名前加上空格符号的数量，如果是字符串，则直接在属性名前加上该字符串。 功能1: 给输出属性前加上n个空格12345678910var user = &#123;name: 'andy', isDead: false, age: 11, addr: 'shanghai'&#125;;JSON.stringify(user, null, 4);"&#123; "name": "andy", "isDead": false, "age": 11, "addr": "shanghai"&#125;" 功能2: tab格式化输出123456789var user = &#123;name: 'andy', isDead: false, age: 11, addr: 'shanghai'&#125;;JSON.stringify(user, null, '\t');"&#123; "name": "andy", "isDead": false, "age": 11, "addr": "shanghai"&#125;" 功能3： 搞笑1234567JSON.stringify(user, null, 'good');"&#123;good"name": "andy",good"isDead": false,good"age": 11,good"addr": "shanghai"&#125;" 2.3. 深拷贝1234var user = &#123;name: 'andy', isDead: false, age: 11, addr: 'shanghai'&#125;;var temp = JSON.stringify(user);var user2 = JSON.parse(temp); 3. 其他JSON.parse() 其实也是支持第二个参数的。功能类似于JSON.stringify的第二个参数的功能。 4. 参考 MDN JSON.stringify()]]></content>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写可配置的express & nodejs的代理]]></title>
    <url>%2Fwrite-configurable-nodejs-http-proxy.html</url>
    <content type="text"><![CDATA[注意：该文章中设置代理的方法存在很大的问题，请不要在使用。这里只作为记录。非常推荐你使用http-proxy-middleware，作为生产环境代理的包。你可以看我的这篇文章，里面有一个非常小巧的写法，可以实现各种代理的方法，Express 代理中间件的写法关于该文章中设置代理会产生的问题，在这篇文章中我会做详细的说明, TCP链接高Recv-Q的原因以及解决方法 nodejs比较好的代理包有：node-http-proxy和http-proxy-middleware。这两个我都用过，它们的优点自不用说，只说说缺点：它们不能从配置文件里读取代理配置。每添加一个拦截路径都需要多加一个接口调用。 所以，我需要自己写一个http代理，要包含一下功能： 从配置文件里读取代理配置 可以路径重写 这样做的好处是：新增服务只需要在配置文件上加上该服务，无需修改业务逻辑 1. /config/default.js123456789101112131415161718192021222324252627module.exports = &#123; "ENV":"dev", "PORT":"8088", "maxAge": 10, "proxy":&#123; "olap":&#123; "host":"172.16.200.225", "port":"8092", "form":"", "to":"" &#125;, "qc":&#123; "host":"192.168.40.231", "port":"30088" &#125;, "api":&#123; "host":"192.168.40.231", "port":"30412" &#125;, "ocm":&#123; "host": process.env.ocm_host || "192.168.40.119", "port": process.env.ocm_port || "31003" &#125; &#125;&#125; 2. /app.js将所有要走代理的路径前必需加上 /p, 这个是我的个人配置，当然也可以是其他的名字。 12345678910111213var express = require('express');var compression = require('compression');var path = require('path');var config = require('config');var log4js = require('log4js');var wsProxyConfig = config.get('proxy');var routes = require('./routes/index');var views = require('./routes/views');var proxy = require('./routes/proxy');app.use('/p',proxy); 3. /routes/proxy.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394var express = require('express');// config是一个第三方包，它的功能是// 自动根据环境变量帮你读取config目录下// 的配置文件，默认会读取default.json，// config支持很多文件类型。var config = require('config');var request = require('request');var log4js = require('log4js');var path = require('path');var router = express.Router();// 此处就是获取配置文件的proxy项了var proxyConfig = config.get('proxy');// 这里记录代理的日志log4js.configure(&#123; appenders: [ &#123; type: 'file', filename: './logs/all-proxy-logs.log', maxLogSize: 10*1024*1024, //max 10mb backups: 5, compress: true &#125;, &#123; type: 'stdout' &#125; ]&#125;);var logger = log4js.getLogger('proxy');router.all('/:apiName/*', function(req, res, next) &#123; // apiName 必需要对应配置文件的proxy的属性名 var apiName = req.params.apiName; if(!apiName)&#123; res.status(404).end('api not found'); &#125; // 如果apiName不在配置文件里，则报500 else if(!proxyConfig[apiName])&#123; res.status(500).end('api has no config'); &#125; else&#123; // originUrl是原始的url // 例如 /p/qc/calls var originalUrl = req.originalUrl; var api = proxyConfig[apiName]; var url = originalUrl.replace('/p',''); url = `http://$&#123;api.host&#125;:$&#123;api.port&#125;` + url; // 某些需要路径重写的地方 if(api.form &amp;&amp; api.to)&#123; url = url.replace(api.form, api.to); &#125; // 必须要删除这个host // 因为本地测试时，这个host是localhost // 这会导致服务端报错 delete req.headers.host; // 修改好的请求头 var option = &#123; url: url, headers: req.headers &#125;; // 使用request发起请求 var proxy = request(option); // 此处是关键，将请求流写入代理，将代理的响应写入原始响应 req.pipe(proxy); proxy.pipe(res); // 代理结束响应时，原始请求结束，并输出日志 proxy.on('end', function()&#123; var log = `$&#123;req.method&#125; $&#123;res.statusCode&#125; $&#123;req.originalUrl&#125; ---&gt; $&#123;option.url&#125; $&#123;req.headers.sessionid&#125;`; if(res.statusCode &lt; 400)&#123; logger.info(log); &#125; else&#123; logger.error(log); &#125; res.end(); &#125;); &#125;&#125;);module.exports = router; 4. 相关第三方模块 node-config request log4js-node]]></content>
      <tags>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac-sublime-shortcut-collector]]></title>
    <url>%2Fmac-sublime-shortcut-collector.html</url>
    <content type="text"><![CDATA[1. 对应关系 标志 键名 ⌘ command ⇧ shift ↩ 回车 ↑ 上 ↓ 下 ⌃ control ⌥ option 红色标记的是常用的快捷键。 2. 编辑 按键 功能 ⌘ + X 剪切当前行 ⌥ + 拖动鼠标 垂直选中 ⌘ + ↩ 在当前行之后换行，无论鼠标在哪里 ⌘ + ⇧ + ↩ 再当前行之前换行，无论鼠标在哪里 ⌘ + ⌃ + ↑ 向上移动整行或者整段 ⌘ + ⌃ + ↓ 向下移动正行或者整段 ⌘ + L 选择正行，重复按会向下再选择整行 ⌘ + D 选中单词，重复按会向下选择相同的单词 ⌃ + ⌘ + G 选中所有你选中的单词，比如先选中name这儿单词，然后按下这个快捷键，则当前文件里所有的name都会被选中 ⌃ + ⇧ + ↑ Extra cursor on the line above ⌃ + ⇧ + ↓ Extra cursor on the line below ⌃ + M 跳到回应圆括号或大括号的结尾 ⌃ + ⇧ + M 跳到回应圆括号或大括号的结尾，并选中这些内容 ⌃ + A 跳到一行的最左边，光标右边有可能不是字母 ⌘ + Left 调到一行文本的左边，光标右边一定跟着字母 ⌃ + E, ⌘ + Right 调到一行的最右边 ⌘ + K, ⌘ + K 删除光标所在行 ⌘ + K + ⌫ 删除光标所在位置到一行开头 ⌘ + ] 缩进当前行或者段落 ⌘ + [ 取消缩进当前行或者段落 ⌘ + ⇧ + D 复制当前行 ⌘ + J 使当前行和当前行的下一行合并成一行 ⌘ + / 注释或者取消注释当前行 ⌘ + ⌥ + / Block comment current selection ⌘ + Y 重复上一个快捷键 ⌘ + ⇧ + V 粘贴并自动缩进 ⌃ + Space Select next auto-complete suggestion ⌃ + U Soft undo; jumps to your last change before undoing change when repeated ⌃ + ⇧ + Up Column selection up ⌃ + ⇧ + Down Column selection down ⌃ + ⇧ + W Wrap Selection in html tag ⌃ + ⇧ + K Delete current line of cursor 3. 导航 按键 功能 ⌘ + P or ⌘ + T 按照文件名打开文件 ⌘ + R Goto symbol ⌃ + G 跳到制定行 4. 通用 按键 功能 ⌘ + ⇧ + P Command Palette ⌃ + ` Python Console ⌃ + ⌘ + F Toggle fullscreen mode ⌃ + ⇧ + ⌘ + F Toggle distraction-free mode ⌘ + K, ⌘ + B Toggle side bar ⌃ + ⇧ + P Show scope in status bar 5. 查找／替换 按键 功能 ⌘ + F 查找 ⌘ + ⌥ + F 替换 ⌘ + ⇧ + F 在文件中查找 6. 滚动 按键 功能 ⌃ + V 向下滚动一页 ⌃ + L 使当前行处于显示器的中央 ⌘ + Down 滚动到文件结尾 ⌘ + Up 滚动到文件开始 7. 标签页 按键 功能 ⌘ + ⇧ + t 打开最近关闭的标签页 ⌘ + [NUM] 调到制定标签页 1-9 ⌘ + 0 调到第10个标签页 ⌘ + ⇧ + [ 切换成左边的标签页 ⌘ + ⇧ + ] 切换成右边的标签页 ^ + Tab 顺序跳转到最近使用的标签页 ⇧ + ^ + Tab 逆序跳转最近使用的标签页 8. 窗口分割 按键 功能 ⌘ + ⌥ + 1 切换成单窗口 ⌘ + ⌥ + 2 切换窗口成2栏 ⌘ + ⌥ + 3 切换窗口成3栏 ⌘ + ⌥ + 4 切换窗口成4栏 ⌘ + ⌥ + 5 Set view to grid (4 groups) ⌃ + [NUM] Jump to group where num is 1-4 ⌃ + ⇧ + [NUM] Move file to specified group where num is 1-4 9. 书签 按键 功能 ⌘ + F2 设置或取消设置书签 F2 调到下一个书签 ⇧ + F2 跳到上一个书签 ⇧ + ⌘ + F2 清空所有书签 10. 文本管理 按键 功能 ⌘ + K, ⌘ + U 转成大写 ⌘ + K, ⌘ + L 转成小写 ⌘ + ⌃ + up, ⌘ + ⌃ + down Clip text upwards / downwards 11. 常用插件快捷键 插件名 按键 功能 omniMarkupPreview ⌘ + ⌥ + o 预览markdown viewInBrowse ⌃ + ⌥ + c 在谷歌浏览器中预览html 12. 参考 Keyboard Shortcuts - OSX]]></content>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECharts 轮流高亮中国地图各个省份]]></title>
    <url>%2Fecharts-highlight-china-map.html</url>
    <content type="text"><![CDATA[最早我是想通过dispatchAction方法去改变选中的省份，但是没有起作用，如果你知道这个方法怎么实现，麻烦你可以告诉我。我实现的方法是另外一种。 1234567891011dispatchAction(&#123; type: 'geoSelect', // 可选，系列 index，可以是一个数组指定多个系列 seriesIndex?: number|Array, // 可选，系列名称，可以是一个数组指定多个系列 seriesName?: string|Array, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 dataIndex?: number, // 可选，数据名称，在有 dataIndex 的时候忽略 name?: string&#125;) 后来我改变了一个方法。这个方法的核心思路是定时获取图标的配置，然后更新配置，最后在设置配置。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var myChart = echarts.init(document.getElementById('china-map'));var COLORS = ["#070093", "#1c3fbf", "#1482e5", "#70b4eb", "#b4e0f3", "#ffffff"];// 指定图表的配置项和数据var option = &#123; tooltip: &#123; trigger: 'item', formatter: '&#123;b&#125;' &#125;, series: [ &#123; name: '中国', type: 'map', mapType: 'china', selectedMode : 'single', label: &#123; normal: &#123; show: true &#125;, emphasis: &#123; show: true &#125; &#125;, data:[ // 默认高亮安徽省 &#123;name:'安徽', selected:true&#125; ], itemStyle: &#123; normal: &#123; areaColor: 'rgba(255,255,255,0.5)', color: '#000000', shadowBlur: 200, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125;, emphasis:&#123; areaColor: '#3be2fb', color: '#000000', shadowBlur: 200, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125; &#125; &#125; ]&#125;;// 使用刚指定的配置项和数据显示图表。myChart.setOption(option);myChart.on('click', function(params) &#123; console.log(params);&#125;);setInterval(function()&#123; var op = myChart.getOption(); var data = op.series[0].data; var length = data.length; data.some(function(item, index)&#123; if(item.selected)&#123; item.selected = false; var next = (index + 1)%length; data[next].selected = true; return true; &#125; &#125;); myChart.setOption(op);&#125;, 3000); 1. 后续补充我从这里发现：https://github.com/ecomfe/echarts/issues/3282，选中地图的写法是这样的，而试了一下果然可以。主要是type要是`mapSelect`,而不是`geoSelect`1234567891011myChart.dispatchAction(&#123; type: 'mapSelect', // 可选，系列 index，可以是一个数组指定多个系列 // seriesIndex: 0, // 可选，系列名称，可以是一个数组指定多个系列 // seriesName: string|Array, // 数据的 index，如果不指定也可以通过 name 属性根据名称指定数据 // dataIndex: number, // 可选，数据名称，在有 dataIndex 的时候忽略 name: '河北'&#125;);]]></content>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3笔记 列表方法详解]]></title>
    <url>%2Fpython3-list-methods-collect.html</url>
    <content type="text"><![CDATA[1. 使用[]或者list()创建列表12user = []user = list() 2. 使用list()可以将其他类型转换成列表1234567# 将字符串转成列表&gt;&gt;&gt; list('abcde')['a', 'b', 'c', 'd', 'e']# 将元祖转成列表&gt;&gt;&gt; list(('a','b','c'))['a', 'b', 'c'] 3. 使用[offset]获取元素 或 修改元素1234567891011121314151617181920212223&gt;&gt;&gt; users = ['a','b','c','d','e']# 可以使用整数来获取某个元素&gt;&gt;&gt; users[0]'a'# 可以使用负整数来表示从尾部获取某个元素&gt;&gt;&gt; users[-1]'e'# 数组越界会报错&gt;&gt;&gt; users[100]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range&gt;&gt;&gt; users[-100]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range# 修改某个元素&gt;&gt;&gt; users[0] = 'wdd'&gt;&gt;&gt; users['wdd', 'b', 'c', 'd', 'e']&gt;&gt;&gt; 4. 列表切片与提取元素列表的切片或者提取之后仍然是一个列表形式如：list[start:end:step]1234567891011121314151617181920212223242526&gt;&gt;&gt; users['wdd', 'b', 'c', 'd', 'e']# 正常截取 注意这里并不会截取到users[2]&gt;&gt;&gt; users[0:2]['wdd', 'b']# 也可从尾部截取&gt;&gt;&gt; users[0:-2]['wdd', 'b', 'c']# 这样可以获取所有的元素&gt;&gt;&gt; users[:]['wdd', 'b', 'c', 'd', 'e']# 也可以加上步长参数&gt;&gt;&gt; users[0:4:2]['wdd', 'c']# 也可以通过这种方式去将列表取反&gt;&gt;&gt; users[::-1]['e', 'd', 'c', 'b', 'wdd']# 注意切片时，偏移量可以越界，越界之后不会报错，仍然按照界限来处理 例如开始偏移量如果小于0，那么仍然会按照0去计算。&gt;&gt;&gt; users['wdd', 'b', 'c', 'd', 'e']&gt;&gt;&gt; users[-100:3]['wdd', 'b', 'c']&gt;&gt;&gt; users[-100:100]['wdd', 'b', 'c', 'd', 'e']&gt;&gt;&gt; 5. 使用append()添加元素至尾部形式如：list.append(item)12345&gt;&gt;&gt; users['wdd', 'b', 'c', 'd', 'e']&gt;&gt;&gt; users.append('ddw')&gt;&gt;&gt; users['wdd', 'b', 'c', 'd', 'e', 'ddw'] 6. 使用extend()或+=合并列表形式如：list1.extend(list2)这两个方法都会直接修改原列表12345678910&gt;&gt;&gt; users['wdd', 'b', 'c', 'd', 'e', 'ddw']&gt;&gt;&gt; names['heihei', 'haha']&gt;&gt;&gt; users.extend(names)&gt;&gt;&gt; users['wdd', 'b', 'c', 'd', 'e', 'ddw', 'heihei', 'haha']&gt;&gt;&gt; users += names&gt;&gt;&gt; users['wdd', 'b', 'c', 'd', 'e', 'ddw', 'heihei', 'haha', 'heihei', 'haha'] 7. 使用insert()在指定位置插入元素形式如：list.insert(offset, item)insert也不存在越界的问题，偏移量正负都行，越界之后会自动伸缩到界限之内，并不会报错12345678910111213141516&gt;&gt;&gt; users['wdd', 'b', 'c', 'd', 'e', 'ddw', 'heihei', 'haha', 'heihei', 'haha']&gt;&gt;&gt; users.insert(0,'xiaoxiao')&gt;&gt;&gt; users['xiaoxiao', 'wdd', 'b', 'c', 'd', 'e', 'ddw', 'heihei', 'haha', 'heihei', 'haha']&gt;&gt;&gt; users.insert(-1,'-xiaoxiao')&gt;&gt;&gt; users['xiaoxiao', 'wdd', 'b', 'c', 'd', 'e', 'ddw', 'heihei', 'haha', 'heihei', '-xiaoxiao', 'haha']# 下面-100肯定越界了&gt;&gt;&gt; users.insert(-100,'-xiaoxiao')&gt;&gt;&gt; users['-xiaoxiao', 'xiaoxiao', 'wdd', 'b', 'c', 'd', 'e', 'ddw', 'heihei', 'haha', 'heihei', '-xiaoxiao', 'haha']# 下面100也是越界了&gt;&gt;&gt; users.insert(100,'-xiaoxiao')&gt;&gt;&gt; users['-xiaoxiao', 'xiaoxiao', 'wdd', 'b', 'c', 'd', 'e', 'ddw', 'heihei', 'haha', 'heihei', '-xiaoxiao', 'haha', '-xiaoxiao'] 8. 使用del删除某个元素形式如：del list[offset]del是python的语句，而不是列表的方法，del删除不存在的元素时，也会提示越界12345678910111213&gt;&gt;&gt; users['-xiaoxiao', 'xiaoxiao', 'wdd', 'b', 'c', 'd', 'e', 'ddw', 'heihei', 'haha', 'heihei', '-xiaoxiao', 'haha', '-xiaoxiao']&gt;&gt;&gt; del users[0]&gt;&gt;&gt; users['xiaoxiao', 'wdd', 'b', 'c', 'd', 'e', 'ddw', 'heihei', 'haha', 'heihei', '-xiaoxiao', 'haha', '-xiaoxiao']&gt;&gt;&gt; del users[100]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list assignment index out of range&gt;&gt;&gt; del users[-100]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list assignment index out of range 9. 使用remove删除具有指定值的元素形式如：list.remove(value)123456789101112131415&gt;&gt;&gt; users['xiaoxiao', 'wdd', 'b', 'c', 'd', 'e', 'ddw', 'heihei', 'haha', 'heihei', '-xiaoxiao', 'haha', '-xiaoxiao']# 删除指定值'c'&gt;&gt;&gt; users.remove('c')&gt;&gt;&gt; users['xiaoxiao', 'wdd', 'b', 'd', 'e', 'ddw', 'heihei', 'haha', 'heihei', '-xiaoxiao', 'haha', '-xiaoxiao']# 删除不存在的值会报错&gt;&gt;&gt; users.remove('alsdkfjalsdf')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list# 如果该值存在多个，那么只能删除到第一个&gt;&gt;&gt; users.remove('haha')&gt;&gt;&gt; users['xiaoxiao', 'wdd', 'b', 'd', 'e', 'ddw', 'heihei', 'heihei', '-xiaoxiao', 'haha', '-xiaoxiao'] 10. 使用pop()方式返回某个元素后，并在数组里删除它形式如：list.pop(offset=-1) 偏移量默认等于-1，也就是删除最后的元素123456789101112131415161718192021&gt;&gt;&gt; users['xiaoxiao', 'wdd', 'b', 'd', 'e', 'ddw', 'heihei', 'heihei', '-xiaoxiao', 'haha', '-xiaoxiao']# 删除最后的元素&gt;&gt;&gt; users.pop()'-xiaoxiao'&gt;&gt;&gt; users['xiaoxiao', 'wdd', 'b', 'd', 'e', 'ddw', 'heihei', 'heihei', '-xiaoxiao', 'haha']# 如果列表本身就是空的，那么pop时会报错&gt;&gt;&gt; user.pop(0)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: pop from empty list&gt;&gt;&gt; users.pop(0)'xiaoxiao'&gt;&gt;&gt; users['wdd', 'b', 'd', 'e', 'ddw', 'heihei', 'heihei', '-xiaoxiao', 'haha']# 越界时也会报错&gt;&gt;&gt; users.pop(100)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: pop index out of range 11. 使用index()查询具有特定值的元素位置形式如：list.index(value)1234567891011# index只会返回第一遇到该值得位置&gt;&gt;&gt; users['wdd', 'b', 'd', 'e', 'ddw', 'heihei', 'heihei', '-xiaoxiao', 'haha']&gt;&gt;&gt; users.index('heihei')5# 如果该值不存在，也会报错&gt;&gt;&gt; users.index('laksdf')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: 'laksdf' is not in list 12. 使用in判断值是否存在列表形式如：value in list1234&gt;&gt;&gt; users['wdd', 'b', 'd', 'e', 'ddw', 'heihei', 'heihei', '-xiaoxiao', 'haha']&gt;&gt;&gt; 'wdd' in usersTrue 13. 使用count()记录特定值出现的次数形式如：list.count(value)123456&gt;&gt;&gt; users['wdd', 'b', 'd', 'e', 'ddw', 'heihei', 'heihei', '-xiaoxiao', 'haha']&gt;&gt;&gt; users.count('heihei')2&gt;&gt;&gt; users.count('h')0 14. 使用join()将列表转为字符串形式如：string.join(list)12345678&gt;&gt;&gt; users['wdd', 'b', 'd', 'e', 'ddw', 'heihei', 'heihei', '-xiaoxiao', 'haha']&gt;&gt;&gt; ','.join(users)'wdd,b,d,e,ddw,heihei,heihei,-xiaoxiao,haha'&gt;&gt;&gt; user[]&gt;&gt;&gt; ','.join(user)'' 15. 使用sort()重新排列列表元素形式如：list.sort()123456789101112131415161718192021&gt;&gt;&gt; users['wdd', 'b', 'd', 'e', 'ddw', 'heihei', 'heihei', '-xiaoxiao', 'haha']# 默认是升序排序&gt;&gt;&gt; users.sort()&gt;&gt;&gt; users['-xiaoxiao', 'b', 'd', 'ddw', 'e', 'haha', 'heihei', 'heihei', 'wdd']# 加入reverse=True, 可以降序排序&gt;&gt;&gt; users.sort(reverse=True)&gt;&gt;&gt; users['wdd', 'heihei', 'heihei', 'haha', 'e', 'ddw', 'd', 'b', '-xiaoxiao']# 通过匿名函数，传入函数进行自定义排序&gt;&gt;&gt; students[&#123;'name': 'wdd', 'age': 343&#125;, &#123;'name': 'ddw', 'age': 43&#125;, &#123;'name': 'jik', 'age': 90&#125;]&gt;&gt;&gt; students.sort(key=lambda item: item['age'])&gt;&gt;&gt; students[&#123;'name': 'ddw', 'age': 43&#125;, &#123;'name': 'jik', 'age': 90&#125;, &#123;'name': 'wdd', 'age': 343&#125;]&gt;&gt;&gt; students.sort(key=lambda item: item['age'], reverse=True)&gt;&gt;&gt; students[&#123;'name': 'wdd', 'age': 343&#125;, &#123;'name': 'jik', 'age': 90&#125;, &#123;'name': 'ddw', 'age': 43&#125;]&gt;&gt;&gt; 16. 使用reverse()将列表翻转形式如：list.reverse()12345&gt;&gt;&gt; users['wdd', 'heihei', 'heihei', 'haha', 'e', 'ddw', 'd', 'b', '-xiaoxiao']&gt;&gt;&gt; users.reverse()&gt;&gt;&gt; users['-xiaoxiao', 'b', 'd', 'ddw', 'e', 'haha', 'heihei', 'heihei', 'wdd'] 17. 使用copy()复制列表形式如：list2 = list1.copy()list2 = list1 这种并不是列表的复制，只是给列表起了别名。实际上还是指向同一个值。123456&gt;&gt;&gt; users['-xiaoxiao', 'b', 'd', 'ddw', 'e', 'haha', 'heihei', 'heihei', 'wdd']&gt;&gt;&gt; users2 = users.copy()&gt;&gt;&gt; users2['-xiaoxiao', 'b', 'd', 'ddw', 'e', 'haha', 'heihei', 'heihei', 'wdd']&gt;&gt;&gt; 18. 使用clear()清空列表形式如： list.clear()12345&gt;&gt;&gt; users2['-xiaoxiao', 'b', 'd', 'ddw', 'e', 'haha', 'heihei', 'heihei', 'wdd']&gt;&gt;&gt; users2.clear()&gt;&gt;&gt; users2[] 19. 使用len()获取列表长度形式如：len(list)1234&gt;&gt;&gt; users['-xiaoxiao', 'b', 'd', 'ddw', 'e', 'haha', 'heihei', 'heihei', 'wdd']&gt;&gt;&gt; len(users)9 20. 关于列表越界的深入思考写了这些方法后，我有一些疑问，为什么有些操作会提示越界，有些则不会呢？ 会提示偏移量越界的操作有 list[offset] 读取或者修改某个元素 del list[offset] 删除指定位置的元素 list.remove(value) 删除指定值的元素 list.pop(offset) 删除指定位置的元素 如果偏移量越界，这些方法会报错的。我的个人理解是:假如我想读取偏移量为10的元素，但是该元素并不存在，如果系统自动给你读取了列表的最后一个元素，而且不报错，这是无法容忍的bug。 如果我想删除第10个元素，但是第10个元素并不存在，而系统帮你删除了列表的最后一个元素，我觉得这也是无法容忍的。 所以在使用这些方法时，务必确认该偏移量的元素是否存，否则可能会报错。]]></content>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我苦苦寻找诡异的bug原因，其实是我的无知]]></title>
    <url>%2Freal-reason-of-my-bugs.html</url>
    <content type="text"><![CDATA[1. 问题1：chosen插件无法显示图标问题现象在我本地调试的时候，我使用了一个多选下拉框的插件，就是chosen, 不知道为什么，这个多选框上面的图标不见了。我找了半天没有找到原因，然后我把我的机器的内网地址给我同事，让他访问我机器，当它访问到这个页面时。他的电脑上居然显示出了这个下拉框的图标。 这是什么鬼？, 为什么同样的代码，在我的电脑上显示不出图标，但是在他的电脑上可以显示。有句名言说的好：没有什么bug是一遍调试解决不了的，如果有，就再仔细调试一遍。于是我就再次调试一遍。 我发现了一些第一遍没有注意到的东西媒体查询，就是在css里有这样的语句：1@media 从这里作为切入口，我发现：媒体查询的类会覆盖它原生的类的属性 由于我的电脑视网膜屏幕，分辨率比较高，触发了媒体查询，这就导致了媒体查询的类覆盖了原生的类。而覆盖后的类，使用了chosen-sprite@2x.png作为图标的背景图片。但是这个图片并没有被放在这个插件的目录下，有的只有chosen-sprite.png这个图片。在一般情况下，都是用chosen-sprite.png作为背景图片的。这就解释了：为什么同事的电脑上出现了图标，但是我的电脑上没有出现这个图标。 总结: 如果你要使用一个插件，你最好把这个插件的所有文件都放在同一个目录下。而不要只放一些你认为有用的文件。最后：媒体查询的相关知识也是必要的。 2. 问题2：jQuery 与 Vue之间的暧昧jQuery流派代表着直接操纵DOM的流派，Vue流派代表着操纵数据的流派。 如果在项目里，你使用了一些jQuery插件，也使用了Vue，这就可能导致一些问题。 举个例子： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/vue/2.4.4/vue.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; 姓名 &lt;input type="text" v-model="userName"&gt; &lt;br/&gt; 年龄 &lt;input type="text" id="userAge" v-model="userAge"&gt; &lt;br/&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;new Vue(&#123; el: '#app', data: &#123; userName: '', userAge: 12 &#125;&#125;);$('#userAge').val(14);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在页面刚打开时：姓名输入框是空的，年龄输入框是14。但是一旦你在姓名输入框输入任何字符时，年龄输入框的值就会变成12。 如果你仔细看过Vue官方文档，你会很容易定位问题所在。 1v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值。因为它会选择 Vue 实例数据来作为具体的值。你应该通过 JavaScript 在组件的 data 选项中声明初始值。---Vue官方文档 你可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。 当userAge被jQuery改成14时，Vue实例中的userAge任然是12。当你输入userName时，Vue发现数据改变，触发虚拟DOM的重新渲染，同时也将userAge渲染成了12。 总结：如果你在Vue项目中逼不得已使用jQuery, 你要知道这会导致哪些常见的问题，以及解决思路。 3. 最后我苦苦寻找诡异的bug原因，其实是我的无知。]]></content>
      <tags>
        <tag>思想者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 初始化软件安装及服务管理]]></title>
    <url>%2Fcentos7-init-install-packages.html</url>
    <content type="text"><![CDATA[因为阿里云最近搞活动，所以买了一台阿里云香港的一台最低配置主机。用来搞搞开发，做静态页面，给女朋友发短信，爬爬页面，翻墙等等。 1. 软件安装1.1. 安装git1234yum install git//检查git是否安装成功git --version 1.2. 安装oh-my-zsh12345678// 检查有没有安装zsh, 没有安装的话，先安装zshcat /etc/shells// 没有安装zsh,先安装zshyum install zsh// 然后安装oh-my-zshsh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 1.3. 安装ss基于python2.7 参考文献 123456789101112131415161718192021222324252627// 安装setuptools pipyum install python-setuptools &amp;&amp; easy_install pip// 安装shadowsockspip install shadowsocks// 新建/etc/shadowsocks.json 文件&#123; "server":"0.0.0.0", "server_port":your-server_port, "local_address":"127.0.0.1", "local_port":1080, "password":"your-password", "timeout":300, "method":"aes-256-cfb", "fast_open":false, "workers":5&#125;// 服务启动ssserver -c /etc/shadowsocks.json -d start// 服务停止ssserver -d stop// 查看服务状态netstat -tunlp 1.4. 安装nodejs123456789yum install epel-releaseyum install nodejs// 如果出现 CentOS 7 使用 npm 失败 npm: symbol SSL_set_cert_cbyum -y install yum-utilsyum-config-manager --enable cr &amp;&amp; yum update// 安装cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org 1.5. 安装nginx参考123456789// 直接通过 yum install nginx 肯定是不行的,因为yum没有nginx，所以首先把 nginx 的源加入 yum 中。// 将nginx放到yum repro库中rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm// 查看nginx信息yum info nginx// 安装nginxyum install nginx 2. 安装python3123yum install epel-releaseyum install python34python3 --version 3. 服务管理 功能 命令 使服务开启启动 systemctl enable httpd.service 关闭服务开机启动 systemctl disabled httpd.service 检查服务状态 systemctl status httpd.service 查看所有已启动的服务 systemctl list-units –type=service 启动服务 systemctl start httpd.service 停止服务 systemctl stop httpd.service 重启服务 systemctl restart httpd.service]]></content>
      <tags>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行命令搭建简易静态文件http服务器]]></title>
    <url>%2Fone-command-create-static-file-server.html</url>
    <content type="text"><![CDATA[简易服务器：在命令执行的所在路径启动一个http服务器，然后你可以通过浏览器访问该路径下的所有文件。 在局域网内传文件，或者自己测试使用都是非常方便的。 1. 基于python 1.1. 基于Python2python -m SimpleHTTPServer port 123&gt; python -m SimpleHTTPServer 8099Serving HTTP on 0.0.0.0 port 8099 ...127.0.0.1 - - [24/Oct/2017 11:07:56] "GET / HTTP/1.1" 200 - 1.2. 基于python3python3 -m http.server port 12345&gt; python3 -m http.server 8099Serving HTTP on 0.0.0.0 port 8099 (http://0.0.0.0:8099/) ...127.0.0.1 - - [24/Oct/2017 11:05:06] "GET / HTTP/1.1" 200 -127.0.0.1 - - [24/Oct/2017 11:05:06] code 404, message File not found127.0.0.1 - - [24/Oct/2017 11:05:06] "GET /favicon.ico HTTP/1.1" 404 - 2. 基于nodejs首先你要安装nodejs 2.1. http-server12345// 安装npm install http-server -g// 用法http-server [path] [options] 2.2. serve12345// 安装npm install -g serve// 用法serve [options] &lt;path&gt; 2.3. webpack-dev-server12345// 安装npm install webpack-dev-server -g// 用法webpack-dev-server 2.4. anywhere123456// 安装npm install -g anywhere// 用法anywhereanywhere -p port 2.5. puer 123456789101112// 安装npm -g install puer// 使用puer- 提供一个当前或指定路径的静态服务器- 所有浏览器的实时刷新：编辑css实时更新(update)页面样式，其它文件则重载(reload)页面- 提供简单熟悉的mock请求的配置功能，并且配置也是自动更新。- 可用作代理服务器，调试开发既有服务器的页面，可与mock功能配合使用- 集成了weinre，并提供二维码地址，方便移动端的调试- 可以作为connect中间件使用(前提是后端为nodejs，否则请使用代理模式)]]></content>
      <tags>
        <tag>静态文件服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[top-javascript-tools-in-2017]]></title>
    <url>%2Ftop-javascript-tools-in-2017.html</url>
    <content type="text"><![CDATA[原文地址git地址 1. 基础工具 accounting.js async axios chance date-fns format.js immutable is.js lodash Math.js Moment.js Numeral.js string.js underscore.js voca wait xregexp.com 2. 编译 / 类型检查 Babel TypeScript Flow 3. 代码分析引擎 Tern 4. JavaScript兼容性检查器 jscc.info/ 5. Linting/ Hinting &amp; Style Linter eslint 6. 单元测试 AVA Jasmine Mocha Tape 7. 单元测试断言库 Chai expect.js should.js 8. 单元测试数据模拟 sinon.js Kakapo.js mockjs 9. E2E测试 puppeteer 10. 代码格式化 / 整洁 esformatter js-beautify jsfmt prettier 11. 性能测试 benchmark.js jsperf.co 12. 可视化，静态分析，复杂性，覆盖工具 Coveralls Esprima istanbul 13. 优化 UglifyJS 2 optimize-js 14. 混淆 Javascript Obfuscator JScrambler 15. 可共享/可运行的代码编辑器 es6fiddle.net jsbin.com jsfiddle.net 16. 在线正则表达式编辑器/可视化工具 debuggex regex101 regexper RegExr 17. 创作公约工具 Airbnb’s ESLint config, following our styleguide Standard - ESLint Shareable Config 18. json可视化 jsonviewernew 19. 代码可视化 lambda-view 20. 静态文件服务器 http-server serve anywhere puer]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webrtc-tutorial-simple-video-chat]]></title>
    <url>%2Fwebrtc-tutorial-simple-video-chat.html</url>
    <content type="text"><![CDATA[本例子是参考webrtc-tutorial-simple-video-chat做的。这个教程应该主要是去宣传ScaleDrone的sdk, 他们的服务是收费的，但是免费的也可以用，就是有些次数限制。 本栗子的地址本栗子的pages地址 1. 准备 使用最新版谷歌浏览器（62版） 视频聊天中 一个是windows, 一个是mac stun服务器使用谷歌的，trun使用ScaleDrone的sdk，这样我就不用管服务端了。 2. 先上效果图 3. 再上在线例子点击此处4. 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// 产生随机数if (!location.hash) &#123; location.hash = Math.floor(Math.random() * 0xFFFFFF).toString(16);&#125;// 获取房间号var roomHash = location.hash.substring(1);// 放置你自己的频道id, 这是我注册了ScaleDrone 官网后，创建的channel// 你也可以自己创建var drone = new ScaleDrone('87fYv4ncOoa0Cjne');// 房间名必须以 'observable-'开头var roomName = 'observable-' + roomHash;var configuration = &#123; iceServers: [&#123; urls: 'stun:stun.l.google.com:19302' // 使用谷歌的stun服务 &#125;]&#125;;var room;var pc;function onSuccess() &#123;&#125;function onError(error) &#123; console.error(error);&#125;drone.on('open', function(error)&#123; if (error) &#123; return console.error(error);&#125; room = drone.subscribe(roomName); room.on('open', function(error)&#123; if (error) &#123;onError(error);&#125; &#125;); // 已经链接到房间后，就会收到一个 members 数组，代表房间里的成员 // 这时候信令服务已经就绪 room.on('members', function(members)&#123; console.log('MEMBERS', members); // 如果你是第二个链接到房间的人，就会创建offer var isOfferer = members.length === 2; startWebRTC(isOfferer); &#125;);&#125;);// 通过Scaledrone发送信令消息function sendMessage(message) &#123; drone.publish(&#123; room: roomName, message &#125;);&#125;function startWebRTC(isOfferer) &#123; pc = new RTCPeerConnection(configuration); // 当本地ICE Agent需要通过信号服务器发送信息到其他端时 // 会触发icecandidate事件回调 pc.onicecandidate = function(event)&#123; if (event.candidate) &#123; sendMessage(&#123; 'candidate': event.candidate &#125;); &#125; &#125;; // 如果用户是第二个进入的人，就在negotiationneeded 事件后创建sdp if (isOfferer) &#123; // onnegotiationneeded 在要求sesssion协商时发生 pc.onnegotiationneeded = function() &#123; // 创建本地sdp描述 SDP (Session Description Protocol) session描述协议 pc.createOffer().then(localDescCreated).catch(onError); &#125;; &#125; // 当远程数据流到达时，将数据流装载到video中 pc.onaddstream = function(event)&#123; remoteVideo.srcObject = event.stream; &#125;; // 获取本地媒体流 navigator.mediaDevices.getUserMedia(&#123; audio: true, video: true, &#125;).then( function(stream) &#123; // 将本地捕获的视频流装载到本地video中 localVideo.srcObject = stream; // 将本地流加入RTCPeerConnection 实例中 发送到其他端 pc.addStream(stream); &#125;, onError); // 从Scaledrone监听信令数据 room.on('data', function(message, client)&#123; // 消息是我自己发送的，则不处理 if (client.id === drone.clientId) &#123; return; &#125; if (message.sdp) &#123; // 设置远程sdp, 在offer 或者 answer后 pc.setRemoteDescription(new RTCSessionDescription(message.sdp), function()&#123; // 当收到offer 后就接听 if (pc.remoteDescription.type === 'offer') &#123; pc.createAnswer().then(localDescCreated).catch(onError); &#125; &#125;, onError); &#125; else if (message.candidate) &#123; // 增加新的 ICE canidatet 到本地的链接中 pc.addIceCandidate( new RTCIceCandidate(message.candidate), onSuccess, onError ); &#125; &#125;);&#125;function localDescCreated(desc) &#123; pc.setLocalDescription(desc, function()&#123; sendMessage(&#123; 'sdp': pc.localDescription &#125;); &#125;,onError);&#125; 5. WebRTC简介5.1. 介绍WebRTC 是一个开源项目，用于Web浏览器之间进行实时音频视频通讯，数据传递。WebRTC有几个JavaScript APIS。 点击链接去查看demo。 getUserMedia(): 捕获音频视频 MediaRecorder: 记录音频视频 RTCPeerConnection: 在用户之间传递音频流和视频流 RTCDataChannel: 在用户之间传递文件流 5.2. 在哪里使用WebRTC? Chrome FireFox Opera Android iOS 5.3. 什么是信令WebRTC使用RTCPeerConnection在浏览器之间传递流数据, 但是也需要一种机制去协调收发控制信息，这就是信令。信令的方法和协议并不是在WebRTC中明文规定的。 在codelad中用的是Node，也有许多其他的方法。 5.4. 什么是STUN和TURN和ICE? STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。该协议由RFC 5389定义。 wikipedia STUN TURN（全名Traversal Using Relay NAT, NAT中继穿透），是一种资料传输协议（data-transfer protocol）。允许在TCP或UDP的连线上跨越NAT或防火墙。TURN是一个client-server协议。TURN的NAT穿透方法与STUN类似，都是通过取得应用层中的公有地址达到NAT穿透。但实现TURN client的终端必须在通讯开始前与TURN server进行交互，并要求TURN server产生”relay port”，也就是relayed-transport-address。这时TURN server会建立peer，即远端端点（remote endpoints），开始进行中继（relay）的动作，TURN client利用relay port将资料传送至peer，再由peer转传到另一方的TURN client。wikipedia TURN ICE （Interactive Connectivity Establishment，互动式连接建立 ），一种综合性的NAT穿越的技术。互动式连接建立是由IETF的MMUSIC工作组开发出来的一种framework，可整合各种NAT穿透技术，如STUN、TURN（Traversal Using Relay NAT，中继NAT实现的穿透）、RSIP（Realm Specific IP，特定域IP）等。该framework可以让SIP的客户端利用各种NAT穿透方式打穿远程的防火墙。[wikipedia ICE] WebRTC被设计用于点对点之间工作，因此用户可以通过最直接的途径连接。然而，WebRTC的构建是为了应付现实中的网络: 客户端应用程序需要穿越NAT网关和防火墙，并且对等网络需要在直接连接失败的情况下进行回调。 作为这个过程的一部分，WebRTC api使用STUN服务器来获取计算机的IP地址，并将服务器作为中继服务器运行，以防止对等通信失败。(现实世界中的WebRTC更详细地解释了这一点。) 5.5. WebRTC是否安全?WebRTC组件是强制要求加密的，并且它的JavaScript APIS只能在安全的域下使用(HTTPS 或者 localhost)。信令机制并没有被WebRTC标准定义，所以是否使用安全的协议就取决于你自己了。 6. WebRTC 参考资料 官网教程 WebRTC 简单的视频聊天 repo WebRTC 教程 MDN WebRTC API 谷歌codelab WebRT教程 github上WebRTC各种例子 segemntfault上关于WebRTC的教程]]></content>
      <tags>
        <tag>webrtc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写好技术文档?]]></title>
    <url>%2Fhow-to-write-a-technical-document.html</url>
    <content type="text"><![CDATA[本文来自于公司内部的一个分享。在文档方面，对内的一些接口文档主要是用swagger来写的。虽然可以在线测试，比较方便。但是也存在着一些更新不及时，swgger文档无法导出成文件的问题。在对外提供的文档方面：我主要负责做一个浏览器端的一个js sdk。文档还算可以github地址，所以想把一些写文档的心得分享给大家。 1. 衡量好文档的唯一标准是什么？ Martin(Bob大叔)曾在《代码整洁之道》一书打趣地说：当你的代码在做 Code Review 时，审查者要是愤怒地吼道： 12“What the fuck is this shit?”“Dude, What the fuck！” 等言辞激烈的词语时，那说明你写的代码是 Bad Code，如果审查者只是漫不经心的吐出几个 “What the fuck?”， 那说明你写的是 Good Code。衡量代码质量的唯一标准就是每分钟骂出“WTF” 的频率。 衡量文档的标准也是如此。 2. 好文档的特点 简洁：一句话可以说完的事情，就不要分两句话来说。并不是文档越厚越好，太厚的文档大多没人看。 准确: 字段类型，默认值，备注，是否必填等属性说明。 逻辑性: 文档如何划分？ 利于查看。 demo胜千言: 好的demo胜过各种字段说明，可以复制下来直接使用。 读者心: 从读者的角度考虑, 方法尽量简洁。可以传递一个参数搞定的事情，绝对不要让用户去传两个参数。 及时更新: 不更新的文档比bug更严重。 向后兼容: 不要随意废弃已有的接口或者某个字段，除非你考虑到这样做的后果。 建立文档词汇表：每个概念只有一个名字，不要随意起名字，名不正则言不顺。 格式统一：例如时间格式。我曾见过2017-09-12 09:32:23, 或2017.09.12 09:32:23或2017.09.12 09:32:23。变量名user_name, userName。 使用专业词语：不要过于口语化 3. 总结: 写出好文档要有以下四点 逻辑性：便于查找 专业性: 值得信赖，质量保证 责任心：及时更新，准确性，向后兼容 读者心：你了解的东西，别人可能并不清楚。从读者的角度去考虑，他们需要什么，而不是一味去强调你能提供什么。 4. 写文档的工具 markdown: 方便快捷，可以导出各种格式的文件 swagger: 功能强大，需要部署，不方便传递文件 5. markdown 工具推荐 蚂蚁笔记 这是我正使用的。 全平台（mac windows ios）有客户端，和浏览器端 笔记可以直接公布为博客 支持独立域名 标签很好用 支持思维导图 支持历史记录 cmd-markdown 有道云笔记 6. 文档之外公司有个同事，我曾问他使用什么搜索一些技术文档，他说用百度。作为一个翻墙老司机，我惊诧的问他：你为什么不用谷歌去搜索。他说他不会翻墙。我只能呵呵一笑。 自从有一次搜索：graph for x^8 + y^8，我就决定不再使用百度了。你可以看一下两者的返回结果有什么不同。 总之：有些鸟儿是关不住的 他们的羽毛太鲜亮了。]]></content>
      <tags>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue + Vue-router + Element-ui 搭建一个非常简单的dashboard demo]]></title>
    <url>%2Fvue-vue-router-elementui-stupid-simple-dashboard.html</url>
    <content type="text"><![CDATA[之前我很少做过组件化的相关demo, 虽然学习了webpack, 但是还是很少使用。工作中用到最多的是jQuery, 还有Vue。但是我只是把Vue看成一个小工具来用，并没有使用组件化或者单文件组件的东西。闲暇时间看看《行尸走肉 第六季》，瑞克一伙人在亚历山大社区中感悟：把自己围在围墙中，虽然舒适，但是并不安全。保持在舒适区只有悲惨的命运。就像前端，外面的世界蓬勃发展，各种技术霸占山头。其实并不需要畏惧新技术，就像WEKING DEAD是很可怕，但是只要你拿起斧头，砍中他们的头颅，一样可以掌控他们。 做完这个demo后，我体会到，Vue组件化，webpack, Vue-router等，并不是很难学习，你需要的只是拿起斧头的勇气 在做demo的过程中，我遇到一个问题，就是vue-router懒加载一直实现不了，纠结了半天。后来回到原点，去vue-route官网看文档，发现是因为syntax-dynamic-import插件没有安装。 所以说：你以为的bug, 实际上是你没看透文档 初次学习这个教程，你不需要有任何担忧某些东西不会，你也不需要写任何代码。因为基本上所有代码都是从element官网上拷贝的，你所做的只是把他们组装在一起罢了。 在线预览仓库地址：https://github.com/wangduanduan/vue-el-dashboard 效果图：使用到的技术： Vue Vue-router Element-ui webpack Normalize.css vue-awesome babel 1. vue-cli 安装模板123456789101112131415161718192021➜ vue-el-dashboard git:(master) vue init webpack? Generate project in current directory? Yes? Project name vue-el-dashboard? Project description A Vue.js project? Author wangdd &lt;wangdd@welljoint.com&gt;? Vue build standalone? Install vue-router? Yes? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests No? Setup e2e tests with Nightwatch? No vue-cli · Generated "vue-el-dashboard". To get started: npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack 2. 安装依赖并运行1234➜ vue-el-dashboard git:(master) ✗ cnpm i✔ Installed 44 packages✔ Linked 680 latest versions➜ npm run dev 浏览器打开如下页面: 3. 安装初始化页面布局安装并使用Element UI 1cnpm i element-ui -S 修改 /src/main.js 为：12345678910111213141516import Vue from 'vue'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import App from './App'Vue.config.productionTip = falseVue.use(ElementUI)/* eslint-disable no-new */new Vue(&#123; el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 我需要的布局是这种： 在 Element 上复制对应的代码,并粘贴到 /src/App.vue文件中：12345678910111213141516171819202122232425&lt;template&gt; &lt;div id="app"&gt; &lt;el-container&gt; &lt;el-header&gt;Header&lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside width="200px"&gt;Aside&lt;/el-aside&gt; &lt;el-main&gt;Main&lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app'&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 不出意外的话，你可以在浏览器上看到如下布局： 现在，布局就这么成了。 4. 安装侧边菜单栏我需要侧边栏是下图右边的自定义颜色的那种菜单 在components文件夹下新建NavMenu.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;template&gt; &lt;el-row class="tac"&gt; &lt;el-col :span="12"&gt; &lt;h5&gt;默认颜色&lt;/h5&gt; &lt;el-menu default-active="2" class="el-menu-vertical-demo" @open="handleOpen" @close="handleClose"&gt; &lt;el-submenu index="1"&gt; &lt;template slot="title"&gt; &lt;i class="el-icon-location"&gt;&lt;/i&gt; &lt;span&gt;导航一&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;template slot="title"&gt;分组一&lt;/template&gt; &lt;el-menu-item index="1-1"&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index="1-2"&gt;选项2&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-menu-item-group title="分组2"&gt; &lt;el-menu-item index="1-3"&gt;选项3&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-submenu index="1-4"&gt; &lt;template slot="title"&gt;选项4&lt;/template&gt; &lt;el-menu-item index="1-4-1"&gt;选项1&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;el-menu-item index="2"&gt; &lt;i class="el-icon-menu"&gt;&lt;/i&gt; &lt;span slot="title"&gt;导航二&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="3"&gt; &lt;i class="el-icon-setting"&gt;&lt;/i&gt; &lt;span slot="title"&gt;导航三&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/el-col&gt; &lt;el-col :span="12"&gt; &lt;h5&gt;自定义颜色&lt;/h5&gt; &lt;el-menu default-active="2" class="el-menu-vertical-demo" @open="handleOpen" @close="handleClose" background-color="#545c64" text-color="#fff" active-text-color="#ffd04b"&gt; &lt;el-submenu index="1"&gt; &lt;template slot="title"&gt; &lt;i class="el-icon-location"&gt;&lt;/i&gt; &lt;span&gt;导航一&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;template slot="title"&gt;分组一&lt;/template&gt; &lt;el-menu-item index="1-1"&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index="1-2"&gt;选项2&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-menu-item-group title="分组2"&gt; &lt;el-menu-item index="1-3"&gt;选项3&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-submenu index="1-4"&gt; &lt;template slot="title"&gt;选项4&lt;/template&gt; &lt;el-menu-item index="1-4-1"&gt;选项1&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;el-menu-item index="2"&gt; &lt;i class="el-icon-menu"&gt;&lt;/i&gt; &lt;span slot="title"&gt;导航二&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="3"&gt; &lt;i class="el-icon-setting"&gt;&lt;/i&gt; &lt;span slot="title"&gt;导航三&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; handleOpen(key, keyPath) &#123; console.log(key, keyPath); &#125;, handleClose(key, keyPath) &#123; console.log(key, keyPath); &#125; &#125; &#125;&lt;/script&gt; 然后将NavMenu组件导入到App.vue中, 修改App.vue：12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div id="app"&gt; &lt;el-container&gt; &lt;el-header&gt;Header&lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside width="200px"&gt; &lt;navmenu&gt;&lt;/navmenu&gt; &lt;/el-aside&gt; &lt;el-main&gt;Main&lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import NavMenu from '@/components/NavMenu'export default &#123; name: 'app', components: &#123; 'navmenu': NavMenu &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 这里要解释一下这条语句, 该语句中的@, 符号是什么意思？1import NavMenu from '@/components/NavMenu' 在build/webpack.base.conf.js中有如下代码, alias就是起别名，@符号就是代表src路径， 所以@/components/NavMenu就是src/components/NavMenu。 这样webpack就知道如何引入文件了。这样做的好处是不必到处去写src了。1234567resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), &#125;&#125;, 现在打开浏览器，应该可以看到如下界面： 可以看到菜单已经引入进来了，但是是两个菜单，下面我们需要修改一下，只要右边的菜单，并删除一些多余的元素。修改NavMenu.vue文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;el-row class="tac"&gt; &lt;el-col :span="24"&gt; &lt;el-menu default-active="2" class="el-menu-vertical-demo" @open="handleOpen" @close="handleClose" unique-opened router background-color="#545c64" text-color="#fff" active-text-color="#ffd04b"&gt; &lt;el-submenu index="1"&gt; &lt;template slot="title"&gt; &lt;i class="el-icon-location"&gt;&lt;/i&gt; &lt;span&gt;导航一&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index="1-1"&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index="1-2"&gt;选项2&lt;/el-menu-item&gt; &lt;el-menu-item index="1-3"&gt;选项3&lt;/el-menu-item&gt; &lt;el-menu-item index="1-4"&gt;选项4&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index="2"&gt; &lt;template slot="title"&gt; &lt;i class="el-icon-location"&gt;&lt;/i&gt; &lt;span&gt;导航二&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index="2-1"&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index="2-2"&gt;选项2&lt;/el-menu-item&gt; &lt;el-menu-item index="2-3"&gt;选项3&lt;/el-menu-item&gt; &lt;el-menu-item index="2-4"&gt;选项4&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; handleOpen(key, keyPath) &#123; console.log(key, keyPath) &#125;, handleClose(key, keyPath) &#123; console.log(key, keyPath) &#125; &#125; &#125;&lt;/script&gt; 现在打开浏览器看看： 点击展开菜单看看： 5. 侧边菜单栏进阶我们需要的功能： 每次只能展开一个一级菜单 每次点击一个二级菜单可以自动改变路由，跳转到对应的组件 由于菜单在路由中也会使用，所以最好抽象出来，做成一个配置文件 第1点和第二点比较好搞，Element上已经有配置文档: unique-opened: 是否只保持一个子菜单的展开 router: 是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转 修改NavMenu.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;el-row class="tac"&gt; &lt;el-col :span="24"&gt; &lt;el-menu default-active="2" class="el-menu-vertical-demo" @open="handleOpen" @close="handleClose" unique-opened router background-color="#545c64" text-color="#fff" active-text-color="#ffd04b"&gt; &lt;el-submenu index="1"&gt; &lt;template slot="title"&gt; &lt;i class="el-icon-location"&gt;&lt;/i&gt; &lt;span&gt;导航一&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index="1-1"&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index="1-2"&gt;选项2&lt;/el-menu-item&gt; &lt;el-menu-item index="1-3"&gt;选项3&lt;/el-menu-item&gt; &lt;el-menu-item index="1-4"&gt;选项4&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;el-submenu index="2"&gt; &lt;template slot="title"&gt; &lt;i class="el-icon-location"&gt;&lt;/i&gt; &lt;span&gt;导航二&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index="2-1"&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index="2-2"&gt;选项2&lt;/el-menu-item&gt; &lt;el-menu-item index="2-3"&gt;选项3&lt;/el-menu-item&gt; &lt;el-menu-item index="2-4"&gt;选项4&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; handleOpen (key, keyPath) &#123; console.log(key, keyPath) &#125;, handleClose (key, keyPath) &#123; console.log(key, keyPath) &#125; &#125; &#125;&lt;/script&gt; 打开浏览器，点击一个二级菜单看看，你会发现，效果并不像预期那样，而且控制台还向你扔出一个bug： 添加一个暂时的路由: 修改main.js123456789101112131415161718import Vue from 'vue'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import App from './App'import router from './router'Vue.config.productionTip = falseVue.use(ElementUI)/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 打开浏览器，点击一个二级菜单，这时候没有报错，浏览器的路径也变了, 变成http://localhost:8080/#/1-3 每次增加一个菜单都要写点html是不能忍的，能用js的，就别用html。 在src目录下创建一个config目录，目录下创建一个menu-config.js 文件：外层的数组代表一级菜单，内层sub数组代表二级菜单。 123456789101112131415161718192021module.exports = [&#123; name: '基础', id: 'basic', sub: [&#123; name: 'Layout 布局', componentName: 'BasicLayout' &#125;, &#123; name: 'Container 布局容器', componentName: 'BasicContainer' &#125;]&#125;, &#123; name: 'Form', id: 'form', sub: [&#123; name: 'Radio 单选框', componentName: 'FormRadio' &#125;, &#123; name: 'Checkbox 多选框', componentName: 'FormCheckbox' &#125;]&#125;] 在NavMenu.vue中引入这个文件，并使用v-for循环去渲染这个菜单：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;el-row class="tac"&gt; &lt;el-col :span="24"&gt; &lt;el-menu class="el-menu-vertical-demo" router unique-opened @open="handleOpen" @close="handleClose" background-color="#545c64" text-color="#fff" active-text-color="#ffd04b"&gt; &lt;el-submenu v-for="item in menu" :index="item.id" :key="item.id"&gt; &lt;template slot="title"&gt; &lt;span v-text="item.name"&gt;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group class="over-hide" v-for="sub in item.sub" :key="sub.componentName"&gt; &lt;el-menu-item :index="sub.componentName" v-text="sub.name"&gt; &lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-col&gt;&lt;/el-row&gt;&lt;/template&gt;&lt;style scoped&gt; .over-hide&#123; overflow: hidden; &#125;&lt;/style&gt;&lt;script&gt; import menu from '@/config/menu-config' export default &#123; data () &#123; return &#123; menu: menu &#125; &#125;, methods: &#123; handleOpen (key, keyPath) &#123; console.log(key, keyPath) &#125;, handleClose (key, keyPath) &#123; console.log(key, keyPath) &#125; &#125; &#125;&lt;/script&gt; 这里要说明一下，我给二级菜单加上了over-hide类，二级菜单在展开时，有点溢出父元素了。打开浏览器看看, 这时候菜单已经是根据配置文件渲染的了。 6. 先加个头部吧，秃顶太丑了在componets文件夹下创建一个Header.vue, 并在App.vue中引入， Header.vue12345678910111213&lt;template&gt; &lt;el-row&gt; &lt;el-col :span="24" &lt;div class="head-wrap"&gt;Element&lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/template&gt;&lt;style scoped&gt;.head-wrap&#123;&#125;&lt;/style&gt; App.vue12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div id="app"&gt; &lt;el-container&gt; &lt;el-header class="header"&gt; &lt;vheader /&gt; &lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside width="200px"&gt; &lt;navmenu&gt;&lt;/navmenu&gt; &lt;/el-aside&gt; &lt;el-main&gt;Main &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import NavMenu from '@/components/NavMenu'import Header from '@/components/Header'export default &#123; name: 'app', components: &#123; 'navmenu': NavMenu, 'vheader': Header &#125;&#125;&lt;/script&gt;&lt;style&gt;.header &#123; background-color: #409EFF; color: #fff; line-height: 60px;&#125;&lt;/style&gt; 这时候打开浏览器看看, 是不是已经好看一点了。但是body有边框，不好看啊！ 再次美化 使用css reset Normalize.css 使用font-awesome vue-awesome图标库 安装Normalize.css, vue-awesome 12cnpm i normalize.css -Dcnpm i vue-awesome -D 这里主要贴一下main.js的改动，其他的代码就不贴了： 12345678910111213141516171819202122import Vue from 'vue'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import NormailizeCss from 'normalize.css'import 'vue-awesome/icons'import Icon from 'vue-awesome/components/Icon'import App from './App'import router from './router'Vue.config.productionTip = falseVue.use(ElementUI)Vue.component('icon', Icon)/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 看下效果, 图标什么的都有了。 7. 组件路由与懒加载在components新增四个文件： BasicContainer.vue12345&lt;template&gt; &lt;div&gt; 这是：Container 布局容器 &lt;/div&gt;&lt;/template&gt; BasicLayout.vue12345&lt;template&gt; &lt;div&gt; 这是：Layout 布局 &lt;/div&gt;&lt;/template&gt; FormCheckbox.vue12345&lt;template&gt; &lt;div&gt; 这是：Checkbox 多选框 &lt;/div&gt;&lt;/template&gt; FormRadio.vue12345&lt;template&gt; &lt;div&gt; 这是：Radio 单选框 &lt;/div&gt;&lt;/template&gt; 修改route/index.js文件, 关于路由和懒加载就不在此赘述，任何文档都没有官方文档说的好。 注意：如果您使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 可以正确地解析语法。也就是说，你要先安装syntax-dynamic-import, 不然懒加载根本不行。1cnpm install --save-dev babel-plugin-syntax-dynamic-import 12345678910111213141516171819import Vue from 'vue'import Router from 'vue-router'import menus from '@/config/menu-config'Vue.use(Router)var routes = []menus.forEach((item) =&gt; &#123; item.sub.forEach((sub) =&gt; &#123; routes.push(&#123; path: `/$&#123;sub.componentName&#125;`, name: sub.componentName, component: () =&gt; import(`@/components/$&#123;sub.componentName&#125;`) &#125;) &#125;)&#125;)export default new Router(&#123; routes &#125;) 另外App.vue文件需要加上 router-view123&lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/el-main&gt; 看看效果：点击菜单，路径跳转，并且每次都是单独去加载路由的文件。 8. github 部署如果你想在github上部署，那么你要修改config/index.js的以下代码, 不然有些文件因为路径问题可能会找不到。 12345678build: &#123; // Template for index.html index: path.resolve(__dirname, '../docs/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../docs'), assetsSubDirectory: 'static', assetsPublicPath: '/vue-el-dashboard/',]]></content>
      <tags>
        <tag>ElementUI</tag>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios进阶：用最优雅的方式写ajax请求]]></title>
    <url>%2Faxios-best-practices.html</url>
    <content type="text"><![CDATA[可以用配置解决的问题，请勿硬编码姊妹篇 jQuery进阶：用最优雅的方式写ajax请求或许你也可以试试：xfire: 简单优雅、高度可配置的fetch接口批量生成工具 axios是Vue官方推荐的ajax库, 用来取代vue-resource。 优点： 增加一个ajax接口，只需要在配置文件里多写几行就可以 不需要在组件中写axios调用，直接调用api方法，很方便 如果接口有调整，只需要修改一下接口配置文件就可以 统一管理接口配置 1. content-type配置12345// filename: content-type.jsmodule.exports = &#123; formData: 'application/x-www-form-urlencoded; charset=UTF-8', json: 'application/json; charset=UTF-8'&#125; 2. api 配置1234567891011121314151617// filename: api-sdk-conf.jsimport contentType from './content-type'export default &#123; baseURL: 'http://192.168.40.231:30412', apis: [ &#123; name: 'login', path: '/api/security/login?&#123;&#123;id&#125;&#125;', method: 'post', contentType: contentType.formData, status: &#123; 401: '用户名或者密码错误' &#125; &#125; ]&#125; 3. request.js 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// request.jsimport axios from 'axios'import qs from 'qs'import contentType from '@/config/content-type'import apiConf from '@/config/api-sdk-conf'var api = &#123;&#125;// render 函数用来渲染路径上的变量, 算是一个微型的模板渲染工具// 例如render('/&#123;&#123;userId&#125;&#125;/&#123;&#123;type&#125;&#125;/&#123;&#123;query&#125;&#125;', &#123;userId:1,type:2, query:3&#125;)// 会被渲染成 /1/2/3function render (tpl, data) &#123; var re = /&#123;&#123;([^&#125;]+)?&#125;&#125;/ var match = '' while ((match = re.exec(tpl))) &#123; tpl = tpl.replace(match[0], data[match[1]]) &#125; return tpl&#125;// fire中的this, 会动态绑定到每个接口上function fire (query = &#123;&#125;, payload = '') &#123; // qs 特别处理 formData类型的数据 if (this.contentType === contentType.formData) &#123; payload = qs.stringify(payload) &#125; // 直接返回axios实例，方便调用then,或者catch方法 return axios(&#123; method: this.method, url: render(this.url, query), data: payload, headers: &#123; contentType: this.contentType &#125; &#125;)&#125;apiConf.apis.forEach((item) =&gt; &#123; api[item.name] = &#123; url: apiConf.baseURL + item.path, method: item.method, status: item.status, contentType: item.contentType, fire: fire &#125;&#125;)export default api 4. 在组件中使用12345678import api from '@/apis/request'... api.login.fire(&#123;id: '?heiheihei'&#125;, &#123; username: 'admin', password: 'admin', namespace: '_system' &#125;)... 浏览器结果：1234567891011121314151617181920Request URL:http://192.168.40.231:30412/api/security/login??heiheiheiRequest Method:POSTStatus Code:200 OKRemote Address:192.168.40.231:30412Referrer Policy:no-referrer-when-downgradePOST /api/security/login??heiheihei HTTP/1.1Host: 192.168.40.231:30412Connection: keep-aliveContent-Length: 47Accept: application/json, text/plain, */*Origin: http://localhost:8080contentType: application/x-www-form-urlencoded; charset=UTF-8User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36Content-Type: application/x-www-form-urlencodedReferer: http://localhost:8080/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8username=admin&amp;password=admin&amp;namespace=_system 5. 更多有个地方我不是很明白，希望懂的人可以给我解答一下 如果某个组件中只需要login方法，但是我这样写会报错。1import &#123;login&#125; from '@/apis/request' 这样写的前提是要在request.js最后写上1export var login = api.login 但是这是我不想要的，因为每次增加一个接口，这里都要export一次， 这不符合开放闭合原则，请问有什么更好的方法吗？]]></content>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记 node最佳实践1 项目工程最佳实践]]></title>
    <url>%2Fnodejs-project-best-struct.html</url>
    <content type="text"><![CDATA[原文阅读: nodebestpractices 1. 工程结构最佳实践1.1. 组件化 bad: 按照功能划分 controllers api.js home.js order.js product.js user.js models order.js product.js user.js test testOrder.js testProduct.js testUser.js good：按照组件划分 order product user index.js user.js userApi.js userError.js userTesting.js userAction.js 1.2. 层次化 不要在express中写太多业务逻辑，express专注web层 业务层要单独抽出 数据库层单独抽出 1.3. NPM化 把常用组件做成NPM包 1.4. 分离Express的 app 和 server 1.5. 配置化 环境感知： 根据不同环境使用不同配置]]></content>
  </entry>
  <entry>
    <title><![CDATA[grep awk 搜索日志常用命令]]></title>
    <url>%2Fgrep-awk-search-log.html</url>
    <content type="text"><![CDATA[1. grep 常用参数参考： GNU Grep 3.0123456789101112131415161718--color:高亮显示匹配到的字符串-v：显示不能被pattern匹配到的-i：忽略字符大小写-o：仅显示匹配到的字符串-q：静默模式，不输出任何信息-A#：after，匹配到的后#行-B#：before，匹配到的前#行-C#：context，匹配到的前后各#行-E：使用ERE，支持使用扩展的正则表达式－c：只输出匹配行的计数。－I：不区分大 小写(只适用于单字符)。－h：查询多文件时不显示文件名。－l：查询多文件时只输出包含匹配字符的文件名。－n：显示匹配行及 行号。- m: 匹配多少个关键词之后就停止搜索－s：不显示不存在或无匹配文本的错误信息。－v：显示不包含匹配文本的所有行。 2. 普通：搜索trace.log 中含有ERROR字段的日志grep ERROR trace.log 3. 输出文件：可以将日志输出文件中grep ERROR trace.log &gt; error.log 4. 反向：搜索不包含ERROR字段的日志grep -v ERROR trace.log 5. 向前：搜索包含ERROR,并且显示ERROR前10行的日志grep -B 10 ERROR trace.log 6. 向后：搜索包含ERROR字段，并且显示ERROR后10行的日志grep -A 10 ERROR trace.log 7. 上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志grep -C 10 ERROR trace.log 8. 多字段：搜索包含ERROR和DEBUG字段的日志gerp -E &#39;ERROR|DEBUG&#39; trace.log 9. 多文件：从多个.log文件中搜索含有ERROR的日志grep ERROR *.log 10. 省略文件名：从多个.log文件中搜索ERROR字段日志，并不显示日志文件名从多个文件中搜索的日志默认每行会带有日志文件名 grep -h ERROR *.log 11. 时间范围： 按照时间范围搜索日志awk &#39;$2&gt;&quot;17:30:00&quot; &amp;&amp; $2&lt;&quot;18:00:00&quot;&#39; trace.log日志形式如下, $2代表第二列即11:44:58, awk需要指定列111-21 16:44:58 /user/info/ 12. 有没有：搜索到第一个匹配行后就停止搜索grep -m 1 ERROR trace.log]]></content>
      <tags>
        <tag>grep</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的谷歌浏览器插件集（15个）]]></title>
    <url>%2Fmy-chrome-extensions-collection.html</url>
    <content type="text"><![CDATA[1. 广告拦截：AdBlock 2. 获取网页样式：CSS Peeper 3. 扩展管理：扩展管理器（Extension Manager） 4. json格式化：JSON-handle 5. 多点高亮查找：Multi-highlight 6. github源码阅读：Octotree 7. http接口调试：Postman 8. 脚本增强：Tampermonkey 9. 脚本注入：Script Injector 10. 键步如飞：Vimium 11. Vue开发利器：Vue.js devtools 12. 前端资讯：掘金 13. 让不支持markdown的富文本编辑器支持markdown: Markdown Here 14. 多标签页时，自动释放内存，开100个标签页也毫无压力：The Great Suspender 15. 接口测试：Restlet Client - REST API Testingrestlet Client和post man功能差不多，restlet更轻量，只在新开一个标签页。postman 需要打开一个app。]]></content>
      <tags>
        <tag>浏览器插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哑代理 - TCP链接高Recv-Q，内存泄露的罪魁祸首]]></title>
    <url>%2Ftcp-high-recv-q-or-send-q-reasons.html</url>
    <content type="text"><![CDATA[1. 问题现象使用netstat -ntp命令时发现，Recv-Q 1692012 异常偏高（正常情况下，该值应该是0），导致应用占用过多的内存。 1tcp 1692012 0 172.17.72.4:48444 10.254.149.149:58080 ESTABLISHED 27/node 问题原因：代理的转发时，没有删除逐跳首部 2. 什么是Hop-by-hop 逐跳首部？http首部可以分为两种 端到端首部 End-to-end: 端到端首部代理在转发时必须携带的 逐跳首部 Hop-by-hop: 逐跳首部只对单次转发有效，代理在转发时，必须删除这些首部 逐跳首部有以下几个, 这些首部在代理进行转发前必须删除 Connetion Keep-Alive Proxy-Authenticate Proxy-Authortization Trailer TE Transfer-Encodeing Upgrade 3. 什么是哑代理？很多老的或简单的代理都是盲中继(blind relay),它们只是将字节从一个连接转发到另一个连接中去,不对Connection首部进行特殊的处理。 (1)在图4-15a中 Web客户端向代理发送了一条报文,其中包含了Connection:Keep-Alive首部,如果可能的话请求建立一条keep-alive连接。客户端等待响应,以确定对方是否认可它对keep-alive信道的请求。 (2) 哑代理收到了这条HTTP请求,但它并不理解 Connection首部(只是将其作为一个扩展首部对待)。代理不知道keep-alive是什么意思,因此只是沿着转发链路将报文一字不漏地发送给服务器(图4-15b)。但Connection首部是个逐跳首部,只适用于单条传输链路,不应该沿着传输链路向下传输。接下来,就要发生一些很糟糕的事情了。 (3) 在图4-15b中,经过中继的HTTP请求抵达了Web服务器。当Web服务器收到经过代理转发的Connection: Keep-Alive首部时,会误以为代理(对服务器来说,这个代理看起来就和所有其他客户端一样)希望进行keep-alive对话!对Web服务器来说这没什么问题——它同意进行keep-alive对话,并在图4-15c中回送了一个Connection: Keep-Alive响应首部。所以,此时W eb服务器认为它在与代理进行keep-alive对话,会遵循keep-alive的规则。但代理却对keep-alive一无所知。不妙。 (4) 在图4-15d中,哑代理将Web服务器的响应报文回送给客户端,并将来自Web服务器的Connection: Keep-Alive首部一起传送过去。客户端看到这个首部,就会认为代理同意进行keep-alive对话。所以,此时客户端和服务器都认为它们在进行keep-alive对话,但与它们进行对话的代理却对keep-alive一无所知。 (5) 由于代理对keep-alive一无所知,所以会将收到的所有数据都回送给客户端,然后等待源端服务器关闭连接。但源端服务器会认为代理已经显式地请求它将连接保持在打开状态了,所以不会去关闭连接。这样,代理就会挂在那里等待连接的关闭。 (6) 客户端在图4-15d中收到了回送的响应报文时,会立即转向下一条请求,在keep-alive连接上向代理发送另一条请求(参见图4-15e)。而代理并不认为同一条连接上会有其他请求到来,请求被忽略,浏览器就在这里转圈,不会有任何进展了。 (7) 这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 –《HTTP权威指南》 这是HTTP权威指南中，关于HTTP哑代理的描述。这里这里说了哑代理会造成的一个问题。 这种错误的通信方式会使浏览器一直处于挂起状态,直到客户端或服务器将连接超时,并将其关闭为止。 实际上，我认为哑代理还是造成以下问题的原因 TCP链接高Recv-Q tcp链接不断开，导致服务器内存过高，内存泄露 节点iowait高 在我们自己的代理的代码中，我有发现，在代理进行转发时，只删除了headers.host, 并没有删除headers.Connection等逐跳首部的字段 12345678910delete req.headers.hostvar option = &#123; url: url, headers: req.headers&#125;var proxy = request(option)req.pipe(proxy)proxy.pipe(res) 4. 解决方案解决方案有两个， 我推荐使用第二个方案，具体方法参考Express 代理中间件的写法 更改自己的原有代码 使用成熟的开源产品 5. 参考文献 What is the reason for a high Recv-Q of a TCP connection? TCP buffers keep filling up (Recv-Q full): named unresponsive linux探秘:netstat中Recv-Q 深究 深入剖析 Socket——TCP 通信中由于底层队列填满而造成的死锁问题 netstat Recv-Q和Send-Q 深入剖析 Socket——数据传输的底层实现 Use of Recv-Q and Send-Q 【美】David Gourley / Brian Totty HTTP权威指南 【日】上野宣 于均良 图解HTTP]]></content>
      <tags>
        <tag>tcp</tag>
        <tag>Recv-Q</tag>
        <tag>哑代理</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些关于Hexo的疑问]]></title>
    <url>%2Fsomething-you-may-dont-konw-about-hexo.html</url>
    <content type="text"><![CDATA[1. 文件名重复了怎么办？使用hexo new filename命令用来新建一个文章，但是如果你创建文章时，已经存在了同样的一个文件名，那么Hexo会怎样处理？ 报错 覆盖之前的文章 在文件名后面加个序号 实际上Hexo使用第三个方式来处理，例如 123// 执行下面命令两次，会产生两个文件 filename.md, filename-1.mdhexo new filenamehexo new filename 所以，在创建文章时，你根本不需要考虑文章重名的事情，Hexo会自动帮你加上序号后处理。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题设置封面的方法]]></title>
    <url>%2Fhexo-next-theme-set-cover.html</url>
    <content type="text"><![CDATA[默认情况下NexT主题的首页，每篇文章几乎都会全部渲染出来。这是这样来看，首页就会变得非常长，不利于快速浏览。 而我希望首页可以尽量缩短，每个文章只需要稍微一点介绍，如果有图片，就设置一张封面就好了。 下面是具体的设置步骤 1. Next主题设置摘要filename: themes/next/_config.yml，将auto_excerpt.enable设置成true，length属性表示摘要的字数限制。123auto_excerpt: enable: true length: 150 2. 文章具体设置在 &lt;!-- more --&gt;上面放一张图片就可以了 1234567891011121314---title: Hexo NexT主题设置封面的方法date: 2018-02-08 21:09:50tags:- hexo---![](http://p3alsaatj.bkt.clouddn.com/20180208212257_BZZjA5_1200px-The_Great_Wave_off_Kanagawa.jpeg)文章摘要&lt;!-- more --&gt;文章正文]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻一片净土 书写我自己的芳华]]></title>
    <url>%2Fwrite-blog-belong-myself.html</url>
    <content type="text"><![CDATA[我曾经在csdn上写过博客 后来因为csdn的广告太多，我就不再csdn上写了 我也曾在博客园上写过博客 后来因为博客园上对markdown支持不够好，所以我也放弃了 我也曾在segmentfault上写过博客 它上面的markdown编辑器也还好用 但是有时候不知道是什么原因 它的markdown编辑器有时候太卡了，而且经常会出现上传图片失败 最让我不能容忍的是 你在SegmentFault删除自己的博客，那其实是逻辑删除 别人还是可以通过连接去访问的 而且SegmentFault上的广告也开始慢慢变多了 而且SegmentFault上对文章的限制也是比较多的 大树底下好乘凉，但是你的流量也是需要给大树的 互联网时代，看似任何服务都是免费的 其实免费的才是最贵的 你用了别人的服务，无论如何，你总要提供给别人价值 无论怎样，你总要做出你的回报 但是，无论如何，我总是需要一个更加独立的领地 她可以完全属于我 无论是野草还是野花 无论是杨柳依依还是雨雪霏霏 我都可以放肆潇洒 我需要一片净土 来书写我自己的芳华 所以，最近一直在把SegmentFault上的文章搬迁到github pages上 另外图片全部存在七牛云上 使用hexo next主题，做一个完全自主的静态博客]]></content>
      <tags>
        <tag>思想者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时器学习：利用定时器分解耗时任务案例]]></title>
    <url>%2Fsettimeout-to-splice-big-work.html</url>
    <content type="text"><![CDATA[对于执行时间过长的脚本，有的浏览器会弹出警告，说页面无响应。有的浏览器会直接终止脚本。总而言之，浏览器不希望某一个代码块长时间处于运行状态，因为js是单线程的。一个代码块长时间运行，将会导致其他任何任务都必须等待。从用户体验上来说，很有可能发生页面渲染卡顿或者点击事件无响应的状态。 如果一段脚本的运行时间超过5秒，有些浏览器（比如Firefox和Opera）将弹出一个对话框警告用户该脚本“无法响应”。而其他浏览器，比如iPhone上的浏览器，将默认终止运行时间超过5秒钟的脚本。–《JavaScript忍者秘籍》 JavaScript忍者秘籍里有个很好的比喻：页面上发生的各种事情就好像一群人在讨论事情，如果有个人一直在说个不停，其他人肯定不乐意。我们希望有个裁判，定时的切换其他人来说话。 Js利用定时器来分解任务，关键点有两个。 按什么维度去分解任务 任务的现场保存与现场恢复 1. 例子要求：动态创建一个表格，一共10000行，每行10个单元格 1.1. 一次性创建123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;script type="text/javascript"&gt; var tbody = document.getElementsByTagName('tbody')[0]; var allLines = 10000; // 每次渲染的行数 console.time('wd'); for(var i=0; i&lt;allLines; i++)&#123; var tr = document.createElement('tr'); for(var j=0; j&lt;10; j++)&#123; var td = document.createElement('td'); td.appendChild(document.createTextNode(i+','+j)); tr.appendChild(td); &#125; tbody.appendChild(tr); &#125; console.timeEnd('wd');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总共耗时180ms, 浏览器已经给出警告！[Violation] &#39;setTimeout&#39; handler took 53ms。 1.2. 分批次动态创建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;script type="text/javascript"&gt; var tbody = document.getElementsByTagName('tbody')[0]; var allLines = 10000; // 每次渲染的行数 var everyTimeCreateLines = 80; // 当前行 var currentLine = 0; setTimeout(function renderTable()&#123; console.time('wd'); for(var i=currentLine; i&lt;currentLine+everyTimeCreateLines &amp;&amp; i&lt;allLines; i++)&#123; var tr = document.createElement('tr'); for(var j=0; j&lt;10; j++)&#123; var td = document.createElement('td'); td.appendChild(document.createTextNode(i+','+j)); tr.appendChild(td); &#125; tbody.appendChild(tr); &#125; console.timeEnd('wd'); currentLine = i; if(currentLine &lt; allLines)&#123; setTimeout(renderTable,0); &#125; &#125;,0);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这次异步按批次创建，没有耗时的警告。因为控制了每次代码在50ms内运行。实际上每80行耗时约10ms左右。这就不会引起页面卡顿等问题。]]></content>
      <tags>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JavaScropt函数式编程，我多么希望能早点看到这本书]]></title>
    <url>%2Fjs-functional-programming.html</url>
    <content type="text"><![CDATA[我父亲以前跟我说过，有些事物在你得到之前是无足轻重的，得到之后就不可或缺了。微波炉是这样，智能手机是这样，互联网也是这样——老人们在没有互联网的时候过得也很充实。对我来说，函数的柯里化（curry）也是这样。 然后我继续看了这本书的中文版。有些醍醐灌顶的感觉。 随之在github搜了一下。 我想，即使付费，我也愿意看。 中文版地址：https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/detailsgithub原文地址：https://github.com/MostlyAdequate/mostly-adequate-guide 1. 后记其实我是想学点函数柯里化的东西，然后用谷歌搜索了一下。第一个结果就是这本书。非常感谢谷歌搜索，如果我用百度，可能就没有缘分遇到这本书了。]]></content>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[积水成渊：用github gist收藏你的代码片段]]></title>
    <url>%2Fgist-collect-code-snippets.html</url>
    <content type="text"><![CDATA[1. Github Gis服务 出生名门github 用于记录代码片段 匿名张贴 能像wiki一样记录历史如果您修改了已经发布了的Gist的话，之前的所有版本都将被保存。 支持markdown … 更多介绍请看：如何看待 Github Gist这个服务，怎样更好的利用？ 2. 客户端2.1. gistbox: 谷歌浏览器插件，用来编写gist 2.2. lepton: 支持windows, max,linux我自己用的就是这个，感觉还不错github: https://github.com/hackjutsu/Lepton 支持markdown 支持搜索 支持打标签 … 看看官方的一些截图。]]></content>
      <tags>
        <tag>gist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于找到你！如何将前端console.log的日志保存成文件?]]></title>
    <url>%2Fsave-console-log-as-file.html</url>
    <content type="text"><![CDATA[本篇文章来自一个需求，前端websocket会收到各种消息，但是调试的时候，我希望把websoekt推送过来的消息都保存到一个文件里，如果出问题的时候，我可以把这些消息的日志文件提交给后端开发区分析错误。但是在浏览器里，js一般是不能写文件的。鼠标另存为的方法也是不太好，因为会保存所有的console.log的输出。于是，终于找到这个debugout.js。 debugout.js的原理是将所有日志序列化后，保存到一个变量里。当然这个变量不会无限大，因为默认的最大日志限制是2500行，这个是可配置的。另外，debugout.js也支持在localStorage里存储日志的。 1. debugout.js 一般来说，可以使用打开console面板，然后右键save，是可以将console.log输出的信息另存为log文件的。但是这就把所有的日志都包含进来了，如何只保存我想要的日志呢？ （调试输出）从您的日志中生成可以搜索，时间戳，下载等的文本文件。 参见下面的一些例子。 Debugout的log（）接受任何类型的对象，包括函数。 Debugout不是一个猴子补丁，而是一个单独的记录类，你使用而不是控制台。 调试的一些亮点： 在运行时或任何时间获取整个日志或尾部 搜索并切片日志 更好地了解可选时间戳的使用模式 在一个地方切换实时日志记录（console.log） 可选地将输出存储在window.localStorage中，并在每个会话中持续添加到同一个日志 可选地，将日志上限为X个最新行以限制内存消耗 下图是使用downloadLog方法下载的日志文件。 官方提供的demo示例，欢迎试玩。http://inorganik.github.io/debugout.js/ 2. 使用在脚本顶部的全局命名空间中创建一个新的调试对象，并使用debugout的日志方法替换所有控制台日志方法： 1234var bugout = new debugout();// instead of console.log('some object or string')bugout.log('some object or string'); 3. API log() -像console.log(), 但是会自动存储 getLog() - 返回所有日志 tail(numLines) - 返回尾部执行行日志，默认100行 search(string) - 搜索日志 getSlice(start, numLines) - 日志切割 downloadLog() - 下载日志 clear() - 清空日志 determineType() - 一个更细粒度的typeof为您提供方便 4. 可选配置···// log in real time (forwards to console.log)self.realTimeLoggingOn = true;// insert a timestamp in front of each logself.useTimestamps = false;// store the output using window.localStorage() and continuously add to the same log each sessionself.useLocalStorage = false;// set to false after you’re done debugging to avoid the log eating up memoryself.recordLogs = true;// to avoid the log eating up potentially endless memoryself.autoTrim = true;// if autoTrim is true, this many most recent lines are savedself.maxLines = 2500;// how many lines tail() will retrieveself.tailNumLines = 100;// filename of log downloaded with downloadLog()self.logFilename = ‘log.txt’;// max recursion depth for logged objectsself.maxDepth = 25;··· 5. 项目地址https://github.com/inorganik/debugout.js 6. 另外我自己也模仿debugout.js写了一个日志保存的项目，该项目可以在ie10及以上下载日志。debugout.js在ie浏览器上下载日志的方式是有问题的。项目地址：https://github.com/wangduanduan/log4b.git]]></content>
      <tags>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何浏览器里调试iframe里层的代码？]]></title>
    <url>%2Fdebug-code-in-iframe.html</url>
    <content type="text"><![CDATA[之前一直非常痛苦，在iframe外层根本获取不了里面的信息，后来使用了postMessage用传递消息来实现，但是用起来还是非常不方便。 其实浏览器本身是可以选择不同的iframe的执行环境的。例如有个变量是在iframe里面定义的，你只需要切换到这个iframe的执行环境，你就可以随意操作这个环境的任何变量了。 这个小技巧，对于调试非常有用，但是我直到今天才发现。 1. Chrome这个小箭头可以让你选择不同的iframe的执行环境，可以切换到你的iframe环境里。 2. IE如图所示是ie11的dev tool点击下来箭头，也可以选择不同的iframe执行环境。 3. 其他浏览器其他浏览器可以自行摸索一下。。。（G_H）]]></content>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8行代码的模板字符串替换函数]]></title>
    <url>%2Fa-very-simple-template-function.html</url>
    <content type="text"><![CDATA[1. 特点 无依赖 无检查 无错误处理 无逻辑 无配置 2. 代码12345678function render(tpl, data)&#123; var re = /&#123;&#123;([^&#125;]+)?&#125;&#125;/; var match = ''; while(match = re.exec(tpl))&#123; tpl = tpl.replace(match[0],data[match[1]]); &#125; return tpl;&#125; 3. demo12345678910111213141516var tpl = '/cube_xinbao_dial_result/&#123;&#123;action&#125;&#125;/&#123;&#123;report_type&#125;&#125;/&#123;&#123;query&#125;&#125;/?userId=&#123;&#123;userId&#125;&#125;';var data = &#123;report_type:1, query: '2323', action: 'todolist',userId: '23234234'&#125;function render(tpl, data)&#123; var re = /&#123;&#123;([^&#125;]+)?&#125;&#125;/; var match = ''; while(match = re.exec(tpl))&#123; tpl = tpl.replace(match[0],data[match[1]]); &#125; return tpl;&#125;console.log(render(tpl,data));&gt; /cube_xinbao_dial_result/todolist/1/2323/?userId=23234234]]></content>
  </entry>
  <entry>
    <title><![CDATA[git常用配置与操作整理]]></title>
    <url>%2Fmy-git-common-config.html</url>
    <content type="text"><![CDATA[1. 常用配置123456789101112131415git config --global user.name "wddd" git config --global user.email "rwerewrsdfds" git config --global color.ui truegit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.br branchgit config --global alias.mg mergegit config --global alias.cp cherry-pickgit config --global push.default currentgit config --global core.editor "mate -w" # 设置Editor使用textmategit config -l # 列举所有配置 2. 提交与查看状态12345678910111213141516// 提交git ci -am "fix a bug"git push// 查看状态git st// 切换到某个分支git st // 先看看当前分支有没有没有提交的代码，如果有，要先提交，然后再切换到其他分支git co test// 切换到test分支// 查看当前一共有多少分支git br -a// pull远程分支代码到本地分支git pull 3. 分支推送与拉取123456// 基于本地maste分支，新建一个dev分支git chheckout master // 切换到master分支git checkout -b dev // 基于master,新建dev分支, 并切换到dev分支git push origin dev // 将dev分支，推送到远程仓库git fetch origin test // 拉去远程test分支到本地 4. git 仅仅合并某次提交12git checkout mastergit cherry-pick commit-id1 commit-id2 // 把指定commit合并到当前分支]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌浏览器 audio如何隐藏下载按钮]]></title>
    <url>%2Faudio-hide-download-icon.html</url>
    <content type="text"><![CDATA[当我们使用原生的audio标签时，可以看到如下的效果。 那么如何让下载按钮隐藏掉呢？ 1. controlsList=”nodownload”1234// 这个方法只支持 Chrome 58+， 低于该版本的是没有无法隐藏的&lt;audio src="/i/horse.ogg" controls="controls" controlsList="nodownload"&gt; Your browser does not support the audio element.&lt;/audio&gt; controlsList属性只兼容Chrome 58+以上，具体可以参考controlslist.html ，controlsList在线例子 nodownload: 不要下载 nofullscreen: 不要全屏 noremoteplayback: 不要远程回放 2. css方式来隐藏12345678// 这个方式兼容所有版本的谷歌浏览器audio::-webkit-media-controls &#123; overflow: hidden !important&#125;audio::-webkit-media-controls-enclosure &#123; width: calc(100% + 32px); margin-left: auto;&#125; 3. 即使让下载按钮隐藏了，如何禁止右键下载？1234// 给audio标签禁止右键，来禁止下载&lt;audio src="/i/horse.ogg" controls="controls" controlsList="nodownload" oncontextmenu="return false"&gt; Your browser does not support the audio element.&lt;/audio&gt; 4. 第三方插件: audiojs项目地址: https://github.com/kolber/audiojs优点： 简单，无依赖缺点：异步插入的audio标签，每次还是需要重新调用audiojs.createAll()方法来重新实例化 123456789// 1.&lt;script src="/audiojs/audio.js"&gt;&lt;/script&gt;// 2.&lt;script&gt; audiojs.events.ready(function() &#123; var as = audiojs.createAll(); &#125;);&lt;/script&gt; 效果图： 5. audio相关问题以及解决方案 关于动态生成的mp3在audio标签无法拖动的问题: (audio断点续传) 6. 参考文献 https://stackoverflow.com/questions/41115801/in-chrome-55-prevent-showing-download-button-for-html-5-video https://stackoverflow.com/questions/39602852/disable-download-button-for-google-chrome/40975859#40975859 https://googlechrome.github.io/samples/media/controlslist.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Audio 如果你愿意一层一层剥开我的心]]></title>
    <url>%2Faudio-heart-detail.html</url>
    <content type="text"><![CDATA[我觉得DOM就好像是元素周期表里的元素，JS就好像是实验器材，通过各种化学反应，产生各种魔术。 1. Audio通过打开谷歌浏览器的dev tools -&gt; Settings -&gt; Elements -&gt; Show user agent shadow DOM, 你可以看到其实Audio标签也是由常用的 input标签和div等标签合成的。 2. 基本用法123456789101112131415161718192021221 &lt;audio src="http://65.ierge.cn/12/186/372266.mp3"&gt;Your browser does not support the audio element.&lt;/audio&gt;&lt;br&gt;2 &lt;audio src="http://65.ierge.cn/12/186/372266.mp3" controls="controls"&gt;Your browser does not support the audio element.&lt;/audio&gt;&lt;br&gt;// controlsList属性目前只支持 chrome 58+3 &lt;audio src="http://65.ierge.cn/12/186/372266.mp3" controls="controls" controlsList="nodownload"&gt; Your browser does not support the audio element.&lt;/audio&gt;&lt;br&gt;4 &lt;audio controls="controls"&gt;&lt;source src="http://65.ierge.cn/12/186/372266.mp3" type='audio/mp3' /&gt;&lt;/audio&gt; 你可以看出他们在Chrome里表现的差异 关于audio标签支持的音频类型，可以参考Audio#Supported_audio_coding_formats 3. 常用属性 autoplay: 音频流文件就绪后是否自动播放 preload: “none” | “metadata” | “auto” | “” “none”: 无需预加载 “metadata”: 只需要加载元数据，例如音频时长，文件大小等。 “auto”: 自动优化下载整个流文件 controls： “controls” | “” 是否需要显示控件 loop： “loop” or “” 是否循环播放 mediagroup： string 多个视频或者音频流是否合并 src： 音频地址 4. API(重点) load(): 加载资源 play(): 播放 pause(): 暂停 canPlayType()： 询问浏览器以确定是否可以播放给定的MIME类型 buffered()：指定文件的缓冲部分的开始和结束时间 5. 常用事件：Media Events(重点) 事件名 何时触发 loadstart 开始加载 progress 正在加载 suspend 用户代理有意无法获取媒体数据，无法获取整个文件 abort 主动终端下载资源并不是由于发生错误 error 获取资源时发生错误 play 开始播放 pause 播放暂停 loadedmetadata 刚获取完元数据 loadeddata 第一次渲染元数据 waiting 等待中 playing 正在播放 canplay 用户代理可以恢复播放媒体数据，但是估计如果现在开始播放，则媒体资源不能以当前播放速率直到其结束呈现，而不必停止进一步缓冲内容。 canplaythrough 用户代理估计，如果现在开始播放，则媒体资源可以以当前播放速率一直呈现到其结束，而不必停止进一步的缓冲。 timeupdate 当前播放位置作为正常播放的一部分而改变，或者以特别有趣的方式，例如不连续地改变。 ended 播放结束 ratechange 媒体播放速度改变 durationchange 媒体时长改变 volumechange 媒体声音大小改变 6. Audio DOM 属性(重点)6.1. 只读属性 duration： 媒体时长，数值， 单位s ended: 是否完成播放，布尔值 paused: 是否播放暂停，布尔值 6.2. 其他可读写属性(重点) playbackRate： 播放速度，大多数浏览器支持0.5-4， 1表示正常速度，设置该属性可以修改播放速度 volume：0.0-1.0之间，设置该属性可以修改声音大小 muted: 是否静音， 设置该属性可以静音 currentTime：指定播放位置的秒数 123456// 你可以使用元素的属性seekable来决定媒体目前能查找的范围。它返回一个你可以查找的TimeRanges 时间对象。var mediaElement = document.getElementById('mediaElementID');mediaElement.seekable.start(); // 返回开始时间 (in seconds)mediaElement.seekable.end(); // 返回结束时间 (in seconds)mediaElement.currentTime = 122; // 设定在 122 secondsmediaElement.played.end(); // 返回浏览器播放的秒数 以下方法可以使音频以2倍速度播放。12345678&lt;audio id="wdd" src="http://65.ierge.cn/12/186/372266.mp3" controls="controls"&gt;Your browser does not support the audio element.&lt;/audio&gt;&lt;script&gt; var myAudio = document.getElementById('wdd'); myAudio.playbackRate = 2;&lt;/script&gt; 7. 常见问题及解决方法 录音无法拖动，播放一端就自动停止： https://wenjs.me/p/about-mp3progress-on-audio 如何隐藏Audio的下载按钮：https://segmentfault.com/a/1190000009737051 想找一个简单的录音播放插件： https://github.com/kolber/audiojs 8. 参考资料 W3C: the-audio-element wikipedia: HTML5 Audio W3C: HTML/Elements/audio Native Audio in the browser HTMLMediaElement.playbackRate 使用 HTML5 音频和视频]]></content>
      <tags>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github上的那些前端神器]]></title>
    <url>%2Fgithub-powerful-tools-recommend.html</url>
    <content type="text"><![CDATA[1. serve: 在任意目录开启静态文件服务器 https://github.com/zeit/serve 2. lambda-view：优雅的看js源码 https://github.com/Jianru-Lin/lambda-view 3. ConEmu：windows命令行从未如此迷人 https://github.com/Maximus5/ConEmu 4. Wox：天下武功，唯快不破 https://github.com/Wox-launcher/Wox 5. gow：谁说windows不能用linux命令 https://github.com/bmatzelle/gow 6. vimium：像用vim一样用chrome浏览器 https://github.com/philc/vimium 7. localtunnel：将内网地址转化成公网地址 https://github.com/localtunnel/localtunnel 8. Browsersync：省时省力的浏览器同步测试工具地址：http://www.browsersync.cn/ 9. PM2: 集负载均衡、热更新、监控等功能于一身的Node.js应用程序的生产流程管理器地址：https://github.com/Unitech/pm2]]></content>
      <tags>
        <tag>github</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitbook 前端好书推荐]]></title>
    <url>%2Fgitbook-good-book-recommend.html</url>
    <content type="text"><![CDATA[1. Front-End Developer Handbook 2017 地址：https://frontendmasters.com/books/front-end-handbook/2017/ 这是任何人都可以用来了解前端开发实践的指南。它大致概述并讨论了前端工程的实践：如何学习它，以及在2017年实践时使用什么工具。 这是专门为潜在的和目前实践的前端开发人员提供专业资源，以配备学习材料和开发工具。其次，管理者，首席技术官，导师和猎头人士可以使用它来了解前端开发的实践。 手册的内容有利于网络技术（HTML，CSS，DOM和JavaScript）以及直接构建在这些开放技术之上的解决方案。本书中引用和讨论的材料是课堂上最好的或目前提出的问题。 该书不应被视为对前端开发人员可用的所有资源的全面概述。这本书的价值被简单，集中和及时地组织起来，仅仅是足够的绝对信息，以免任何人在任何一个特定的主题上压倒一切。 目的是每年发布一次内容更新。 手册分为三部分。 第一部分。前端实践 第一部分广泛描述了前端工程的实践。 第二部分：学习前端发展 第二部分指出了自主导向和直接的资源，用于学习成为前端开发人员。 第三部分：前端开发工具 第三部分简要解释和识别交易工具。 2. JS函数式编程指南英文版地址：中文版地址：https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ 这本书的主题是函数范式（functional paradigm），我们将使用 JavaScript 这个世界上最流行的函数式编程语言来讲述这一主题。有人可能会觉得选择 JavaScript 并不明智，因为当前的主流观点认为它是一门命令式（imperative）的语言，并不适合用来讲函数式。但我认为，这是学习函数式编程的最好方式，因为： 你很有可能在日常工作中使用它 这让你有机会在实际的编程过程中学以致用，而不是在空闲时间用一门深奥的函数式编程语言做一些玩具性质的项目。 你不必从头学起就能开始编写程序 在纯函数式编程语言中，你必须使用 monad 才能打印变量或者读取 DOM 节点。JavaScript 则简单得多，可以作弊走捷径，因为毕竟我们的目的是学写纯函数式代码。JavaScript 也更容易入门，因为它是一门混合范式的语言，你随时可以在感觉吃力的时候回退到原有的编程习惯上去。 这门语言完全有能力书写高级的函数式代码 只需借助一到两个微型类库，JavaScript 就能模拟 Scala 或 Haskell 这类语言的全部特性。虽然面向对象编程（Object-oriented programing）主导着业界，但很明显这种范式在 JavaScript 里非常笨拙，用起来就像在高速公路上露营或者穿着橡胶套鞋跳踢踏舞一样。我们不得不到处使用 bind 以免 this 不知不觉地变了，语言里没有类可以用（目前还没有），我们还发明了各种变通方法来应对忘记调用 new 关键字后的怪异行为，私有成员只能通过闭包（closure）才能实现，等等。对大多数人来说，函数式编程看起来更加自然。+ 以上说明，强类型的函数式语言毫无疑问将会成为本书所示范式的最佳试验场。JavaScript 是我们学习这种范式的一种手段，将它应用于什么地方则完全取决于你自己。幸运的是，所有的接口都是数学的，因而也是普适的。最终你会发现你习惯了 swiftz、scalaz、haskell 和 purescript，以及其他各种数学偏向的语言。 3. 前端开发笔记本地址：http://chanshuyi.github.io/frontend_notebook/ 前端开发笔记本涵括了大部分前端开发所需的知识点，主要包括5大部分：《页面制作》、《JavaScript程序设计》、《DOM编程》、《页面架构》、《前端产品架构》。]]></content>
      <tags>
        <tag>books</tag>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs Express dockerfile最佳实践]]></title>
    <url>%2Fnodejs-best-dockerfile.html</url>
    <content type="text"><![CDATA[1. 少啰嗦，先看代码1.1. package.json123456789101112131415161718192021222324&#123; "name": "xxx", "version": "0.0.0", "private": true, "scripts": &#123; "start": "node ./bin/www", "forever": "node_modules/forever/bin/forever bin/www" &#125;, "dependencies": &#123; "async": "0.9.0", "body-parser": "1.13.2", "compression": "1.6.2", "config": "1.12.0", "connect-multiparty": "2.0.0", "cookie-parser": "1.3.5", "debug": "2.2.0", "ejs": "2.3.3", "express": "4.13.1", "forever": "0.15.3", "http-proxy-middleware": "0.17.3", "log4js": "0.6.24", "serve-favicon": "2.3.0" &#125;&#125; 1.2. dockerfile12345678910111213141516FROM node:9.2.1-alpineRUN apk update &amp;&amp; apk add bash tzdata \ &amp;&amp; cp -r -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeWORKDIR /appCOPY package.json yarn.lock /app/RUN yarn install --production &amp;&amp; yarn cache cleanCOPY . /appEXPOSE 8088CMD yarn run server 2. 分析原理 使用alpine的nodejs镜像，显著缩小nodejs镜像大小 node:9.2.1-alpine自带yarn 和 npm copy package到run npm i到copy . /app, 这样的顺序可以充分使用镜像缓存 修改过后，对比之前通过jenkins打包时间从10分钟缩短到7.4秒 3. 参考资料 How to write excellent Dockerfiles]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>docker</tag>
        <tag>dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表单验证工具 jquery-validation Vs Parsley]]></title>
    <url>%2Fjquery-validation-vs-parsley.html</url>
    <content type="text"><![CDATA[1. 基本对比 名称 gitbub地址 stars 文档地址 jquery-validation 这里 7859(截止7/21) 这里 Parsley.js 这里 7979(截止7/21) 这里 2. 强烈推荐Parsley这两个表格验证插件我都用过，最早用的是jqueryValidataion, 现在用Parsley。这两个插件都依赖jQuery。但是如果说那个跟好用的话，真心推荐Parsley。Parsley号称不用写一行代码就能验证表单。另外从star的数量上也可以看出来Parsley更流行。而且Parsley支持在html中就将错误信息定义在里面。 Parsley优势 直观的DOM API: 像没有其他表单验证库一样，只需用HTML格式写入您的要求，Parsley将会做剩下的所有事情！不需要编写一行代码来验证表单。 动态表单验证： parsley现在更聪明，它会自动检测您的表单的修改并相应地调整其验证。简单地添加，删除或编辑字段，parsley将会自动验证。 还有好多… 1234567891011&lt;form&gt; &lt;input type="text" required="" data-parsley-checkphonenum data-parsley-checkphonenum-message="手机号码格式有误" name="phoneNum" class="form-control" placeholder="请填写手机号"&gt;&lt;/form&gt;//验证表单// 注意 checkphonenum是我自定义的验证规则，添加到parsley里面的$('from').parsley().validate();]]></content>
      <tags>
        <tag>jQuery</tag>
        <tag>Parsley</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端小白的python实战 报纸分词排序]]></title>
    <url>%2Fpython-paper-word-split.html</url>
    <content type="text"><![CDATA[先看效果： 1. 环境 win7 64位 python 3.5 2. 目标抓取一篇报纸，并提取出关键字，然后按照出现次数排序，用echarts在页面上显示出来。 3. 工具选择因为之前对nodejs的相关工具比较熟悉，在用python的时候，也想有类似的工具。所以就做了一个对比的表格。 功能 nodejs版 python版 http工具 request requests 中文分词工具 node-segment, nodejieba(一直没有安装成功过) jieba(分词准确度比node-segment好) DOM解析工具 cheeio pyquery(这两个工具都是有类似jQuery那种选择DOM的接口，很方便) 函数编程工具 underscore.js underscore.py(underscore来处理集合比较方便) 服务器 express flask 4. 开始的噩梦：中文乱码感觉每个学python的人都遇到过中文乱码的问题。我也不例外。 首先要抓取网页，但是网页在控制台输出的时候，中文总是乱码。搞了好久，搞得我差点要放弃python。最终找到解决方法。 解决python3 UnicodeEncodeError: ‘gbk’ codec can’t encode character ‘\xXX’ in position XX 过程很艰辛，但是从中也学到很多知识。 123import ioimport syssys.stdout = io.TextIOWrapper(sys.stoodout.buffer,encoding='gb18030') 5. 函数式编程： 顺享丝滑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#filename word_rank.pyimport requestsimport ioimport reimport sysimport jieba as _jieba # 中文分词比较优秀的一个库from pyquery import PyQuery as pq #类似于jquery、cheerio的库from underscore import _ # underscore.js python版本sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding='gb18030') # 解决控制台中文乱码USELESSWORDS = ['的','要','了','在','和','是','把','向','上','为','等','个'] # 标记一些无用的单词TOP = 30 # 只要前面的30个就可以了def _remove_punctuation(line): # 移除非中文字符 # rule = re.compile("[^a-zA-Z0-9\u4e00-\u9fa5]") rule = re.compile("[^\u4e00-\u9fa5]") line = rule.sub('',line) return linedef _calculate_frequency(words): # 计算分词出现的次数 result = &#123;&#125; res = [] for word in words: if result.get(word, -1) == -1: result[word] = 1 else: result[word] += 1 for word in result: if _.contains(USELESSWORDS, word): # 排除无用的分词 continue res.append(&#123; 'word': word, 'fre': result[word] &#125;) return _.sortBy(res, 'fre')[::-1][:TOP] # 降序排列def _get_page(url): # 获取页面 return requests.get(url)def _get_text(req): # 获取文章部分 return pq(req.content)('#ozoom').text()def main(url): # 入口函数，函数组合 return _.compose( _get_page, _get_text, _remove_punctuation, _jieba.cut, _calculate_frequency )(url) 6. python服务端：Flask浅入浅出1234567891011121314151617181920import word_rankfrom flask import Flask, request, jsonify, render_templateapp = Flask(__name__)app.debug = True@app.route('/rank') # 从query参数里获取pageUrl，并给分词排序def getRank(): pageUrl = request.args.get('pageUrl') app.logger.debug(pageUrl) rank = word_rank.main(pageUrl) app.logger.debug(rank) return jsonify(rank)@app.route('/') # 主页面def getHome(): return render_template('home.html')if __name__ == '__main__': app.run() 7. 总结据说有个定律：凡是能用JavaScript写出来的，最终都会用JavaScript写出来。 我是很希望这样啦。但是不得不承认，python上有很多非常优秀的库。这些库在npm上并没有找到合适的替代品。 所以，我就想: 如何能用nodejs直接调用python的第三方库 目前的解决方案有两种，第一，只用nodejs的child_processes。这个方案我试过，但是不太好用。 第二，npm里面有一些包，可以直接调用python的库。例如：node-python, python.js, 但是这些包我在win7上安装的时候总是报错。而且解决方法也蛮麻烦的。索性我就直接用python了。 最后附上项目地址：https://github.com/wangduanduan/read-newspaper]]></content>
      <tags>
        <tag>Python</tag>
        <tag>分词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【笔记】 程序员修炼之道 从小工到专家]]></title>
    <url>%2Fhow-to-be-a-better-programer.html</url>
    <content type="text"><![CDATA[1 关心你的技艺 2 思考你的工作 3 在所有的弱点中，最大的弱点就是害怕暴露弱点 4 提供各种选择，不要找各种蹩脚的借口 5 不要容忍破窗户 6 作变化的催化剂 7 记住大方向 8 让质量成为需求问题 9 知识也会贬值，定期为你的知识投资 每年至少学习一种编程语言 每季度至少读一本技术书籍 也要阅读非技术书籍 上课 上网 玩玩UNIX 跟上潮流 10 批判的分析你读到的和听到的 11 我相信，被打量要被忽略要好 12 你说什么和你怎样说同样重要 13 不要重复你自己, 也不要重复别人 14 糟糕的代码才需要许多注释 15 让复用变得容易 16 消除无关事物之间的影响 (解耦性，正交性) 17 编码 让你的代码保持解耦 避免使用全局数据 避免编写相似的函数 18 如果某个想法是你唯一的想法，再没有什么比这更危险的事情了 19 不存在最终决定 20 稍后就是永不 21 用曳光弹找到目标 22 语言的界限就是一个人世界的界限 23 靠近问题编程 24 估算，避免发生意外 25 用纯文本保存知识 26 利用命令shells的力量 27 用好一种编辑器，彻底了解它，确保你的编辑器能在所有平台上使用 (我现在最爱是vscode, 曾经最爱是sublime) 可配置 可扩展 可编辑 语法高亮 自动完成 自动缩进 跨平台 启动快 占用内存小 漂亮 28 总是使用源码控制 29 要修正问题，而不是发出职责 (关于调试，bug) 30 不要恐慌 (我曾经差点因为上线的之前的重大问题产生辞职的想法) 31 不要假定，要证明 32 你不可能写出完美的软件 33 如果它不可能发生，用断言确保它不会发生 34 将异常用于异常的问题 35 要有始有终 36 使模块之间的耦合减至最小 37 要配置，不要集成 (可配置) 38 将抽象放进代码，将细节放进元数据 39 分析工作流，以改善并发性 40 用服务进行设计 41 总是为并发进行设计 42 将视图与模型分离 43 小心那些替你编写大量代码的工具，除非你了解它在做什么 44 不要靠巧合编程 45 估算你算法的阶 46 早重构，常重构 47 为测试而设计 48 不要搜集需求，挖掘他们 49 与用户一起工作，以像用户一样思考 50 需求不是架构，需求不是设计，也不是用户界面，而是需求。 51 抽象比细节活的更长久 52 使用项目词汇表 (名不正则言不顺) 53 昂贵的工具不一定能制作出更好的设计 54 早测试，常测试，自动测试 55 要到通过全部测试，编码才算完成 56 把网收紧，一个bug只抓一次 57 温和的超出用户的期望 58 在你的作品上签名 59 建立自己的藏书库]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码整洁之道 - 有意义的命名]]></title>
    <url>%2Fclean-code-method.html</url>
    <content type="text"><![CDATA[在小朱元璋出生一个月后，父母为他取了一个名字（元时惯例）：朱重八，这个名字也可以叫做朱八八。我们这里再介绍一下，朱重八家族的名字，都很有特点。朱重八高祖名字：朱百六；朱重八曾祖名字：朱四九；朱重八祖父名字：朱初一；他的父亲我们介绍过了，叫朱五四。取这样的名字不是因为朱家是搞数学的，而是因为在元朝，老百姓如果不能上学和当官就没有名字，只能以父母年龄相加或者出生的日期命名。（登记户口的人一定会眼花）–《明朝那些事儿》 那么问题来了，朱四九和朱百六是什么关系？ 你可能马上懵逼了。所以说：命名不仅仅是一种科学，更是一种艺术。 1. 名副其实12345// badvar d; // 分手的时间，以天计算// goodvar daysAfterBrokeUp; // 分手以后，以天计算 2. 避免误导1234567891011// badvar nameList = 'wdd'; // List一般暗指数据是数组，而不应该赋值给字符串// goodvar nameList = ['wdd','ddw','dwd']; // // badvar ill10o = 10; //千万不要把i,1,l,0,o,O放在一起，傻傻分不清楚// goodvar illOne = 10; 3. 做有意义的区分12345// badvar userData, userInfo; // Data和Info, 有什么区别？？？？, 不要再用data和info这样模糊不清的单词了// goodvar userProfile, userAcount 4. 使用读得出来的名称12345// bad var beeceearrthrtee; // 你知道怎么读吗？ 鼻涕阿三？？// goodvar userName; 5. 使用可搜索的名称12345// badvar e = 'not found'; // 想搜e, 就很难搜// goodvar ERROR_NO_FOUND = 'not found'; 6. 方法名一概是动词短语12345// goodfunction createAgent()&#123;&#125;funtion deleteAgent()&#123;&#125;function updateAgent()&#123;&#125;function queryAgent()&#123;&#125; 7. 尽量不要用单字母名称, 除了用于循环123456789101112// badvar i = 1;// goodfor(var i=0; i&lt;10; i++)&#123; ...&#125;// very gooduserList.forEach(function(user)&#123; ...&#125;); 8. 每个概念对应一个词1controller和manager, 没什么区别，要用controller都用controller, 要用manager都用manager, 不要混着用 9. 建立项目词汇表, 不要随意创造名称1user, agent, org, queue, activity, device... 10. 参考资料 《代码整洁之道》 《明朝那些事儿》]]></content>
  </entry>
  <entry>
    <title><![CDATA[定位神器：1秒定位DOM元素绑定的事件代码的位置]]></title>
    <url>%2Fvisual-event-tool.html</url>
    <content type="text"><![CDATA[1. VisualEventgithub地址： https://github.com/DataTables/VisualEvent 2. 使用教程 打开http://sprymedia.co.uk/VisualEvent/这个页面，然后将visual Event连接拖动到浏览器的书签栏上 随便打开一个页面，然后点击VisualEvent书签后，页面就变成这样了。鼠标移动到蓝色或者黄色边框的元素上，相应得逻辑代码就会出现。截图左下角蓝色长条上有一些有用的信息，最左边有个关闭的按钮。 3. 最后VisualEvent并不是万能的，Vue绑定的事件它就无法检测出来。当然Vue的事件是直接写在Dom上的，根本无需定位。工欲善其事必先利其器，多一个工具总是好的，万一真有需要呢。]]></content>
  </entry>
  <entry>
    <title><![CDATA[可能被遗漏的https与http的知识点]]></title>
    <url>%2Fyou-dont-know-https-and-http.html</url>
    <content type="text"><![CDATA[1. HTTPS域向HTTP域发送请求会被浏览器直接拒绝，HTTP向HTTPS则不会例如在github pages页面，这是一个https页面，如果在这个页面向http发送请求，那么会直接被浏览器拒绝，并在控制台输出下面的报错信息。 1jquery-1.11.3.min.js:5 Mixed Content: The page at 'https://wangduanduan.github.io/ddddddd/' was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint 'http://cccccc/log/conf?token=welljoint'. This request has been blocked; the content must be served over HTTPS. 如果你在做第三方集成的系统，如果他们是在浏览器中直接调用你提供的接口，那么最好你使用https协议，这样无论对方是https还是http都可以访问。（相信我，这个很重要，我曾经经历过上线后遇到这个问题，然后连夜申请证书，把http升级到https的痛苦经历） 2. HTTPS的默认端口是443，而不是443如果443端口已经被其他服务占用了，那么使用其他任何没有被占用的端口都可以用作HTTPS服务，只不过在请求的时候需要加上端口号罢了。 3. 如何快速隐藏一个DOM元素选中一个元素，然后按h,这时候就会在选中的DOM元素上加上__web-inspector-hide-shortcut__类，这个类会让元素隐藏。谷歌和火狐上都可以，IE上没有试过行不行。]]></content>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直接在Chrome DevTools调试Node.js]]></title>
    <url>%2Fdebug-nodejs-in-chrome-devtool.html</url>
    <content type="text"><![CDATA[英文好的，直接看原文 https://blog.hospodarets.com/nodejs-debugging-in-chrome-devtools 1. 要求 Node.js 6.3+ Chrome 55+ 2. 操作步骤 1 打开连接 chrome://flags/#enable-devtools-experiments 2 开启开发者工具实验性功能 3 重启浏览器 4 打开 DevTools Setting -&gt; Experiments tab 5 按6次shift后，隐藏的功能会出现，勾选”Node debugging” 3. 运行程序必须要有 --inspect12345&gt; node --inspect wwwDebugger listening on port 9229.Warning: This is an experimental feature and could change at any time.To start debugging, open the following URL in Chrome: chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true&amp;v8only=true&amp;ws=localhost:9229/78a884f4-8c2e-459e-93f7-e1cbe87cf5cf 将这个地址粘贴到谷歌浏览器：chrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true&amp;v8only=true&amp;ws=localhost:9229/78a884f4-8c2e-459e-93f7-e1cbe87cf5cf 程序后端输出的日志也回输出到谷歌浏览器的console里面，同时也可以在Sources里进行断点调试了。]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12个值得关注的顶级JS库]]></title>
    <url>%2Ftop-11-javascript-libraries-are-worth-your-attention.html</url>
    <content type="text"><![CDATA[本文是译文，原文是https://da-14.com/blog/top-11-javascript-libraries-are-worth-your-attention我在原文的基础上加了百度的Echats图表库，这个也是毫不逊色其他图表库的。另外Handsontable电子表格库也是蛮好玩的。 前端开发工具在过去几年中取得了进步和成功。这些日子，JS库和框架可以简化工作流程，提高开发过程，并在响应式设计方面提供更好的功能。 考虑到一个长的JavaScript库列表，它可能是挑战选择，那是值得的时间和精力。我们已经讨论了最好的JavaScript框架，今天我们想研究JS库中的新星。你可能听说过像jQuery或React这样的大名字，这是最有用的JavaScript库之一，虽然有很多其他解决方案。 一些库是几乎必须在每个其他项目应用，而其他的更集中和用于执行应用程序中的特定功能。为了清楚起见，我们按类型分组了最好的JavaScript库，所以让我们开始。 1. 图表类1.1. D3 D3.js（数据驱动文档）通常被称为最强大的开源JavaScript可视化库。它的生态系统包括几十个插件和其他库建立在D3js的顶部。同时，支持社区和大量的文档可以帮助您立即开始。 D3符合W3C网络标准，几乎支持所有现代浏览器。尽管事实上它不包括任何预先构建的图表，它提供了许多例子和“输入和退出”选择，容易的调试过程和强大的转换等有用的功能。 1.2. Chart.js Chart.js是一个简单的开源解决方案，用于小项目和这些情况下，当你需要快速创建图表。它有八种图表类型和混合它们的能力，外加令人惊叹的动画选项开箱。强烈建议使用此JavaScript图形库，以便简单的设置过程，工作灵活性和全面的文档，尽管其功能相当有限。 Chartist.js具有类似的功能，而它是基于SVG，而不是HTML5画布在Chartjs。 1.3. FusionCharts FusionCharts是迄今为止最好的JavaScript图表库。作为设计师和开发者最全面的解决方案，它包括90多种图表类型和1000个地图，将Google图表和MetricsGraphics保留在后面。 今天FusionCharts可以拥有超过24,000个客户，其中包括白宫，Oracle，IBM，微软，谷歌等等。作为最流行的JavaScript库之一，它是高度可扩展的，并与各种设备和浏览器，包括IE 6,7和8兼容。但是，水印版本可以免费使用商业和个人项目，但删除水印你需要购买许可证。 1.4. Google ChartsGoogle图表允许您构建从纯色图表到复杂树形图的所有内容。它配备了广泛的预构建的图表库，各种数据工具和多个自定义选项。 HTML5和SVG上的基础图表​​此库确保跨浏览器和跨平台兼容性，而对于较旧的IE版本，它包括VML。 由于详细的文档，代码注释和分步说明，Google Charts工具可以成为任何人谁想要使用JavaScript构建图表的一个很好的起点。但是，由于文件是从Google的服务器上传的，因此您的Web JavaScript应用程序应该在线以查看图表。 1.5. Echarts（百度出品） 更小文件 更大作为 更小体积的文件，满足更轻便的使用需求 更灵活的打包方式，可自由选择你需要的图表和组件 移动端强势来袭 良好的自适应效果 专属的移动端交互体验 更丰富的可视化效果 新增更多图表类型，更好的满足不同数据的处理需求 更多的搭配方案让你的数据呈现方式更个性和完美 2. 动画2.1. GSAP GSAP（GreenSock动画平台）是一个先进的动画解决方案，由全球最大的企业使用创建惊人的互动动画，没有麻烦。它被超过200万网站雇用，在他们的客户中，你可以找到像福特，耐克，Adobe，微软，三星和许多其他的伟大的名字。 GSAP与新旧浏览器以及移动设备高度兼容。在顶级功能SVG支持，使任何DOM元素可拖动，可旋转或可滑动滚动和快速性能的能力。它还带有定向旋转，3D变换，模块化架构，快速加载，零依赖性等等。 2.2. Bounce.js Bounce.js是一个整洁的JavaScript动画库，使您能够创建有吸引力的CSS3动力的动画，像饼图一样简单。它有10个预设，如旋转，旋风，果冻，公路跑步者和其他人，以生成平滑的动画，任何网页设计或自定义项目。 这个库是绝对免费的和MIT许可的，它是一个不错的选择，在那些情况下，当你不需要一个长列表的动画类型，寻找实验或只是尝试你的手在动画。 3. Animate.css Animate.css是一个平滑的CSS库，允许您添加整洁的动画到所选对象。它具有超过50种不同的预设，可以应用于文本，形式，对象和CSS3的图片。由于小文件大小，跨浏览器支持和易于使用它可以是一个非常适合移动项目，滑块，主页等。 4. 时间日期4.1. Moment.js Moment.js是一个简单和轻量级的日期库，使解析，操作和格式化日期和时间容易和准确。它具有多语言支持，持续时间，日历时间和各种插件，以获得诸如时区支持，Twitter集成等功能。但重要的是，它消除了使用本机JavaScript日期对象的需要，随后促进复杂解析过程和减少代码量。 4.2. Date-fns Date-fns是一个高级工具集，用于在浏览器和Node.js中操作时间和日期。它提供了140多个有用的功能，可以通过简单的API轻松访问。由于模块化结构，它允许您只选择您当前需要的项目的那些功能。 5. 其他5.1. Math.js Math.js是JavaScript引擎的开源数学库。它有许多函数和常量，灵活的表达式解析器，以及支持复杂和大数字，单位，字符串，分数，矩阵，数组和符号计算。 5.2. Handsontable Handsontable是一个无障碍的JavaScript电子表格库用于构建一流的Web应用程序。它可以轻松地扩展和修改与自定义插件。由开发人员为开发人员建造，它确保快速和容易的开始，方便的模块化结构和活跃的社区支持。这个表库包括超过30个功能的免费版本和额外的10+功能的专业版。目前Handsontable用于销售报告，人力规划，数据合并，数据库编辑等领域。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【译】13简单的优秀编码规则（从我15年的经验）]]></title>
    <url>%2Ffew-simple-rules-for-good-coding-my-15-years-experience.html</url>
    <content type="text"><![CDATA[原文地址：https://hackernoon.com/few-simple-rules-for-good-coding-my-15-years-experience-96cb29d4acd9#.ddzpjb80c 嗨，我的工作作为一个程序员超过15年，并使用许多不同的语言，范例，框架和其他狗屎。我想和大家分享我写好代码的规则。 1. 优化VS可读性 去他妈的优化始终编​​写易于阅读且对开发人员可理解的代码。因为在硬可读代码上花费的时间和资源将远远高于从优化中获得的。如果你需要进行优化，那么使它像DI的独立模块，具有100％的测试覆盖率，并且不会被触及至少一年。 2. 架构第一我看到很多人说“我们需要快速做事，我们没有时间做架构”。其中约99％的人因为这样的想法而遇到了大问题。编写代码而不考虑其架构是没有用的，就像没有实现它们的计划一样，梦想你的愿望。在编写代码的第一行之前，你应该明白它将要做什么，它将如何使用，模块，服务如何相互工作，它将有什么结构，如何进行测试和调试，以及如何更新。 3. 测试覆盖率测试是好事，但他们并不总是负担得起，对项目有意义。 当你需要测试： 当你编写模块时，微服务将不会被触及至少一个月。 当你编写开源代码。 当你编写涉及金融渠道的核心代码或代码。 当您有代码更新的同时更新测试的资源。 当你不需要测试时： 当你是一个创业。 当你有小团队和代码更改是快速。 当你编写的脚本，可以简单地通过他们的输出手动测试。 记住，带有严格测试的代码可能比没有测试的代码更有害。 4. 保持简单，极度简单不要编写复杂的代码。更多更简单，那么更少的错误它可能有和更少的时间来调试它们。代码应该做的只是它需要没有非常多的抽象和其他OOP shit（尤其是涉及java开发人员）+ 20％的东西可能需要在将来以简单的方式更新它。 5. 注释出现注释说明你的代码不够好。好的代码应该是可以理解的，没有一行注释。但是如何为新开发人员节省时间？ - 编写简单的内联文档描述什么和如何方法工作。这将节省很多时间来理解，甚至更多 - 它将给人们更多的机会来提出更好的实施这种方法。并且它将是全球代码文档的良好开端。 6. 硬耦合VS较小耦合始终尝试使用微服务架构。单片软件可以比微服务软件运行得更快，但只能在一个服务器的上下文中运行。微服务使您可以不仅在许多服务器上，而且有时甚至在一台机器上（我的意思是过程分发）高效地分发您的软件。 7. 代码审查代码审查可以是好的，也以是坏的。您可以组织代码审查，只有当您有开发人员了解95％的代码，谁可以监控所有更新，而不浪费很多时间。在其他情况下，这将是只是耗时，每个人都会讨厌这个。 在这部分有很多问题，所以更深入地描述这一点。 许多人认为代码审查是一个很好的方式教新手，或者工作在不同部分的代码的队友。但是代码审查的主要目标是保持代码质量，而不是教学。让我们想象你的团队制作代码用于控制核反应堆或太空火箭发动机的冷却系统。你在非常硬的逻辑中犯了巨大的错误，然后你给这个代码审查新的家伙。你怎么认为会发生意外的风险？ - 我的练习率超过70％。 良好的团队是每个人都有自己的角色，负责确切的工作。如果有人想要理解另一段代码，那么他去一个负责任去问他。你不可能知道一切，更好的优秀的理解小块代码而不是理解所有。 8. 重构没啥用在我的职业生涯中，我听到很多次“不要担心，我们以后会重构它”。在未来，这会导致大的技术债务或从头开始删除所有的代码和写作。 所以，不要得到一个债务，除非你有钱从头开发你的软件几次。 9. 当你累了或在一个坏的心情不要写代码。当开发人员厌倦时，他们正在制造2到5倍或者更多的bug。所以工作更多是非常糟糕的做法。这就是为什么越来越多的国家思考6小时工作日，其中一些已经有了。精神工作不同于使用你的二头肌。 10. 不要一次写全部 - 使开发迭代在编写代码分析和预测之前，您的客户/客户真正需要什么，然后选择您可以在短期内以高质量开发的MVF（最有价值的功能）。使用这样的迭代来部署质量更新，而不是腰部时间和资源对不合理的愿望和牺牲与质量。 11. 自动化VS手动自动化是长期的100％成功。所以如果你有资源自动化的东西，现在应该做。你可能认为“只需要5分钟，为什么我应该自动化？但让我计算这个。例如，它是5个开发人员的日常任务。 5分钟 5天 21天* 12个月= 6 300分钟= 105小时= 13.125天〜5250 $。如果你有40 000名员工，这将需要多少费用？ 12. 出去浪，学习新爱好差异化工作可以增加心智能力，并提供新想法。所以，暂停现在的工作，出去呼吸一下新鲜空气，与朋友交谈，弹吉他等。ps: 莫春者，春服既成，冠者五六人，童子六七人，浴乎沂，风乎舞雩，咏而归。------《论语.先进》。 13. 在空闲时间学习新事物当人们停止学习时，他们开始退化。]]></content>
  </entry>
  <entry>
    <title><![CDATA[15行代码为segmentfault增加头条文章排序功能]]></title>
    <url>%2Fsort-for-sf.html</url>
    <content type="text"><![CDATA[有个需求，想看点赞最多的头条，但是页面没有这种按钮。怎么办？自己写吧。 先看效果 再看代码123456789101112131415var rows = $('.news__item').each(function()&#123; var key = +$(this).find('.news__item-zan-number').text(); $(this).data('key', key);&#125;).get();rows.sort(function(a,b)&#123; var keyA = $(a).data('key'); var keyB = $(b).data('key'); if(keyA&lt;keyB)&#123;return -1;&#125; else&#123;return 1;&#125;&#125;);$.each(rows, function(index, row)&#123; $('.news__list').prepend(row);&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[可视化交互阅读JS源代码]]></title>
    <url>%2Fvisual-reading-js-code.html</url>
    <content type="text"><![CDATA[1. 曾经，你可以能习惯这样阅读javascript 2. 现在，你可以用这个姿势阅读 3. 怎么做呢?3.1. step1:1npm install -g lambda-view 3.2. step2:1234567891011// 阅读本地代码lv targer.js// 阅读远程代码lv https://code.jquery.com/jquery-3.1.1.js// 阅读多个代码lv file1.js file2.js file3.js// 阅读所有lv *.js 4. 项目地址：https://github.com/Jianru-Lin/lambda-view5. 欢迎试玩！]]></content>
  </entry>
  <entry>
    <title><![CDATA[谷歌浏览器： Snippets小程序哪家强？]]></title>
    <url>%2Fchrome-snippets-collect.html</url>
    <content type="text"><![CDATA[Snippets是可以在Chrome DevTools的“源”面板中创建和执行的小脚本。 您可以从任何页面访问和运行它们。 当您运行代码段时，它会从当前打开的页面的上下文执行。 1. 显示所有元素的边框，看页面布局非常方便 123[].forEach.call($$("*"),function(a)&#123; a.style.outline="1px solid #"+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;); 2. allcolors.js 从页面上的元素中使用的计算样式打印所有颜色。 使用样式化的console.log调用来可视化每种颜色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// allcolors.js// https://github.com/bgrins/devtools-snippets// Print out CSS colors used in elements on the page.(function () &#123; // Should include colors from elements that have a border color but have a zero width? var includeBorderColorsWithZeroWidth = false; var allColors = &#123;&#125;; var props = ["background-color", "color", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color"]; var skipColors = &#123; "rgb(0, 0, 0)": 1, "rgba(0, 0, 0, 0)": 1, "rgb(255, 255, 255)": 1 &#125;; [].forEach.call(document.querySelectorAll("*"), function (node) &#123; var nodeColors = &#123;&#125;; props.forEach(function (prop) &#123; var color = window.getComputedStyle(node, null).getPropertyValue(prop), thisIsABorderProperty = (prop.indexOf("border") != -1), notBorderZero = thisIsABorderProperty ? window.getComputedStyle(node, null).getPropertyValue(prop.replace("color", "width")) !== "0px" : true, colorConditionsMet; if (includeBorderColorsWithZeroWidth) &#123; colorConditionsMet = color &amp;&amp; !skipColors[color]; &#125; else &#123; colorConditionsMet = color &amp;&amp; !skipColors[color] &amp;&amp; notBorderZero; &#125; if (colorConditionsMet) &#123; if (!allColors[color]) &#123; allColors[color] = &#123; count: 0, nodes: [] &#125;; &#125; if (!nodeColors[color]) &#123; allColors[color].count++; allColors[color].nodes.push(node); &#125; nodeColors[color] = true; &#125; &#125;); &#125;); function rgbTextToRgbArray(rgbText) &#123; return rgbText.replace(/\s/g, "").match(/\d+,\d+,\d+/)[0].split(",").map(function(num) &#123; return parseInt(num, 10); &#125;); &#125; function componentToHex(c) &#123; var hex = c.toString(16); return hex.length == 1 ? "0" + hex : hex; &#125; function rgbToHex(rgbArray) &#123; var r = rgbArray[0], g = rgbArray[1], b = rgbArray[2]; return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b); &#125; var allColorsSorted = []; for (var i in allColors) &#123; var rgbArray = rgbTextToRgbArray(i); var hexValue = rgbToHex(rgbArray); allColorsSorted.push(&#123; key: i, value: allColors[i], hexValue: hexValue &#125;); &#125; allColorsSorted = allColorsSorted.sort(function (a, b) &#123; return b.value.count - a.value.count; &#125;); var nameStyle = "font-weight:normal;"; var countStyle = "font-weight:bold;"; function colorStyle(color) &#123; return "background:" + color + ";color:" + color + ";border:1px solid #333;"; &#125;; console.group("Total colors used in elements on the page: " + window.location.href + " are " + allColorsSorted.length); allColorsSorted.forEach(function (c) &#123; console.groupCollapsed("%c %c " + c.key + " " + c.hexValue + " %c(" + c.value.count + " times)", colorStyle(c.key), nameStyle, countStyle); c.value.nodes.forEach(function (node) &#123; console.log(node); &#125;); console.groupEnd(); &#125;); console.groupEnd("All colors used in elements on the page");&#125;)(); 3. cachebuster.js 通过在href和src属性的末尾添加Date.now（）来覆盖所有链接和（可选）脚本标记。 默认情况下，不执行处理脚本，应将变量process_scripts更改为true以运行这些脚本。 12345678910111213141516171819202122232425262728293031//Cache Buster(function ()&#123; var rep = /.*\?.*/, links = document.getElementsByTagName('link'), scripts = document.getElementsByTagName('script'), process_scripts = false; for (var i=0;i&lt;links.length;i++)&#123; var link = links[i], href = link.href; if(rep.test(href))&#123; link.href = href+'&amp;'+Date.now(); &#125; else&#123; link.href = href+'?'+Date.now(); &#125; &#125; if(process_scripts)&#123; for (var i=0;i&lt;scripts.length;i++)&#123; var script = scripts[i], src = script.src; if(rep.test(src))&#123; script.src = src+'&amp;'+Date.now(); &#125; else&#123; script.src = src+'?'+Date.now(); &#125; &#125; &#125;&#125;)(); 4. console-save.js 从控制台将对象保存为.json文件的简单方法包括一个chrome扩展和一个纯文本。1console.save(data, [filename]) 1234567891011121314151617181920212223242526(function(console)&#123; console.save = function(data, filename)&#123; if(!data) &#123; console.error('Console.save: No data') return; &#125; if(!filename) filename = 'console.json' if(typeof data === "object")&#123; data = JSON.stringify(data, undefined, 4) &#125; var blob = new Blob([data], &#123;type: 'text/json'&#125;), e = document.createEvent('MouseEvents'), a = document.createElement('a') a.download = filename a.href = window.URL.createObjectURL(blob) a.dataset.downloadurl = ['text/json', a.download, a.href].join(':') e.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null) a.dispatchEvent(e) &#125;&#125;)(console) 5. formcontrols.js 在一个不错的表中显示所有html表单元素及其值和类型。 在页面上为每个表单添加一个新表 123456789101112131415161718192021222324252627282930// formcontrols.js// https://github.com/bgrins/devtools-snippets// Print out forms and their controls(function() &#123; var forms = document.querySelectorAll("form"); for (var i = 0, len = forms.length; i &lt; len; i++) &#123; var tab = [ ]; console.group("HTMLForm quot;" + forms[i].name + "quot;: " + forms[i].action); console.log("Element:", forms[i], "\nName: "+forms[i].name+"\nMethod: "+forms[i].method.toUpperCase()+"\nAction: "+forms[i].action || "null"); ["input", "textarea", "select"].forEach(function (control) &#123; [].forEach.call(forms[i].querySelectorAll(control), function (node) &#123; tab.push(&#123; "Element": node, "Type": node.type, "Name": node.name, "Value": node.value, "Pretty Value": (isNaN(node.value) || node.value === "" ? node.value : parseFloat(node.value)) &#125;); &#125;); &#125;); console.table(tab); console.groupEnd(); &#125;&#125;)(); 6. log-globals.js 打印全局变量 123456789101112131415161718192021222324252627282930313233* log-globals by Sindre Sorhus https://github.com/sindresorhus/log-globals MIT License*/(function () &#123; 'use strict'; function getIframe() &#123; var el = document.createElement('iframe'); el.style.display = 'none'; document.body.appendChild(el); var win = el.contentWindow; document.body.removeChild(el); return win; &#125; function detectGlobals() &#123; var iframe = getIframe(); var ret = Object.create(null); for (var prop in window) &#123; if (!(prop in iframe)) &#123; ret[prop] = window[prop]; &#125; &#125; return ret; &#125; console.log(detectGlobals());&#125;)(); 7. performance.js 打印有关window.performance对象的信息。 使用console.table和分组来组织信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// performance.js// https://github.com/bgrins/devtools-snippets// Print out window.performance information.// https://developer.mozilla.org/en-US/docs/Navigation_timing(function () &#123; var t = window.performance.timing; var lt = window.chrome &amp;&amp; window.chrome.loadTimes &amp;&amp; window.chrome.loadTimes(); var timings = []; timings.push(&#123; label: "Time Until Page Loaded", time: t.loadEventEnd - t.navigationStart + "ms" &#125;); timings.push(&#123; label: "Time Until DOMContentLoaded", time: t.domContentLoadedEventEnd - t.navigationStart + "ms" &#125;); timings.push(&#123; label: "Total Response Time", time: t.responseEnd - t.requestStart + "ms" &#125;); timings.push(&#123; label: "Connection", time: t.connectEnd - t.connectStart + "ms" &#125;); timings.push(&#123; label: "Response", time: t.responseEnd - t.responseStart + "ms" &#125;); timings.push(&#123; label: "Domain Lookup", time: t.domainLookupEnd - t.domainLookupStart + "ms" &#125;); timings.push(&#123; label: "Load Event", time: t.loadEventEnd - t.loadEventStart + "ms" &#125;); timings.push(&#123; label: "Unload Event", time: t.unloadEventEnd - t.unloadEventStart + "ms" &#125;); timings.push(&#123; label: "DOMContentLoaded Event", time: t.domContentLoadedEventEnd - t.domContentLoadedEventStart + "ms" &#125;); if(lt) &#123; if(lt.wasNpnNegotiated) &#123; timings.push(&#123; label: "NPN negotiation protocol", time: lt.npnNegotiatedProtocol &#125;); &#125; timings.push(&#123; label: "Connection Info", time: lt.connectionInfo &#125;); timings.push(&#123; label: "First paint after Document load", time: Math.ceil(lt.firstPaintTime - lt.finishDocumentLoadTime) + "ms" &#125;); &#125; var navigation = window.performance.navigation; var navigationTypes = &#123; &#125;; navigationTypes[navigation.TYPE_NAVIGATENEXT || 0] = "Navigation started by clicking on a link, or entering the URL in the user agent's address bar, or form submission.", navigationTypes[navigation.TYPE_RELOAD] = "Navigation through the reload operation or the location.reload() method.", navigationTypes[navigation.TYPE_BACK_FORWARD] = "Navigation through a history traversal operation.", navigationTypes[navigation.TYPE_UNDEFINED] = "Navigation type is undefined.", console.group("window.performance"); console.log(window.performance); console.group("Navigation Information"); console.log(navigationTypes[navigation.type]); console.log("Number of redirects that have taken place: ", navigation.redirectCount) console.groupEnd("Navigation Information"); console.group("Timing"); console.log(window.performance.timing); console.table(timings, ["label", "time"]); console.groupEnd("Timing"); console.groupEnd("window.performance");&#125;)(); 8. 更多有意思的： http://bgrins.github.io/devtools-snippets/]]></content>
      <tags>
        <tag>snippets</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 日志插件比较 VS 自定义日志插件]]></title>
    <url>%2Fnodejs-log-packages.html</url>
    <content type="text"><![CDATA[1. morgan 【优点】morgan配置非常简单 【优点】支持自定义日志格式 【优点】支持日志分机 【优点】支持日志压缩：使用rotating-file-stream 【缺点】无法同时往console和文件中写日志 2. log4js-node 【优点】配置简单 【优点】支持同时往控制台和文件中写数据 【优点】支持按照时间或文件大小分割文件 【优点】支持文件压缩123456789101112131415161718192021222324252627282930313233343536"use strict";var path = require('path'), log4js = require('../lib/log4js');log4js.configure( &#123; appenders: [ &#123; type: "file", filename: "important-things.log", maxLogSize: 10*1024*1024, // = 10Mb numBackups: 5, // keep five backup files compress: true, // compress the backups encoding: 'utf-8', mode: parseInt('0640', 8), flags: 'w+' &#125;, &#123; type: "dateFile", filename: "more-important-things.log", pattern: "yyyy-MM-dd-hh", compress: true &#125;, &#123; type: "stdout" &#125; ] &#125;);var logger = log4js.getLogger('things');logger.debug("This little thing went to market");logger.info("This little thing stayed at home");logger.error("This little thing had roast beef");logger.fatal("This little thing had none");logger.trace("and this little thing went wee, wee, wee, all the way home."); 3. winston 没用过，不做评论 4. fluent-logger-node 往fluntd中写日志，没用过 5. express-winston 没用过 6. 如何自定义一个日志插件 可以自定义日志结构 日志文件可以用gzip压缩 不影响往console写日志 可以按时间分割日志 支持日志覆盖，最多保留1个月的备份 使用rotating-file-stream123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var path = require('path');var fs = require('fs');var rfs = require('rotating-file-stream');var logDirectory = __dirname;function Wpad(num) &#123; return (num &gt; 9 ? "" : "0") + num;&#125;/** * [Wgenerator 创建文件名函数] * @Author Wdd * @DateTime 2017-02-22T10:13:39+0800 * 日志会保留一个月的：因为日志文件名是只使用日期，9月8号的日志就会覆盖8月8号的日志 * 文件的格式是gzip * 文件名例如：22-log.gizp */function Wgenerator(time, index) &#123; if(! time)&#123; return "temp-log.txt.gzip"; &#125; return "/storage/"+ Wpad(time.getDate()) +"-log.txt.gzip";&#125;var accessLogStream = rfs(Wgenerator, &#123; interval: '1d', // 周期为1天 path: logDirectory, compress: 'gzip' , rotationTime:true&#125;);/** * [exports description] * @Author Wdd * @DateTime 2017-02-22T10:24:06+0800 * 使用方式： * 1. 安装rotating-file-stream * 2. 在根目录下创建一个文件夹，例如logs。然后把access-log.js放进去 * 3. 在app.js中var mylog = require('./logs/access-log'); * 4. 在app = express(); 后添加一句 app.use(mylog); * 5. 日志文件会自动生成在./logs/storage文件夹下面，当天的日志会保存在暂存的./logs/temp-log.gzip里 */module.exports = function(req, res, next)&#123; req._startTime = new Date(); res.once('finish', function()&#123; var msg = ""; //hostname msg = process.env.hostname+" "; // 时间 msg += new Date()+" "; // 请求方式 msg += req.method+" "; // 响应状态码 msg += res.statusCode+" "; // sessionId msg += req.headers.sessionid+" "; // 响应时长 msg += new Date() - req._startTime ; // 请求路径 msg += " " + req.originalUrl +'\n\r\n\r'; accessLogStream.write(msg); &#125;); next();&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery进阶：用最优雅的方式写ajax请求]]></title>
    <url>%2Felegant-way-write-ajax-request.html</url>
    <content type="text"><![CDATA[1. 首先需要一个配置文件1234567891011121314151617181920var api = &#123; basePath: 'http://192.168.200.226:58080', pathList: [ &#123; name: 'agentHeartBeat', path:'/api/csta/agent/heartbeat/&#123;&#123;agentId&#125;&#125;/&#123;&#123;type&#125;&#125;/&#123;&#123;something&#125;&#125;', method:'get' &#125;, &#123; name: 'setAgentState', path: '/api/csta/agent/state', method: 'post' &#125;, &#123; name: 'getAgents', path: '/user/agent/&#123;&#123;query&#125;&#125;', method: 'get' &#125; ]&#125; 2. 然后需要一个方法，把配置文件生成接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function WellApi(Config)&#123;var headers = &#123;&#125;;var Api = function()&#123;&#125;;Api.pt = Api.prototype;var util = &#123; ajax: function(url, method, payload) &#123; return $.ajax(&#123; url: url, type: method || "get", data: JSON.stringify(payload), headers: headers, dataType: "json", contentType: 'application/json; charset=UTF-8' &#125;); &#125;, /** * [render 模板渲染] * 主要用于将 /users/&#123;&#123;userId&#125;&#125; 和&#123;userId: '89898'&#125;转换成/users/89898，和mastache语法差不多， * 当然我们没必要为了这么小的一个功能来引入一个模板库 * query字符串可以当做一个参数传递进来 * 例如： /users/&#123;&#123;query&#125;&#125;和&#123;query:'?name=jisika&amp;sex=1'&#125; * @Author Wdd * @DateTime 2017-03-13T19:42:58+0800 * @param &#123;[type]&#125; tpl [description] * @param &#123;[type]&#125; data [description] * @return &#123;[type]&#125; [description] */ render: function(tpl, data)&#123; var re = /&#123;&#123;([^&#125;]+)?&#125;&#125;/; var match = ''; while(match = re.exec(tpl))&#123; tpl = tpl.replace(match[0],data[match[1]]); &#125; return tpl; &#125;&#125;;/** * [setHeader 暴露设置头部信息的方法] * 有些方法需要特定的头部信息，例如登录之后才能获取sesssionId,然后访问所有的接口时，必须携带sessionId * 才可以访问 * @Author Wdd * @DateTime 2017-03-13T10:34:03+0800 * @param &#123;[type]&#125; headers [description] */Api.pt.setHeader = function(headers)&#123; headers = headers;&#125;;/** * [fire 发送ajax请求，this会绑定到每个接口上] * @Author Wdd * @DateTime 2017-03-13T19:42:13+0800 * @param &#123;[type]&#125; pathParm [description] * @param &#123;[type]&#125; payload [description] * @return &#123;[type]&#125; [description] */function fire(pathParm, payload)&#123; var url = util.render(this.path, pathParm); return util.ajax(url, this.method, payload);&#125;/** * [for 遍历所有接口] * @Author Wdd * @DateTime 2017-03-13T19:49:33+0800 * @param &#123;[type]&#125; var i [description] * @return &#123;[type]&#125; [description] */for(var i=0; i &lt; Config.pathList.length; i++)&#123; Api.pt[Config.pathList[i].name] = &#123; path: Config.basePath + Config.pathList[i].path, method: Config.pathList[i].method, fire: fire &#125;;&#125;return new Api();&#125; 3. 试用一下1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="api.js"&gt;&lt;/script&gt; &lt;script src="jquery-ajax.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; var saas = WellApi(api); saas.agentHeartBeat.fire(&#123;agentId: '5001@1011.cc', type:'a', something: 'test'&#125;) .done(function(res)&#123; console.log('心跳成功'); &#125;) .fail(function(res)&#123; console.log('心跳失败'); &#125;); // 如果没有参数要渲染到路径上，那个第一个参数可以传空对象 saas.setAgentState.fire(&#123;&#125;, &#123;status: 'Ready'&#125;) .done(function(res)&#123; console.log('设置成功'); &#125;) .fail(function(res)&#123; console.log('设置失败'); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4. 注意点fire(pathParm, payload)中的pathParm是最终会被渲染到请求的路径里面，而paylaod代表请求体。 例如：12345678// 路径这么写/api/&#123;&#123;version&#125;&#125;/agent/&#123;&#123;id&#125;&#125;/&#123;&#123;somethingElse&#125;&#125;// pathParm这样写&#123;version: 1, id: '2', somethingElse: 'sss'&#125;// 最终路径会被渲染成/api/1/agent/2/sss path里面不仅仅可放一个变量的，具体可以参考mustache语法，上面代码里的render是以最简单的实现。 5. 优点与扩展 [优点]：类似与promise的回调方式 [优点]：增加一个接口只是需要增加一个配置文件，很方便 [扩展]：当前的ajax 的contentType我只写了json，有兴趣可以扩展其他的数据类型 [缺点]：没有对函数参数进行校验]]></content>
      <tags>
        <tag>ajxa</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年 最好的javascript 书籍]]></title>
    <url>%2F2017-best-js-books.html</url>
    <content type="text"><![CDATA[我看过三本，第1本，第二本，第四本。第一本买的的实体书，其他两本看的是电子书。第一本是大名鼎鼎老道写的，书很薄，但是非常经典。javascirpt忍者秘籍是jquery的作者写的，也是非常经典。you dont kown js系列也是非常好。看了收益匪浅。文章是谷歌翻译的，英文好的直接看原文吧。 原文：https://reactdom.com/blog/javascript-books 你不能是一个好的ReactJS，React Native或GraphQL开发人员，如果你没有很好地理解JavaScript。有太多的JavaScript书出来，每月出来更多。那么什么是最好的JavaScript书为你？经过多年的经历，这些是学习JavaScript的最好的JavaScript书。请记住，这些书中的一些可能不是最新的，但概念和基础仍应适用。我们将继续更新这个最好的JavaScript书籍的列表，还有书签，共享和定期检查！ 1. JavaScript: The Good Parts《JavaScript语言精粹》 JavaScript：Douglas Crockford的Good Parts是JavaScript书籍历史中的一个重要版本，是每个JavaScript程序员都需要阅读的一本书。 Douglas Crockford是JSON，JSLint的创建者，并且对JavaScript的开发做出了许多贡献。 JavaScript：The Good Parts侧重于使JavaScript成为一个伟大的面向对象编程语言的想法。这些想法包括函数，对象，语法，符号等。不幸的是，这些好的想法与坏的和彻底的可怕的想法混在一起，如基于全局变量的编程模型。这本书将告诉你如何避免这些坏的部分，并使用好的部分来制作伟大的代码。 JavaScript：Good Parts将告诉你如何创建优雅的代码，而不管你使用JavaScript的方式。如果你为Web开发网站或应用程序，这本书是绝对必须的。你需要编写复杂的接口，做大量的计算和处理JS，就像它是面向对象的语言，这实际上是一个必读。 2. You Don’t Know JS《你不知道js》 你不知道JS通过Kyle Simpson是一个JavaScript系列的书，将显示你的JavaScript知识的差距，然后教你需要了解JavaScript的一切，以弥补这些差距。 Kyle Simpson是最好的JavaScript老师之一。任何认真对待JavaScript的人都应该注意凯尔的所有教义。 你不知道JS书籍处理JavaScript的棘手部分，以帮助你实现真正的JavaScript掌握。这些书的范围相似，涵盖了并不总是被理解的主题。你不知道JS是每个级别的开发人员的完美。这些书在范围上非常具体，这是它的最大优势。 你不知道JS书系列是所有JavaScript程序员的必须，所有的书是伟大的。短书的长度是一件伟大的事情，你可以快速完成，而不失去焦点。你不知道JS带有最高的建议。 3. JavaScript: The Definitive Guide《JavaScript权威指南》 JavaScript：David Flanagan的“绝对指南”是一本书，它肯定是一个非常沉重的标题，绝对是最好的JavaScript书籍之一。 David Flanagan在Mozilla工作，他的大部分时间都在编写编程书。 JavaScript：The Definitive Guide被分为两个部分，分别是讨论和引用。这两个部分中的每一个包含两个部分，核心和客户端。核心章节涵盖了数据类型，函数，类等语言特性。客户端章节涵盖了在浏览器中运行的JavaScript的使用。 JavaScript：The Definitive Guide包括基于作者现实世界经验的准确文档。 JavaScript：The Definitive Guide多年来一直有多个版本和更新。这是很好的理由;这本书总是在改进，作者总是参与新版本（缺乏许多JavaScript书籍的东西）。无论版本是什么，本书的基础和核心以及JavaScript保持不变。 JavaScript：The Definitive Guide是一个关于JavaScript的最终指南，从基础知识开始，一直到高级功能。 JavaScript：The Definitive Guide属于每个程序员的架子，不能被推荐足够。 4. Secrets of the JavaScript Ninja《JavaScript忍者秘籍》 JavaScript Ninja的秘密由John Resig，Bear Bibeault＆Josip Maras是一个JavaScript经典，将把你变成一个JavaScript忍者。 John Resig是jQuery库的创建者，Bear Bibeault是一名网络开发人员，Josip Maras是一位博士后研究员。 JavaScript Ninja的秘密由4部分组成。每个部分都集中在几个相关的话题，从基础到高级。包括的一些主题是功能，对象，原型，承诺等。本书有很多有用的摘要和练习。 JavaScript Ninja的秘密使用非常实用的例子清楚地说明每个核心概念和技术。 JavaScript Ninja的秘密还包括API，最佳实践，跨各种浏览器测试等。 JavaScript Ninja的秘密是非常精巧的写作，这是没有什么惊喜，因为作者在JavaScript非常有经验。 JavaScript Ninja的秘密推荐给任何想成为一个JavaScript忍者，这是每个人。 5. Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript 有效的JavaScript：68具体的方法来利用JavaScript的力量David Herman将教会你通过68提示和技巧写更好的JavaScript。 David Herman是Mozilla Research的首席研究员，在Ecma的JavaScript标准化委员会有多年的经验。 有效的JavaScript集中在68个不同的课程与示例，使你写更好的JavaScript。从基础到高级功能的一切都在详细讨论。要成为JavaScript的主人，您必须学习如何避免陷阱，并使用JavaScript的强大功能有效地工作。有效的JavaScript将帮助编写更好和可维护的代码，而不管您的JavaScript体验。 有效的JavaScript涵盖68个JavaScript原则到68个简短的课程，使它成为一个伟大的方式来学习JavaScript。 Effective JavaScript是一本推荐给所有级别的JavaScript程序员的书，不管它们有多忙。 6. JavaScript Patterns: Build Better Applications with Coding and Design Patterns JavaScript模式：使用编码和设计模式构建更好的应用程序Stoyan Stefanov教你JavaScript编码模式和最佳实践。 Stoyan Stefanov在雅虎工作，是YSlow 2.0的建筑师 JavaScript模式将引导您使用模式和反模式编写JavaScript。讨论了Singleton等经典设计模式，然后展示了如何在JavaScript中使用它们。讨论了编写高质量JavaScript代码和定义函数的不同和适当方法的伟大习惯。本书涵盖了大量的继承和代码重用技术。 JavaScript模式将教你从初学者到高级水平所需的一切。 JavaScript模式在JavaScript的教学模式以及详细的代码示例方面非常出色。这本书展示了你使用它教授的各种技术的优点和缺点。 JavaScript模式是一本关于开发JavaScript应用程序的精心编写的书，应该用作各级JavaScript开发人员的参考。 7. The Principles of Object-Oriented JavaScript Nicholas C. Zakas的面向对象JavaScript的原理探讨了JavaScript的面向对象的特性，并揭示了JavaScript如何使用继承和其他关键属性。 Nicholas C. Zakas是一位前端顾问，在他的主页，YUI等上与Yahoo广泛合作。 面向对象的JavaScript的原则遍历所有的方式在JavaScript中使用面向对象的原则。所有讨论的主题，如处理原型，对象，构造函数等。面向对象的JavaScript的原则涵盖了所有提供的解决方案的优点和缺点，同时深入地涵盖了主题。所有级别的JavaScript开发人员都将从阅读本书中获益良多，并编写更高效的代码。 面向对象的JavaScript的原则涵盖JavaScript的面向对象的方面，并且非常好。这本书的长度不算太大，所以它不会压倒你。如果你想使用JavaScript的面向对象的原则，面向对象的JavaScript的原则是为你。 8. Eloquent JavaScript: A Modern Introduction to Programming 雄辩的JavaScript：Marijn的现代编程介绍Haverbeke是一本关于JavaScript的惊人的书。这肯定是一本雄辩的书.Marijn Haverbeke在开源软件上工作，并创建了CodeMirror和Tern。 雄辩的JavaScript是所有关于编程。这本书专注于编程和所有的编程概念。雄辩的JavaScript是伟大的初学者，因为它假设没有以前的经验，从编程的基础开始。 雄辩的JavaScript使用一个非常集中的路线图，并充满了练习。 Eloquent JavaScript是一本伟大的书，可以启动JavaScript，并推荐给大家。 擅长JavaScript是一个需要是一个好的ReactJS开发人员。无论你在JavaScript中的专业水平，这些书将帮助你成为一个更好的JavaScript开发人员。不仅如此，他们还会让你成为一个更好的ReactJS和前端开发人员。在你完成这些书后，查看ReactJS书籍和最好的React本土书籍。]]></content>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：编写高质量javascript的68个方法]]></title>
    <url>%2F68-skills-to-write-better-js-code.html</url>
    <content type="text"><![CDATA[书还没看完。一遍看，一遍写读书笔记。 这本书的序是JavaScript之父Brendan Eich写的，作者是JavaScript标准化委员会专家。可想而知其质量如何。这本书不厚，和《JavaScript语言精粹》差不多厚，约等于4分之一的《JavaScript权威指南》的厚度。绝对值得一看。 1. 本书赞誉本书的赞誉有来自Chrome开发主管，有来自JSHint的专家，还有一些行业大咖。 如果你想成为一名真正的JavaScript开发者, 那么请阅读这本书。就我来说，我多么希望在第一次开始JavaScript编程时就阅读它。—Anton Kovalyov, JSHint开发者 很少有人有机会同大师一起学习他们的手艺。这本书弥补了这种缺陷，其对JavaScript的研究就像随一位时间旅行哲学家回到公园前5世纪与柏拉图一起学习。—Rick Waldron, JavaScript传教士， Bocoup 2. 让自己习惯JavaScript 有些人说不清哪里好，可就是谁也替代不了。 2.1. 了解你使用的JavaScript的版本 2.2. 理解JavaScript的浮点数2.3. 当心隐式的强制类型转换2.4. 原始类型优于封装对象2.5. 避免对混合类型使用 == 运算符2.6. 了解分号插入的局限2.7. 视字符串为16位的代码单元序列3. 变量与作用域 作用域对程序员来说就像氧气。它无处不在，甚至，你往往不会去想它。但当它被污染时，你会感觉到窒息。 3.1. 尽量少使用全局对象 避免声明全局变量 尽量声明局部变量 避免对全局变量增加属性 3.2. 始终声明局部变量3.3. 避免使用with语句3.4. 熟练使用闭包 JavaScript的函数值包含了比调用他们时执行所需要的代码还要更多的信息。而且，JavaScript函数值还在内部存储他们可能会引用的定义在其封闭作用域的变量。那些在其所涵盖的作用域内跟踪变量的函数称为闭包。 JavaScript允许你引用在当前函数以外定义的变量 即使外部函数已经返回，当前函数仍然可以引用外部函数定义的变量 闭包可以更新外部函数的值 3.5. 理解变量声明提升3.6. 使用立即调用表达式创建局部作用域3.7. 当心命名函数表达式笨拙的作用域3.8. 当心局部块函数声明笨拙的作用域3.9. 避免使用evel创建局部变量3.10. 间接调用eval函数函数优于直接调用]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高级技巧]]></title>
    <url>%2Fjs-high-skills.html</url>
    <content type="text"><![CDATA[0.1. 安全类型检测 javascript内置类型检测并不可靠 safari某些版本（&lt;4）typeof正则表达式返回为function 建议使用Object.prototype.toString.call()方法检测数据类型12345678910111213141516function isArray(value)&#123; return Object.prototype.toString.call(value) === "[object Array]";&#125;function isFunction(value)&#123; return Object.prototype.toString.call(value) === "[object Function]";&#125;function isRegExp(value)&#123; return Object.prototype.toString.call(value) === "[object RegExp]";&#125;function isNativeJSON()&#123; return window.JSON &amp;&amp; Object.prototype.toString.call(JSON) === "[object JSON]";&#125; 对于ie中一COM对象形式实现的任何函数，isFunction都返回false，因为他们并非原生的javascript函数。 在web开发中，能够区分原生与非原生的对象非常重要。只有这样才能确切知道某个对象是否有哪些功能 以上所有的正确性的前提是：Object.prototype.toString没有被修改过 0.2. 作用域安全的构造函数123456789function Person(name)&#123; this.name = name;&#125;//使用new来创建一个对象var one = new Person('wdd');//直接调用构造函数Person(); 由于this是运行时分配的，如果你使用new来操作，this指向的就是one。如果直接调用构造函数，那么this会指向全局对象window,然后你的代码就会覆盖window的原生name。如果有其他地方使用过window.name, 那么你的函数将会埋下一个深藏的bug。 ==那么，如何才能创建一个作用域安全的构造函数？==方法112345678function Person(name)&#123; if(this instanceof Person)&#123; this.name = name; &#125; else&#123; return new Person(name); &#125;&#125; 1. 惰性载入函数假设有一个方法X，在A类浏览器里叫A,在b类浏览器里叫B,有些浏览器并没有这个方法,你想实现一个跨浏览器的方法。 惰性载入函数的思想是：在函数内部改变函数自身的执行逻辑 12345678910111213function X()&#123; if(A)&#123; return new A(); &#125; else&#123; if(B)&#123; return new B(); &#125; else&#123; throw new Error('no A or B'); &#125; &#125;&#125; 换一种写法12345678910111213141516171819function X()&#123; if(A)&#123; X = function()&#123; return new A(); &#125;; &#125; else&#123; if(B)&#123; X = function()&#123; return new B(); &#125;; &#125; else&#123; throw new Error('no A or B'); &#125; &#125; return new X();&#125; 2. 防篡改对象2.1. 不可扩展对象 Object.preventExtensions1234567891011// 下面代码在谷歌浏览器中执行&gt; var person = &#123;name: 'wdd'&#125;;undefined&gt; Object.preventExtensions(person);Object &#123;name: "wdd"&#125;&gt; person.age = 1010&gt; personObject &#123;name: "wdd"&#125;&gt; Object.isExtensible(person)false 2.2. 密封对象Object.seal密封对象不可扩展，并且不能删除对象的属性或者方法。但是属性值可以修改。123456789101112&gt; var one = &#123;name: 'hihi'&#125;undefined&gt; Object.seal(one)Object &#123;name: "hihi"&#125;&gt; one.age = 1212&gt; oneObject &#123;name: "hihi"&#125;&gt; delete one.namefalse&gt; oneObject &#123;name: "hihi"&#125; 2.3. 冻结对象 Object.freeze最严格的防篡改就是冻结对象。对象不可扩展，而且密封，不能修改。只能访问。 3. 高级定时器3.1. 函数节流函数节流的思想是：某些代码不可以没有间断的连续重复执行12345678910111213141516171819202122var processor = &#123; timeoutId: null, // 实际进行处理的方法 performProcessing: function()&#123; ... &#125;, // 初始化调用方法 process: function()&#123; clearTimeout(this.timeoutId); var that = this; this.timeoutId = setTimeout(function()&#123; that.performProcessing(); &#125;, 100); &#125;&#125;// 尝试开始执行processor.process(); 3.2. 中央定时器页面如果有十个区域要动态显示当前时间，一般来说，可以用10个定时来实现。其实一个中央定时器就可以搞定。 中央定时器动画 demo地址：http://wangduanduan.coding.me/my-all-demos/ninja/center-time-control.html 1234567891011121314151617181920212223242526272829var timers = &#123; timerId: 0, timers: [], add: function(fn)&#123; this.timers.push(fn); &#125;, start: function()&#123; if(this.timerId)&#123; return; &#125; (function runNext()&#123; if(timers.timers.length &gt; 0)&#123; for(var i=0; i &lt; timers.timers.length ; i++)&#123; if(timers.timers[i]() === false)&#123; timers.timers.splice(i, 1); i--; &#125; &#125; timers.timerId = setTimeout(runNext, 16); &#125; &#125;)(); &#125;, stop: function()&#123; clearTimeout(timers.timerId); this.timerId = 0; &#125; &#125;; 参考书籍：《javascript高级程序设计》《javascript忍者秘籍》]]></content>
  </entry>
  <entry>
    <title><![CDATA[从一个小场景学会使用 apply方法]]></title>
    <url>%2Fhow-to-use-apply.html</url>
    <content type="text"><![CDATA[1. 需求 需要自定义一个log方法，这个方法可以像原生的console.log一样 在开发环境我希望调用这个log会输出日志信息，生产环境我希望即使调用了这个方法，也不会输出日志信息。 2. 实现这个log 可能要使用apply或者call方法 log的参数个数和类型都是不固定的 call的参数个数是固定的，要排除它 apply的参数是需要一个数组，这个合适，可以使用arguments来当做数组传递 3. 代码12345678var MyLog = &#123; silent: false, log: function()&#123; if(!this.silent)&#123; console.log.apply(this, arguments); &#125; &#125;&#125;; 4. 试用123456789&gt; MyLog.log(1,2,3, '4545');1 2 3 "4545"undefined&gt; MyLog.silent = truetrue&gt; MyLog.log(1,2,3, '4545');undefined 5. 后记 不要随处使用console.log，因为这样当你不需要日志输出的时候，你就要到处填坑了 不要使用alert，这个很烦人]]></content>
  </entry>
  <entry>
    <title><![CDATA[突然觉得自己好像没学过JS]]></title>
    <url>%2Fi-realy-dont-know-js.html</url>
    <content type="text"><![CDATA[0.1. 先看题：mean的值是什么？123456789var scores = [10,11,12];var total = 0;for(var score in scores)&#123; total += score;&#125;var mean = total/scores.length;console.log(mean); 0.2. 是11？恭喜你：答错了！ 0.3. 是1？恭喜你：答错了！ 0.4. 正确答案： 4解释： for in 循环循环的值永远是key, key是一个字符串。所以total的值是：’0012’。它是一个字符串，字符串’0012’/3,0012会被转换成12，然后除以3，结果是4。 0.5. 后记这个示例是来自《编写高质量JavaScript的68个方法》的第49条：数组迭代要优先使用for循环而不是for in循环。既然已经发布，就可能有好事者拿出去当面试题。这个题目很有可能坑一堆人。其中包括我。 这里涉及到许多js的基础知识. for in 循环是循环对象的索引属性，key是一个字符串。 数值类型和字符串相加，会自动转换为字符串 字符串除以数值类型，会先把字符串转为数值，最终结果为数值 正确方法123456789var scores = [10,11,12];var total = 0;for(var i=0, n=scores.length; i &lt; n; i++)&#123; total += scores[i];&#125;var mean = total/scores.length;console.log(mean); 这样写有几个好处。 循环的终止条件简单且明确 即使在循环体内修改了数组，也能有效的终止循环。否则就可能变成死循环。 编译器很难保证重启计算scores.length是安全的。 提前确定了循环终止条件，避免多次计算数组长度。这个可能会被一些浏览器优化。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI大全：前端UI框架集合（持续更新）]]></title>
    <url>%2Fall-best-ui-frame.html</url>
    <content type="text"><![CDATA[1. 更新UI选择务必慎重，货比三家。 弱水三千只取一瓢：弱水三千只取一瓢，源起佛经中的一则故事，警醒人们在一生中可能会遇到很多美好的东西，但只要用心好好把握住其中的一样就足够了 😊😊😊😊欢迎贡献😊😊😊😊 2017-1209 ZanUI (Vue) 2017-1218 Onsen UI(Vue, React, Angular) 2017-1215 增加 Vuetify, Weex UI, Semantic UI React,element-react, element-angular,NG-ZORRO 2017-1214 增加 Mint UI 2017-1211 增加 Layui, UIkit 2017-1206 增加 cube-ui, Amaze ui React 除了老牌构建于jQuery框架之上的UI外, 新锐UI派系： 基于Vue: ELementUI, iViewui 基于React: AntDesign, Amaze UI React 2. 移动端2.1. WeUI 来自：腾讯 WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。详情 2.2. SUI Mobile 来自：阿里 SUI Mobile 是一套基于 Framework7 开发的UI库。它非常轻量、精美，只需要引入我们的CDN文件就可以使用，并且能兼容到 iOS 6.0+ 和 Android 4.0+，非常适合开发跨平台Web App。轻量的UI库SUI Mobile 非常轻量，核心库压缩Gzip后的JS、CSS网络传输体积总共只有52K，却提供了20+个常用的组件。详情 2.3. Amaze ~ 妹子 UI 中国首个开源 HTML5 跨屏前端框架 详情 Amaze UI 以移动优先（Mobile first）为理念，从小屏逐步扩展到大屏，最终实现所有屏幕适配，适应移动互联潮流。 Amaze UI 含近 20 个 CSS 组件、20 余 JS 组件，更有多个包含不同主题的 Web 组件，可快速构建界面出色、体验优秀的跨屏页面，大幅提升开发效率。 相比国外框架，Amaze UI 关注中文排版，根据用户代理调整字体，实现更好的中文排版效果；兼顾国内主流浏览器及 App 内置浏览器兼容支持。 Amaze UI 面向 HTML5 开发，使用 CSS3 来做动画交互，平滑、高效，更适合移动设备，让 Web 应用更快速载入。 2.4. jQuery mobile jQuery移动是一个基于html5的用户界面系统,为响应web站点和应用程序都可以访问所有的智能手机,平板电脑和桌面设备而设计。详情 2.5. Framework7 Framework7 是一个开源免费的框架可以用来开发混合移动应用（原生和HTML混合）或者开发 iOS &amp; Android 风格的WEB APP。也可以用来作为原型开发工具，可以迅速创建一个应用的原型。详情 Framework7 最主要的功能是可以使用HTML、CSS和JS来开发iOS7应用。Framework7 是完全免费开源的。 Framework7 并不能兼容所有的设备。她只专注于为 iOS 和 Google Material 设计提供最好的体验。 如果你想开发 iOS 或者 Android 混合应用（Phonegap）或者你想开发 iOS 和 Google Material 风格的WEB APP，那么Framework7将会是你的首选。 2.6. cube-ui（Vue）cube-ui 是由滴滴开源的基于 Vue.js 实现的移动端组件库。 详情 ● 质量可靠：由滴滴内部组件库精简提炼而来，历经考验，并且每个组件都有充分单元测试，为后续集成提供保障。● 体验极致：以迅速响应、动画流畅、接近原生为目标，在交互体验方面追求极致。● 标准规范：遵循统一的设计交互标准，高度还原设计效果；接口标准化，统一规范使用方式，开发更加简单高效。● 扩展性强：支持按需引入和后编译，轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。 2.7. Mint UI (Vue)基于 Vue.js 的移动端组件库 详情 2.8. Weex UI (Vue)一个基于 Weex 的富交互、轻量级、高性能的 UI 组件库 详情 2.9. Onsen UI(Vue, React, Angular)最偏亮高效的开发HTML5应用和WEB apps, 支持angular, vue ,react, 详情 3. PC端3.1. EasyUI easyui是一种基于jQuery的用户界面插件集合。easyui为创建现代化，互动，JavaScript应用程序，提供必要的功能。详情 使用easyui你不需要写很多代码，你只需要通过编写一些简单HTML标记，就可以定义用户界面。 easyui是个完美支持HTML5网页的完整框架。 easyui节省您网页开发的时间和规模。 easyui很简单但功能强大的。 3.2. Bootstrap 简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。详情 3.3. jQuery UI jQuery UI 是建立在 jQuery JavaScript 库上的一组用户界面交互、特效、小部件及主题。无论您是创建高度交互的 Web 应用程序还是仅仅向窗体控件添加一个日期选择器，jQuery UI 都是一个完美的选择。jQuery UI 包含了许多维持状态的小部件（Widget），因此，它与典型的 jQuery 插件使用模式略有不同。所有的 jQuery UI 小部件（Widget）使用相同的模式，所以，只要您学会使用其中一个，您就知道如何使用其他的小部件（Widget）。详情 3.4. SUI SUI 是一套基于bootstrap开发的前端组件库，同时她也是一套设计规范。通过SUI，可以非常方便的设计和实现精美的页面。详情 3.5. ZUI 一个基于 Bootstrap 深度定制开源前端实践方案，帮助你快速构建现代跨屏应用。详情 3.6. Plane UI HTML5 跨终端响应式前端界面框架详情 3.7. Semantic UI Semantic UI 是一款语义化设计的前端开源框架，其功能强大，使用简单，为设计师和开发师提供可复用的完美设计方案。详情 3.8. materialize 基于谷歌material design设计的框架详情 3.9. ElementUI （Vue）Element由饿了吗团队开源，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的组件库，提供了配套设计资源，帮助你的网站快速成型。详情 3.10. iviewui （Vue）一套基于 Vue.js 的高质量 UI 组件库 详情 3.11. ANT DESIGN (React)一套企业级的 UI 设计语言和 React 实现。https://ant.design/index-cn 提炼自企业级中后台产品的交互语言和视觉风格。 开箱即用的高质量 React 组件。 使用 TypeScript 构建，提供完整的类型定义文件。 基于 npm + webpack + dva 的企业级开发框架。 3.12. MDUIMDUI 是一套基于 Material Design 的前端框架。轻量级、多主题切换、响应式、无依赖。http://www.mdui.org/ 3.13. Amaze UI React (React)基于 React.js 开发的 Web 组件库 详情 3.14. Layui layui（谐音：类UI) 是一款采用自身模块规范编写的前端 UI 框架，遵循原生 HTML/CSS/JS 的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到 API 的每一处细节都经过精心雕琢，非常适合界面的快速开发。layui 首个版本发布于2016年金秋，她区别于那些基于 MVVM 底层的 UI 框架，却并非逆道而行，而是信奉返璞归真之道。准确地说，她更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。 详情 3.15. UIkit 轻量级模块化前端框架 详情 3.16. Vuetify (Vue)基于vue2的material风格组件化框架 详情 3.17. Semantic UI React(React)The official Semantic-UI-React integration. detail jQuery Free Declarative API Augmentation Shorthand Props Sub Components Auto Controlled State 3.18. element-react (React)element ui的react版本 详情 3.19. element-angular (angular)element ui的react版本 详情 3.20. NG-ZORRO (angular)这里是 Ant Design 的 Angular^5.0.0 实现，开发和服务于企业级后台产品。 详情 4. PC &amp; 移动端4.1. ZanUI (Vue) Vant ( \ˈvænt\ ) 是有赞前端团队基于有赞统一的规范实现的 Vue 组件库，提供了一整套 UI 基础组件和业务组件。 详情 48+ 个经过有赞线上业务检验的组件 单测覆盖率超过 90% 完善详实的 中英文文档 专门的设计师团队维护视觉规范，统一而优雅 支持 babel-plugin-import 支持 TypeScript]]></content>
      <tags>
        <tag>ui</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发常用工具网站]]></title>
    <url>%2Ffront-end-common-websit.html</url>
    <content type="text"><![CDATA[1. 性能测试 PageSpeed Insights 2. 查询浏览器支持: caniuse 3. 文档查询: W3C 4. 浏览器调试：chrome-devtools 5. 工具箱: bejson]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue+websocket+stompjs 实时监控坐席状态demo]]></title>
    <url>%2Fvue-ws-monitor-agent-status.html</url>
    <content type="text"><![CDATA[由于是前后端分离的demo, 程序的后端我不管，我只负责把前端做好，这只是个demo， 还有很多不完善的地方。 2018-01-09新增：后端的MQ事件结构现在也改了，该demo只能看看了。 html1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;link href="http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;/head&gt;&lt;body&gt;&lt;table class="table" id="event-queue"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;当前状态&lt;/th&gt; &lt;th&gt;状态改变时间&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;工号&lt;/th&gt; &lt;th&gt;分机号&lt;/th&gt; &lt;th&gt;对方号码&lt;/th&gt; &lt;th&gt;呼入数&lt;/th&gt; &lt;th&gt;呼出数&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="item in eventQueue"&gt; &lt;td&gt;&#123;&#123;item.agentStatus | transAgentStatus&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.agentStatusTime&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.userName&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.loginName&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.deviceId&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &lt;script src="http://cdn.bootcss.com/vue/1.0.26/vue.js"&gt;&lt;/script&gt; &lt;script src="js/websocket-suport.min.js"&gt;&lt;/script&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159var tm = (function()&#123; var App = function()&#123;&#125;; var app = App.prototype; var config = &#123; dest: 'http://xxx.xxx.xxx.xxx:58080/mvc/stomp', topic: '/topic/csta/namespace/testwdd2.com' // topic: '/topic/csta/device/8002@testwdd2.com' &#125;; var eventQueue = []; var vm = new Vue(&#123; el:'#event-queue', data:&#123; eventQueue: eventQueue &#125; &#125;); Vue.filter('transAgentStatus', function(status)&#123; switch(status)&#123; case 'NotReady': return '未就绪'; case 'WorkNotReady': return '话后处理状态'; case 'Idle': return '就绪'; case 'OnCallIn': return '呼入通话'; case 'OnCallOut': return '呼出通话'; case 'Logout': return '登出'; case 'Ringing': return '振铃'; case 'OffHook': return '摘机'; case 'CallInternal': return '内部通话'; case 'Dailing': return '外线已经振铃'; case 'Ringback': return '回铃'; case 'Conference': return '会议'; case 'OnHold': return '保持'; case 'Other': return '其他'; &#125; return ''; &#125;); /** * [render description] * @Author Wdd * @DateTime 2016-12-26T16:06:16+0800 * @param &#123;[string]&#125; tpl [模板字符串] * @param &#123;[object]&#125; data [data对象] * @return &#123;[string]&#125; [渲染后的字符串] */ app.render = function(tpl,data)&#123; var re = /&#123;&#123;([^&#125;]+)?&#125;&#125;/g; while(match = re.exec(tpl))&#123; tpl = tpl.replace(match[0],data[match[1]] || ''); &#125; return tpl; &#125;; app.initWebSocket = function(dest, topic)&#123; dest = dest || config.dest; topic = topic || config.topic; var socket = new SockJS(dest); var ws = Stomp.over(socket); ws.connect(&#123;&#125;, function(frame) &#123; ws.subscribe(topic, function(event) &#123; // var eventInfo = JSON.parse(event.body); app.handerEvent(JSON.parse(event.body)); &#125;); &#125;, function(frame) &#123; console.log(frame); console.error(new Date() + 'websocket失去连接'); &#125;); &#125;; /** * [findAgentIndex description] * @Author Wdd * @DateTime 2016-12-28T10:34:13+0800 * @param &#123;[string]&#125; agentId [description] * @return &#123;[int]&#125; [description] */ app.findAgentIndex = function(agentId)&#123; for(var i = eventQueue.length - 1; i &gt;= 0; i--)&#123; if(eventQueue[i].agentId === agentId)&#123; return i; &#125; &#125; return -1; &#125;; /** * [handerEvent 处理websocket事件] * @Author Wdd * @DateTime 2016-12-28T10:33:03+0800 * @param &#123;[object]&#125; data [description] * @return &#123;[type]&#125; [description] */ app.handerEvent = function(data)&#123; if(data.eventType === 'CallEvent')&#123; return; &#125; if(!data.eventSrc)&#123; return; &#125; var eventItem = &#123; agentStatus: '', eventName: data.eventName, agentId: '', loginName: '', userName: '', deviceId: data.deviceId, agentStatusTime: '' &#125;; var agent = data.eventSrc.agent || ''; if(agent)&#123; eventItem.agentId = agent.agentId; eventItem.loginName = agent.loginName; eventItem.userName = agent.userName; eventItem.agentStatus = agent.agentStatus; eventItem.agentStatusTime = agent.agentStatusTime; &#125; // 针对登出事件的agentId在外层 else if(data.agentMode)&#123; eventItem.agentStatus = data.agentMode; eventItem.agentId = data.agentId; &#125; else if(data.agentStatus)&#123; eventItem.agentStatus = data.agentStatus; &#125; if(!eventItem.agentId)&#123; return; &#125; var itemIndex = app.findAgentIndex(eventItem.agentId); // 新的座席加入 if(itemIndex === -1)&#123; eventQueue.push(eventItem); &#125; // 更新已有座席的状态 else&#123; eventQueue[itemIndex].agentStatus = eventItem.agentStatus; eventQueue[itemIndex].agentStatusTime = eventItem.agentStatusTime; eventQueue[itemIndex].eventName = eventItem.eventName; &#125; &#125;; return new App();&#125;)(); 打开控制台，输入tm.initWebsocket()后，websocket连接正常。 之后坐席状态改变，可以看到有事件推送过来。 看下整个页面： 最后，这个小小的监控如果用jQuery写，也可以，不过就是太坑了，每次都要去找到Dom元素，再更新DOM，用了Vue这类的框架，页面的dom操作完全不用关心了，真是太舒服了。\(^o^)/ 1. 关于stomp的重连程序后服务端使用RabbitMQ这里我直接引用我的另一个项目的部分代码，这个没有使用SockJS， 直接使用浏览器原生的WebSocket。重连的原理很简单，就是检测到断开时，去调用我的reconnectWs方法，这里我也做了重连的次数限制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109initWebSocket: function(callback, errorCallback) &#123; callback = callback || function()&#123;&#125;; if(ws &amp;&amp; ws.connected)&#123; return; &#125; Config.isManCloseWs = false; var url = Config.wsProtocol + Config.SDK + Config.eventPort + Config.eventBasePath + "/websocket"; if(typeof WebSocket != 'function')&#123; alert('您的浏览器版本太太太老了，请升级你的浏览器到IE11，或使用任何支持原生WebSocket的浏览器'); return; &#125; try&#123; var socket = new WebSocket(url); &#125; catch(e)&#123; console.log(e); return; &#125; var wsHeartbeatId = ''; ws = Stomp.over(socket); if(!Config.useWsLog)&#123; ws.debug = null; &#125; ws.connect(&#123;&#125;, function(frame) &#123; Config.currentReconnectTimes = 0; var dest = Config.newWsTopic + env.loginId.replace(/\./g,'_'); var lastEventSerial = ''; ws.subscribe(dest, function(event) &#123; var eventInfo = &#123;&#125;; try&#123; eventInfo = JSON.parse(event.body); delete eventInfo.params; delete eventInfo._type; delete eventInfo.topics; &#125; catch(e)&#123; console.log(e); return; &#125; if(lastEventSerial === eventInfo.serial)&#123; util.error('Error: event repeat sent !'); return; &#125; else&#123; lastEventSerial = eventInfo.serial; &#125; if(Config.useEventLog)&#123; util.debugout.log(' ' + JSON.stringify(eventInfo)); &#125; eventHandler.deliverEvent(eventInfo); &#125;); callback(); &#125;, function(frame) &#123; // websocket upexpected disconnected // maybe network disconnection, or browser in offline // this condition will emit wsDisconnected event if(Config.isManCloseWs)&#123;return;&#125; errorCallback(); util.log(frame); util.error(new Date() + 'websocket disconnect'); // clearInterval(wsHeartbeatId); if(Config.currentReconnectTimes &lt; Config.maxReconnectTimes)&#123; Config.currentReconnectTimes++; util.reconnectWs(); &#125; else&#123; var errorMsg = &#123; eventName: 'wsDisconnected', msg: 'websocket disconnect' &#125;; wellClient.ui.main(&#123; eventName:'wsDisconnected' &#125;); util.debugout.log('&gt;&gt;&gt; websocket disconnect'); wellClient.triggerInnerOn(errorMsg); &#125; &#125;); &#125;, reconnectWs: function()&#123; setTimeout(function()&#123; util.log('&gt;&gt;&gt; try to reconnect'); util.debugout.log('&gt;&gt;&gt; try to reconnect'); util.initWebSocket(function()&#123;&#125;,function()&#123;&#125;); &#125;, Config.timeout * 1000); &#125;, 2. 参考 STOMP Over WebSocket]]></content>
      <tags>
        <tag>stompjs</tag>
        <tag>Vue</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自从装了windows神器，再也不用羡慕mac了]]></title>
    <url>%2Fwindows-powerful-tools.html</url>
    <content type="text"><![CDATA[1. 命令行神器1.1. GOW Gow（Gnu On Windows）是Cygwin的轻量级替代品。 它使用一个方便的NSIS安装程序，安装超过100个非常有用的开源UNIX应用程序，编译为本机win32二进制文件。 它被设计为尽可能小，大约18 MB，而不是Cygwin，它可以运行超过100 MB根据选项。 1.2. 强烈推荐 ConEmu 非常强大，可以在里面愉快的ctrl+v,ctrl+c用过你才知道好用https://conemu.github.io/ 2. 搜索神器2.1. Wox Windows下一款最接近 Alfred 的软件启动/文件搜索利器 2.2. Everything 快速批量查找文件的利器 3. 包管理神器4. Chocolatey 安装软件再也不用烦恼教程 5. 健康管理神器6. f.lux 有没有注意到人们在夜间发短信的怪异蓝色发光？或者醒来准备写下一个伟大的想法，并被你的电脑屏幕蒙蔽？白天，电脑屏幕看起来很好，他们的设计看起来像太阳。但是，在晚上9点，晚上10点或凌晨3点，你可能不应该看太阳。f.lux修复这个：它使你的电脑显示器的颜色适应一天的时间，在夜间温暖和白天喜欢阳光。甚至有可能你因为你的电脑而停滞太晚。你可以使用f.lux因为它使你睡得更好，或者你可以只使用它，只是因为它使你的电脑看起来更好。 7. 谷歌浏览器插件神器7.1. 强烈推荐vimium 速度起飞，只用键盘就可以完全操纵谷歌浏览器 7.2. shortKeys vimium的快捷键其实已经足够多了，但是如果你想有更多自定义的快捷键，例如：关闭右侧的标签页，这个快捷键。你可以试试shortKeys。唯一遗憾的是，这里面也没有关闭其他标签页的快捷键，如果你知道有哪些工具可以做到，麻烦请告诉我。 7.3. infinity新标签页 8. 参考 http://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/ http://www.jeffjade.com/2015/10/19/2015-10-18-Efficacious-win-software/ https://www.zhihu.com/question/22919326 https://blogs.msdn.microsoft.com/scott_hanselman/2013/07/31/windows/]]></content>
      <tags>
        <tag>windows</tag>
        <tag>神器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发起Ajax请求当页面onunload]]></title>
    <url>%2Fsend-ajax-when-page-unload.html</url>
    <content type="text"><![CDATA[0.1. 同步Ajax 这种需求主要用于当浏览器关闭，或者刷新时，向后端发起Ajax请求。 123window.onunload = function()&#123; $.ajax(&#123;url:"http://localhost:8888/test.php?", async:false&#125;);&#125;; 使用async：false参数使请求同步（默认是异步的）。 同步请求锁定浏览器，直到完成。 如果请求是异步的，页面只是继续卸载。 它足够快，以至于该请求甚至没有时间触发。服务端很可能收不到请求。 0.2. navigator.sendBeacon优点：简洁、异步、非阻塞缺点：这是实验性的技术，并非所有浏览器都支持。其中IE和safari不支持该技术。 示例：12345window.addEventListener('unload', logData, false);function logData() &#123; navigator.sendBeacon("/log", analyticsData);&#125; 参考：http://stackoverflow.com/questions/1821625/ajax-request-with-jquery-on-page-unload参考：https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon]]></content>
      <tags>
        <tag>ajax</tag>
        <tag>onunload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongo DB增删改查命令概要]]></title>
    <url>%2Fmongodb-api-overview.html</url>
    <content type="text"><![CDATA[1. 列出并选用1.1. 列出所有数据库123&gt; show dbs local 0.000GBmyblog 0.000GB 1.2. 使用某个数据库12&gt; use myblogswitched to db myblog 1.3. 列出所有集合123456&gt; show collectionsarticlesreplicationColletionsessionsuserswangduanduan 2. 插入数据 insert(value)1234567// 在已经存在的集合中插入数据&gt; db.users.insert(&#123;name:'hh',age:23&#125;)Inserted 1 record(s) in 43ms// 在不存在的集合中插入数据,集合不存在则自动创建集合并插入&gt; db.students.insert(&#123;name:'hh',age:23&#125;)Inserted 1 record(s) in 72ms 3. 查询 find(option)3.1. 查询集合里所有的文档12345678910111213141516171819202122232425262728&gt; db.users.find()/* 1 */&#123; "_id" : ObjectId("583e908453be942d0c5419dc"), "login_name" : "wangduanduan", "password" : "wrong age"&#125;/* 2 */&#123; "_id" : ObjectId("583ed2a5cc9a937db049616d"), "login_name" : "hh", "password" : "sdfsdf"&#125;/* 3 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125;/* 4 */&#123; "_id" : ObjectId("583fb707b12f8b7a7aa37573"), "name" : "hh", "age" : 23.0&#125; 3.2. 按条件查询文档1234567&gt; db.users.find(&#123;name:'wangduanduan'&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125; 注意12345678910111213// 这是错的，查不到结果&gt; db.users.find(&#123;_id:'583fb2e9b12f8b7a7aa37572'&#125;)Fetched 0 record(s) in 1ms// 这是正确的&gt; db.users.find(&#123;_id:ObjectId('583fb2e9b12f8b7a7aa37572')&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125; 3.3. 查询集合内文档的个数12&gt; db.users.count()4 3.4. 比较运算符 $gt: 大于 $gte: 大于等于 $lt: 小于 $lte: 小于等于 $ne: 不等于 123456789// 查询用户里年龄大于30岁的人， 其他条件以此类推&gt; db.user.find(&#123;age:&#123;$gt:30&#125;&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125; 3.5. 逻辑运算符3.5.1. 与12345678// 查询名字是wangduanduan,age=34的用户&gt; db.users.find(&#123;name:'wangduanduan',age:34&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125; 3.5.2. $in 或12345678// 查询名字是wangduanduan,或hh的用户&gt; db.users.find(&#123;name:&#123;$in:['wangduanduan','hh']&#125;&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125; 3.5.3. $nin 非123456789101112131415// 查询名字不是wangduanduan或者hh的用户&gt; db.users.find(&#123;name:&#123;$nin:['wangduanduan','hh']&#125;&#125;)/* 1 */&#123; "_id" : ObjectId("583e908453be942d0c5419dc"), "login_name" : "wangduanduan", "password" : "wrong age"&#125;/* 2 */&#123; "_id" : ObjectId("583ed2a5cc9a937db049616d"), "login_name" : "hh", "password" : "sdfsdf"&#125; 3.6. 正则匹配123456789101112131415// 查询名字是中含有duan的用户&gt; db.users.find(&#123;name:/duan/&#125;)/* 1 */&#123; "_id" : ObjectId("583fb2e9b12f8b7a7aa37572"), "name" : "wangduanduan", "age" : 34.0&#125;/* 2 */&#123; "_id" : ObjectId("583fc919b12f8b7a7aa37575"), "name" : "wangduanduan", "age" : 45.0&#125; 3.7. 大招$where1234// 返回含有login_name字段的文档db.getCollection('users').find(&#123;$where:function()&#123; return !!this.login_name;&#125;&#125;) 4. 更新 update();4.1. 整体更新12&gt; db.users.update(&#123;login_name:'wangduanduan'&#125;,&#123;name:'heihei',age:34&#125;)Updated 1 existing record(s) in 116ms 4.2. $set 局部更新12// 只是将用户年龄设置成101&gt; db.users.update(&#123;name:'wangduanduan'&#125;,&#123;$set:&#123;age:101&#125;&#125;) 4.3. $inc12// 将用户年龄增加1岁，如果文档没有age这个字段，则会增加这个字段&gt; db.users.update(&#123;name:'wangduanduan'&#125;,&#123;$inc:&#123;age:1&#125;&#125;) 4.4. upsert操作12345678910// 如果查不到文档，则增加文档&gt; db.users.update(&#123;name:'nobody'&#125;,&#123;$inc:&#123;age:1&#125;&#125;,true)Updated 1 new record(s) in 3ms/* 6 */&#123; "_id" : ObjectId("583fd20f2cfa6a4817c4171c"), "name" : "nobody", "age" : 1.0&#125; 4.5. 批量更新12// upadate 的第四个参数设置成true的时候，就会批量更新&gt; db.users.update(&#123;name:'wangduanduan'&#125;,&#123;$set:&#123;age:1891&#125;&#125;,false,true) 5. 删除12345// 删除某些文档db.person.remove(&#123;"name":"joe"&#125;)// 删除整个集合db.person.remove()]]></content>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git化文档管理]]></title>
    <url>%2Fgit-manager-docs.html</url>
    <content type="text"><![CDATA[1. 产品概况2. 基本要求 所有文档的格式采用markdown 文档使用Git进行 3. 前提准备4. 从MVC角度分析需求 模型层：资源最小数据集定义，功能定义 控制器：负责请求处理。例如增删改查 视图层：资源展现与交互 对于前端的需求是：视图层 + 模型层对于后端的需求是：控制器 + 模型层 5. 前端需求文档6. 实施7. 资源下载8. 参考文献 产品经理如何绕开API的坑]]></content>
      <tags>
        <tag>未完成</tag>
        <tag>git</tag>
        <tag>gitlab</tag>
        <tag>gow</tag>
        <tag>ConEmu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年我的阅读计划]]></title>
    <url>%2F2018-reading-plan.html</url>
    <content type="text"><![CDATA[要量化阅读 要坚持不懈 多看每本书每天每次阅读至少10页 kindle每本书每天每次阅读至少1% 我的2018年总书单 书名 来源 状态 读后感 浪潮之巅上下册 纸质 读完 新生 七年就是一辈子 多看 读完 大数据 多看 读完 怪诞经济学 多看 读完 专业主义 多看 读完 怪诞心理学 多看 读完 乌合之众 kindle 读完 人性的弱点 多看 读完 沉默的大多数 kindle 读完 生命不息，折腾不止 kindle 读完 动物农场 kindle 读完 厚黑学 kindle 读完 python学习手册 kindle 废话太多，看了快一半，不看了 python编程从入门到实战 kindle 读完 图解HTTP kindle 读完 图解TCP IP 多看 读完 编程之美 kindle 读完 一只特立独行的猪 kindle 读完 利用python进行数据分析 kindle 推迟 流畅的python kindle 推迟 富爸爸 穷爸爸 kindle 读完 python语言及其应用 kindle 读完 给投资新手的极简股票课 kindle 读完 前端开发手册2017 kindle 读完 国富论 kindle 20% 停止 阮一峰 未来世界的幸存者 网络 读完 上帝会掷骰子吗？量子物理史话 kindle 读完 编写可读性代码的艺术 kindle 读完 程序员的数学 kindle 读完 深入浅出react kindle 52% 停止 大型网站技术架构 kindle 读完 webkit技术内幕 kindle 在读 经济史的趣味 kindle 在读 30年后，你那什么养活自己 kindle 在读 富爸爸财务自由之路 kindle 在读 小狗钱钱 kindle 在读 you dont konw js 英文版 kindle 在读 MySql必知必会 kindle 在读 失控 多看 在读 魔鬼经济学 多看 在读 设计心理学 多看 把时间当做朋友 多看 三体 多看 自控力 kindle 人类简史 kindle 影响力 kindle 阮一峰 前方的路 网络 人类简史 kindle 韦伯英语字典 纸质书 第12周 0218-0324 ed 书名 周一 周二 周三 周四 周五 周六 周日 失控1573 812 822 832 844 863 874 891 魔鬼经济学 698 710 721 735 767 786 810 数学之美 2章 3章 null null null null null 韦伯英语字典 null null null null null null null 乌合之众 79% 80% 83% 88% 100% null null 国富论 17% 18% 19% 20%done null null null 编程之美 69% 74% 81% 100% null null null 富爸爸 财务自由之路 17% 19% 27% 29% 35% 38% 45% 深入浅出react redux 37% 38% 41% 52%done null null null 大型网站技术架构 60% 63% 72% 89% 100% null null webkit技术内幕 17% 18% 21% 27% 37% 38% 44% 经济史的趣味 18% 19% 21% 24% 28% 30% 33% 30年后，你那什么养活自己 null null null null 15% 21% 24% 小狗钱钱 null null null null 1% 8% 20% you dont konw js null null null null 2% 3% 4% 第11周 0212-0318 ed 书名 周一 周二 周三 周四 周五 周六 周日 失控1573 588 624 648 713 751 772 800 乌合之众 39% 45% 50% 51% 57% 73% 78% 国富论 10% 11% 12% 13% 14% 15% 16% 魔鬼经济学 41 66 352 493 593 650 670 上帝会掷骰子吗？量子物理史话 60% 65% 68% 69% 80% 100% 数学之美 1章 编程之美 0% 7% 13% 28% 64% 富爸爸 财务自由之路 0% 10% 14% 16% 深入浅出react redux 13% 18% 30% 31% 34% 35% 36% 大型网站技术架构 0% 11% 15% 40% 55% webkit技术内幕 0% 8% 14% 16% 经济史的趣味 0% 12% 15% 17% python语言及其应用 28% 31% 100% 编写可读性代码的艺术 57% 62% 100% 程序员的数学 0% 100% 浪潮之巅 22章 23章 24章 读完 穷爸爸富爸爸 90% 100% 第10周 0205-0311 ed 书名 周一 周二 周三 周四 周五 周六 周日 失控1573 460 477 509 520 532 547 564 乌合之众 18% 19% 22% 24% 27% 33% 36% 上帝会掷骰子吗？量子物理史话 40% 41% 45% 46% 48% 54% 58% 穷爸爸富爸爸 61% 62% 69% 71% 75% 79% 84% 浪潮之巅 18章 19章 20章 21章 python语言及其应用 15% 17% 20% 22% 24% 25% 27% 国富论 3% 4% 5% 6% 7% 8% 9% 编写可读性代码的艺术 16% 19% 26% 31% 33% 48% 深入浅出react redux 0% 3% 7% 9% 12% 未来世界的幸存者 0% 100% 给投资新手的极简股票课 64% 73% 87% 100% 前端开发手册2017 60% 89% 100% 怪诞心理学546 455 477 546读完 人性的弱点490 432 455 490读完 第9周 0226-0304 ed 书名 周一 周二 周三 周四 周五 周六 周日 人性的弱点490 341 350 360 370 380 392 411 怪诞心理学546 360 370 380 390 400 422 430 专业主义378 270 280 290 300 310 322 378读完 失控1573 381 390 400 410 420 437 449 图解TCP IP 907 670 760 907 读完 一只特立独行的猪 23% 100% 读完 乌合之众 7% 8% 9% 10% 11% 14% 17% 上帝会掷骰子吗？量子物理史话 4% 5% 6% 7% 8% 29% 36% 穷爸爸富爸爸 28% 29% 31% 33% 37% 44% 52% 厚黑学 56% 100% 读完 浪潮之巅 第14章 第15章 第16章 第17章 第18章 python语言及其应用 7% 12% 给投资新手的极简股票课 40% 51% 前端开发手册2017 22% 29% 国富论 1% 2% 第8周 0219-0225 ed 书名 周一 周二 周三 周四 周五 周六 周日 人性的弱点490 250 260 270 280 294 310 330 怪诞心理学546 250 260 270 280 290 308 325 专业主义378 150 160 170 180 190 202 256 失控1573 291 300 310 320 330 346 367 图解TCP IP 907 443 484 510 540 570 600 630 一只特立独行的猪 17% 20% 乌合之众 1% 4% 上帝会掷骰子吗？量子物理史话 1% 2% 图解http 60% 100% 厚黑学 33% 53% 穷爸爸富爸爸 14% 22% 第7周 0212-0218 ed 书名 周一 周二 周三 周四 周五 周六 周日 人性的弱点490 150 172 185 197 209 222 232 怪诞心理学546 140 158 170 189 209 225 240 专业主义378 50 75 92 104 115 126 138 失控1573 200 218 230 242 256 267 280 图解TCP IP 907 16 20 24 27 34 38 412 第6周 0205-0211 ed 书名 周一 周二 周三 周四 周五 周六 周日 新生 七年就是一辈子917-19 900ok 917ok 怪诞经济学539-11 450ok 500ok 539ok 大数据851-17 750ok 800ok 851ok 人性的弱点490-10 50ok 100ok 110ok 120ok 130ok 140ok 怪心理学546 50ok 100ok 110ok 120ok 130ok 专业主义378 10ok 20ok 30ok 40ok 失控1573 50ok 100ok 150ok 160ok 170ok 180ok 190ok 第5周 0129-0204 ed 页数基于多看阅读 书名 周一 周二 周三 周四 周五 周六 周日 新生 七年就是一辈子917-19 550 ok 600 ok 650 ok 700ok 750ok 800ok 850ok 怪诞经济学539-11 250ok 300ok 350ok 400ok 大数据851-17 400 ok 450 ok 500 ok 550ok 600ok 650ok 700ok 第4周 0122-0128 ed 备注：明朝那些事儿，看到抗日援朝那部分，实在是看不下去啦，索性不看了 页数基于多看阅读 书名 周一 周二 周三 周四 周五 周六 周日 新生 七年就是一辈子 200 ok 250 ok 300 ok 350 ok 400 ok 450 ok 500 ok 明朝哪些事儿 4050 ok 4100 ok 4150 ok 4200 ok 4250 4300 4350 大数据 50 ok 100 ok 150 ok 200 ok 250 ok 300 ok 350 ok]]></content>
      <tags>
        <tag>reading</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要成为某个技术的死忠粉]]></title>
    <url>%2Fdo-not-be-big-fans.html</url>
    <content type="text"><![CDATA[1. 我对Vue与React的态度2. 成年人权衡利弊，小孩子才说好坏3. 你只不过在找借口罢了4. 不要成为某个技术的死忠粉]]></content>
      <tags>
        <tag>未完成</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Think With Stream]]></title>
    <url>%2Fthink-with-stream.html</url>
    <content type="text"><![CDATA[1. 流的存在 2. 流的规则3. 终极的流]]></content>
      <tags>
        <tag>未完成</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode常用快捷键集锦]]></title>
    <url>%2Fvscode-commom-shortcuts.html</url>
    <content type="text"><![CDATA[功能 键 多行选中 alt+shift+鼠标拖动 打开terminal ctrl + ` 行上下移动 atlt + 上或下箭头 向下复制当前行 shift alt + 下箭头 向上复制当前行 shift alt + 上箭头 f1 打开命令面板 开关书签 com + option + k 书签跳转 com + option + j or l]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Commit Message 格式与类型分类]]></title>
    <url>%2Fcommit-type-summary.html</url>
    <content type="text"><![CDATA[1. 缩写含义说明 类型 描述 feat 新增feature fix 修复bug docs 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等 style 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑 refactor 代码重构，没有加新功能或者修复bug perf 优化相关，比如提升性能、体验 test 测试用例，包括单元测试、集成测试等 chore 改变构建流程、或者增加依赖库、工具等 revert 回滚到上一个版本 tips 增加一些提示信息，例如错误提示 2. 格式示例格式： type [id] message 1git commit -am "fix 2038 解决点击无反应的问题" 3. 小技巧3.1. 使用单引号多行commit注意： window下务必使用git bash。 123git commit -am 'fix 2093 alsdfj laksdasdflka sdflkasdf ' 4. 参考 project-guidelines Commit message 和 Change log 编写指南 cz-cli Git commit message和工作流规范]]></content>
      <tags>
        <tag>git</tag>
        <tag>git-commit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记：浪潮之巅]]></title>
    <url>%2Fread-notes-on-top-of-tides.html</url>
    <content type="text"><![CDATA[1. 互联网的金门大桥： 思科1.1. 关于情书的八卦思科的创始人刚开始是男女朋友关系，他们是斯坦福大学不同计算机中心的主管。两人经常用计算机写情书，但是呢，不同的网络之间的设备协议不同，互不兼容，导致了情书传递非常不方便。于是他们就发明了一种能够支持各种网络设备，各种协议的路由器，即多协议路由器。 1.2. 对立与兼容大公司都是想打败对手，而不是做出兼容。所以思科的多协议路由器能够有生存的机会。]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>未完成</tag>
        <tag>浪潮之巅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无坚不摧：打造极大提高工作效率的装备库]]></title>
    <url>%2Ftool-improve-work-efficiency.html</url>
    <content type="text"><![CDATA[1. Git Bash 2. Gow 1 2 3 4 5 6 7 8 9 10 awk basename bash bc bison bunzip2 bzip2 bzip2 bzip2recover cat chgrp chmod chown chroot cksum clear cp csplit curl cut dc dd df diff diff3 dirname dos2unix du egrep env expand expr factor fgrep flex fmt fold gawk gdbm3 gfind gow grep gsar gsort gzip head history5 hostid hostname id indent install join jwhois less lesskey libcurl libeay32 libiconv-2 libidn-11 libintl-2 libintl3 libssl32 ln ls m4 make md5sum mkdir mkfifo mknod msys-1 msys-regex-1 msys-termcap-0 mv nano ncftp nl od pageant paste patch pathchk pcre3 plink pr printenv printf pscp psftp putty puttygen pwd readline5 regex2 rm rmdir scp sdiff sed seq sftp sha1sum shar sleep split ssh ssleay32 su sum sync tac tail tar tee test touch tr uname unexpand uniq unix2dos unlink unrar unrar3 unshar uudecode uuencode vim wc wget whereis which whoami xargs yes zip zip32z64 3. ConEmu4. gerp5. Chrome Extensions5.1. vimium5.2. Multi-highlight5.3. Restlet Client - REST API Testing5.4. Tampermonkey6. Web Tools6.1. jsonviewernewhttps://www.bejson.com/jsonviewernew/ 6.2. regex1016.3. Linux 工具快速教程]]></content>
      <tags>
        <tag>未完成</tag>
        <tag>git</tag>
        <tag>gow</tag>
        <tag>conemu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码工作法]]></title>
    <url>%2Fhttp-status-code-work-method.html</url>
    <content type="text"><![CDATA[1. 概念类比1234Title:连接建立的过程客户主机-&gt;服务器主机: 连接请求（SYN=1,seq=client_isn） 服务器主机-&gt;客户主机: 授予连接（SYN=1,seq=client_isn）\n ack=client_isn+1客户主机-&gt;服务器主机: 确认（SYN=0,seq=client_isn+1）\nack=server_isn+1 2. 工作状态码分类 分类 分类描述 100 已经开始开发该项目，但是还未完成，需要继续开发 200 完成任务 301 任务被转给其他人处理 400 任务描述不清晰，导致无法继续工作，需要重新设计需求 500 任务需要依赖其他服务，但是其他服务无法提供服务，正在等待]]></content>
      <tags>
        <tag>http</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdwon、笔记、编辑器与缓存]]></title>
    <url>%2Fthink-about-markdown-and-editor.html</url>
    <content type="text"><![CDATA[1. 笔记有哪些种类？ 所有人可读：所有人都可以看的，这种类型的笔记适合作为博客 部分可读：这种不适合作为博客，需要一些约束条件，被授权的人才有资格去读 仅自己可读：这种类型的往往都是个人隐私，不需要和别人分享 2. 为什么要记笔记？你需要的东西网上都有，搜索引擎都能找到，那么你为什么还要记笔记？ 节约效率与缓存：搜索引擎并不一定能够找到你需要的数据，一旦找到，最好可以缓存起来，作为笔记，下次查找的效率往往会提高非常多；另外，这次可以找到的内容，下次同样的位置，也可能文档已经被删除。 知识经验积累: 原创的内容在互联网上是搜不到的，所以需要记录，积累知识，内化吸收 生活感情记录: 作为一种情绪的记录 3. markdown, 笔记， 编辑器之间有什么关系markdown是笔记的一种形式，编辑器来制作笔记。 4. 对于编辑器的要求 可以编辑markdown 可以导出pdf 可以云端备份]]></content>
      <tags>
        <tag>未完成</tag>
        <tag>markdown</tag>
        <tag>editor</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git合并上游仓库即同步fork后的仓库]]></title>
    <url>%2Ffork-sync-learn.html</url>
    <content type="text"><![CDATA[1. 前提说明 仓库A: http://gitlab.tt.cc:30000/fe/omp.git 仓库B: 仓库Bfork自仓库A, 仓库A的地址是：http://gitlab.tt.cc:30000/wangdd/omp.git 某一时刻，仓库A更新了。仓库B需要同步上游分支的更新。 2. 本地操作12345678910111213141516171819202122232425262728293031323334// 1 查看远程分支➜ omp git:(master) git remote -vorigin http://gitlab.tt.cc:30000/wangdd/omp.git (fetch)origin http://gitlab.tt.cc:30000/wangdd/omp.git (push)// 2 添加一个远程同步的上游仓库➜ omp git:(master) git remote add upstream http://gitlab.tt.cc:30000/fe/omp.git➜ omp git:(master) git remote -vorigin http://gitlab.tt.cc:30000/wangdd/omp.git (fetch)origin http://gitlab.tt.cc:30000/wangdd/omp.git (push)upstream http://gitlab.tt.cc:30000/fe/omp.git (fetch)upstream http://gitlab.tt.cc:30000/fe/omp.git (push)// 3 拉去上游分支到本地，并且会被存储在一个新分支upstream/master➜ omp git:(master) git fetch upstreamremote: Counting objects: 4, done.remote: Compressing objects: 100% (4/4), done.remote: Total 4 (delta 2), reused 0 (delta 0)Unpacking objects: 100% (4/4), done.From http://gitlab.tt.cc:30000/fe/omp * [new branch] master -&gt; upstream/master// 4 将upstream/master分支合并到master分支，由于我已经在master分支，此处就不在切换到master分支➜ omp git:(master) git merge upstream/masterUpdating 29c098c..6413803Fast-forward README.md | 1 + 1 file changed, 1 insertion(+)// 5 查看一下，此次合并，本地有哪些更新➜ omp git:(master) git log -p// 6 然后将更新推送到仓库B➜ omp git:(master) git push 3. 总结通过上述操作，仓库B就同步了仓库A的代码。整体的逻辑就是将上游分支拉去到本地，然后合并到本地分支上。就这么简单。]]></content>
      <tags>
        <tag>git</tag>
        <tag>fork</tag>
        <tag>合并上游分支</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitbash生存指南 之 git常用命令与oh-my-zsh常用缩写]]></title>
    <url>%2Fgit-commom-cmds.html</url>
    <content type="text"><![CDATA[如果命令行可以解决的问题，就绝对不要用GUI工具。快点试用Git bash吧， 别再用TortoiseGit了。 1. 必会8个命令下面的操作都是经常使用的，有些只需要做一次，有些是经常操作的 git命令虽然多，但是经常使用的不超过8个。 命令 执行次数 说明 git clone http://sdfjslf.git 每个项目只需要执行一次 //克隆一个项目 git fetch origin round-2 每个分支只需要执行一次 //round-2分支在本地不存在，首先要创建一个分支 git checkout round-2 多次 // 切换到round-2分支 git branch --set-upstream-to=origin/round-2 每个分支只需要执行一次 // 将本地round-2分支关联远程round-2分支 git add -A 每次增加文件都要执行 // 在round-2下创建了一个文件, 使用-A可以添加所有文件到暂存区 git commit -am &quot;我增加了一个文件&quot; 每次提交都要执行 // commit git push 每次推送都要执行 //最好是在push之前，使用git pull拉去远程代码到本地，否则有可能被拒绝 git pull 每次拉去都要执行 拉去远程分支代码到本地并合并到当前分支 2. 常用的git命令假设你在master分支上 12345// 将本地修改后的文件推送到本地仓库git commit -am '修改了一个问题'// 将本地仓库推送到远程仓库git push 2.1. 状态管理2.1.1. 状态查看查看当前仓库状态1git status 2.2. 分支管理2.2.1. 分支新建基于当前分支，创建test分支12345678// 创建dev分支git checkout dev// 创建dev分支后，切换到dev分支git checkout -b dev // 以某个commitId为起点创建分支git checkout -b new-branch-name commit-id 2.2.2. 分支查看查看远程分支： git branch -r 12345678// 查看本地分支git branch// 查看远程分支git branch -r// 查看所有分支git branch -a 2.2.3. 分支切换切换到某个分支: git checkout 0.10.7123&gt; git checkout 0.10.7Branch 0.10.7 set up to track remote branch 0.10.7 from origin.Switched to a new branch '0.10.7' 2.2.4. 分支合并将master分支合并到0.10.7分支: git merge123456789101112&gt; git merge masterMerge made by the 'recursive' strategy. public/javascripts/app-qc.js | 83 +++++++++++++++++++++++++-- views/menu.html | 1 + views/qc-template-show-modal.html | 114 ++++++++++++++++++++++++++++++++++++++ views/qc-template.html | 7 ++- 4 files changed, 198 insertions(+), 7 deletions(-) create mode 100644 views/qc-template-show-modal.html// 有时候只想合并某次commit到当前分支，而不是合并整个分支，可以使用 cherry-pick 合并git cherry-pick commmitId 2.2.5. 分支删除12345// 删除远程dev分支git push --delete origin dev// 删除本地dev分支git branch -D dev 2.2.6. 拉取本地不存在的远程分支123456789101112// 假设现在在master分支， 我需要拉去远程的dev分支到本地// 拉取远程分支到本地git fetch origin dev// 切换到dev分支git checkout dev// 本地dev分支关联远程dev分支, 如果不把本地dev分支关联远程dev分支，则执行git pull和git push命令时会报错git branch --set-upstream-to=origin/dev// 然后你就可以在dev分支上编辑了 2.3. 版本对比12345678// 查看尚未暂存的文件更新了哪些部分git diff// 查看某两个版本之间的差异git diff commitID1 commitID2 // 查看某两个版本的某个文件之间的差异git diff commitID1:filename1 commitID2:filename2 2.4. 日志查看12git log git short-log 3. oh-my-zsh中常用的git缩写12345678910111213141516171819202122alias ga='git add'alias gb='git branch'alias gba='git branch -a'alias gbd='git branch -d'alias gcam='git commit -a -m'alias gcb='git checkout -b'alias gco='git checkout'alias gcm='git checkout master'alias gcp='git cherry-pick'alias gd='git diff'alias gfo='git fetch origin'alias ggpush='git push origin $(git_current_branch)'alias ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'alias glgp='git log --stat -p'alias gm='git merge'alias gp='git push'alias gst='git status'alias gsta='git stash save'alias gstp='git stash pop'alias gl='git pull'alias glg='git log --stat'alias glgp='git log --stat -p' oh-my-zsh git命令缩写完整版 4. 参考文献 git 命令参考 《Pro Git 中文版》 廖雪峰 git教程 猴子都能懂的GIT入门]]></content>
      <tags>
        <tag>git</tag>
        <tag>oh-my-zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令使用场景总结]]></title>
    <url>%2Flinux-common-cmds.html</url>
    <content type="text"><![CDATA[1. lsof: 根据端口号查监听的进程号参考 使用模型：lsof -i :port 已知某服务占用8088端口，请查出使用该端口的进程号 1lsof -i :8088 lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。lsof命令详情 2. grep: 搜索神器参考： GNU Grep 3.0123456789101112131415161718--color:高亮显示匹配到的字符串-v：显示不能被pattern匹配到的-i：忽略字符大小写-o：仅显示匹配到的字符串-q：静默模式，不输出任何信息-A#：after，匹配到的后#行-B#：before，匹配到的前#行-C#：context，匹配到的前后各#行-E：使用ERE，支持使用扩展的正则表达式－c：只输出匹配行的计数。－I：不区分大 小写(只适用于单字符)。－h：查询多文件时不显示文件名。－l：查询多文件时只输出包含匹配字符的文件名。－n：显示匹配行及 行号。- m: 匹配多少个关键词之后就停止搜索－s：不显示不存在或无匹配文本的错误信息。－v：显示不包含匹配文本的所有行。 2.1. 普通：搜索trace.log 中含有ERROR字段的日志grep ERROR trace.log 2.2. 输出文件：可以将日志输出文件中grep ERROR trace.log &gt; error.log 2.3. 反向：搜索不包含ERROR字段的日志grep -v ERROR trace.log 2.4. 向前：搜索包含ERROR,并且显示ERROR前10行的日志grep -B 10 ERROR trace.log 2.5. 向后：搜索包含ERROR字段，并且显示ERROR后10行的日志grep -A 10 ERROR trace.log 2.6. 上下文：搜索包含ERROR字段，并且显示ERROR字段前后10行的日志grep -C 10 ERROR trace.log 2.7. 多字段：搜索包含ERROR和DEBUG字段的日志gerp -E &#39;ERROR|DEBUG&#39; trace.log 2.8. 多文件：从多个.log文件中搜索含有ERROR的日志grep ERROR *.log 2.9. 省略文件名：从多个.log文件中搜索ERROR字段日志，并不显示日志文件名从多个文件中搜索的日志默认每行会带有日志文件名 grep -h ERROR *.log 2.10. 时间范围： 按照时间范围搜索日志awk &#39;$2&gt;&quot;17:30:00&quot; &amp;&amp; $2&lt;&quot;18:00:00&quot;&#39; trace.log日志形式如下, $2代表第二列即11:44:58, awk需要指定列111-21 16:44:58 /user/info/ 2.11. 有没有：搜索到第一个匹配行后就停止搜索grep -m 1 ERROR trace.log 2.12. 行数统计: 统计ERROR出现了多少行grep -c ERROR trace.log 2.13. 单词统计：统计ERROR出现了多少次grep -c ERROR trace.log | wc -w 3. wc：单词统计4. 参考文献 Linux工具快速教程]]></content>
      <tags>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猴子都能懂的教程：向kindle推送电子书]]></title>
    <url>%2Fsend-book-to-kindle.html</url>
    <content type="text"><![CDATA[原文链接 读书，嗯，读书 1. 教程目的 通过邮件向kindle推送一本电子书 2. 前期准备 一台可以上网的电脑 一个电子书 一个kindle 3. 你的kindle邮箱是什么？ 登录亚马逊，地址：https://www.amazon.cn/ref=nav_logo 鼠标移动到导航栏上的我的账户 点击下拉框中的：管理我的内容和设备 会出现下面tab页面 =&gt; 设置 =&gt; 个人文档设置 =&gt; 里面会有电子邮件地址 里面的邮箱即为你邮件发送的收件方地址。例如：abcd@kindle.cc 4. 如何设置邮箱白名单？并不是所有邮件都能发送到abcd@kindle.cc, 需要在上一步的同一个页面设置已认可的发件人电子邮箱, 只有来自认可的邮箱的电子书，亚马逊才会接受。你需要添加认可的电子邮箱。例如发件的邮箱写为：abcd@qq.com 5. 邮件该怎么写？必须使用上一步白名单里面的邮箱来发送 收件人写你的kindle邮箱 主题写：Convert 在邮件的附件中添加准备好的电子书 点击发送 6. 在哪里查找已经发送的电子书？ 还是在管理我的内容和设备页面 点击我的内容 在显示中选择：个人文档 例如你可以在截图中看到，我刚刚上传的一本：you dont konw js 如果没有找到你已经发送的书籍，请再次检查一下，你的kindle邮箱和白名单中的邮箱是否正确 7. 如何向kindle推送电子书紧接着上一步. 选择要发送的书籍 点击发送 在出现的弹出框中，在下拉框中选择你的kindle设备 点击发送 kindle链接WiFi，进入我的图书馆，点击设备，同步 8. 使用体验的思考？之前用多看阅读，WIFI传书非常方便。kindle的上传图书其实蛮复杂的，过程中可能直接过滤掉一些用户。 我在想为什么亚马逊不在：管理我的内容和设备页面添加一个上传图书的按钮呢？ 9. 重点划线 一封电子邮件最多只能包含25个附件，并且最多只能发送至15个不同的〖发送至Kindle〗电子邮箱。文档的总大小不得超过50MB。 在电子邮件主题中输入“Convert”以将您的文档转换为Kindle格式，然后再将其发送至您的设备以及【管理我的内容和设备】页面中的【我的内容】 如果您的设备或阅读软件暂时无法连接无线网络，我们最多可以为您保存个人文档60天 Kindle个人文档服务支持以下文件类型： Kindle格式（.MOBI、.AZW） Microsoft Word（.DOC、.DOCX） HTML（.HTML、.HTM） RTF (.RTF) Text (.TXT) (Kindle X 咪咕电子书阅读器不支持) JPEG（.JPEG、.JPG） GIF (.GIF) PNG (.PNG) BMP (.BMP) PDF (.PDF) 建议您在发送文件之前将文件名改成英文 10. 参考文档 使用您的〖发送至Kindle〗电子邮箱 添加用于接收文档的电子邮箱 Kindle个人文档服务 Kindle个人文档服务使用条件]]></content>
      <tags>
        <tag>kindle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查询字符串的最小数据集]]></title>
    <url>%2Fquery-string-mds.html</url>
    <content type="text"><![CDATA[1. 什么是查询字符串？给个例子： 1https://en.wikipedia.org/w/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector 查询字符串是url中问号后边的部分，形式如：key1=value1&amp;key2=value2&amp;key3=value3。这部分称为查询(query)组件。 2. 查询组件的最小数据集 参数名： 是否必须： 是否是精确查询： 描述： 示例：必须要有，比如说如果查询的是一个时间。那么时间的格式有很多种，务必给出示例 约束： 字符串：最小长度，最大长度。[3,10] 数值型：取值区间。[4, 10] 枚举型：枚举字符串。1代表男，0代表女 3. 举例说明：一个用户查询的接口 参数名 是否必须 是否是精确查询 描述 示例 约束 email 否 是 邮箱 test@tt.cc 长度：[6, 10] age 否 是 年龄 18 取值：[0, 110] gender 否 是 性别 1 1代表男，0代表女 userName 否 否 用户名 alex 长度：[4, 40] token 是 是 认证令牌 90sdflkajf0asdflkja 长度：60 registerBeginTime 否 是 开始注册时间，返回的结果都是该时间以后的数据 2018-09-20 17:23:00 长度：19 很多资源 4. 参考 wikipedia:Query_string]]></content>
      <tags>
        <tag>docs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写好接口文档？]]></title>
    <url>%2Fhow-to-write-better-api-docs.html</url>
    <content type="text"><![CDATA[1. HTTP携带信息的方式 url headers body: 包括请求体，响应体 2. 分离通用信息一般来说，headers里的信息都是通用的，可以提前说明，作为默认参数 3. 路径中的参数表达式URL中参数表达式使用{}的形式，参数包裹在大括号之中{paramName} 例如： /api/user/{userId} /api/user/{userType}?age={age}&amp;gender={gender} 4. 数据模型定义数据模型定义包括： 路径与查询字符串参数模型 请求体参数模型 响应体参数模型 数据模型的最小数据集： 名称 是否必须 说明 “最小数据集”（MDS）是指通过收集最少的数据，较好地掌握一个研究对象所具有的特点或一件事情、一份工作所处的状态，其核心是针对被观察的对象建立起一套精简实用的数据指标。最小数据集的概念起源于美国的医疗领域。最小数据集的产生源于信息交换的需要，就好比上下级质量技术监督部门之间、企业与质量技术监督部门之间、质量技术监督部门与社会公众之间都存在着信息交换的需求。 一些文档里可能会加入字段的类型，但是我认为这是没必要的。以为HTTP传输的数据往往都需要序列化，大部分数据类型都是字符串。一些特殊的类型，例如枚举类型的字符串，可以在说明里描述。 另外：数据模型非常建议使用表格来表现。 举个栗子🌰： 名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 age 否 用户年龄 gender 否 用户性别。1表示男，0表示女 5. 请求示例123456789101112131415// general POST http://www.testapi.com/api/user// request payload&#123; "name": "qianxun", "age": 14, "like": ["music", "reading"], "userType": "vip"&#125;// response&#123; "id": "asdkfjalsdkf"&#125; 6. 异常处理异常处理最小数据集 状态码 说明 解决方案 举个栗子🌰： 状态码 说明 解决方案 401 用户名密码错误 检查用户名密码是否正确 424 超过最大在线数量 请在控制台修改最大在线数量 之前我一直不想把解决方案加入异常处理的最小数据集，但是对于很多开发者来说，即使它知道424代表超过最大在线数量。如果你不告诉如果解决这个问题，那么他们可能就会直接来问你。所以最好能够一步到位，直接告诉他应该如何解决，这样省时省力。 7. 如何组织？7.1. 一个创建用户的例子：创建用户1 请求示例1234567891011121314// general POST http://www.testapi.com/api/user/vip/?token=abcdefg// request payload&#123; "name": "qianxun", "age": 14, "like": ["music", "reading"]&#125;// response&#123; "id": "asdkfjalsdkf"&#125; 2 路径与查询字符串参数模型 POST http://www.testapi.com/api/user/{userType}/?token={token} 名称 是否必须 说明 userType 是 用户类型。commom表示普通用户，vip表示vip用户 token 是 认证令牌 3 请求体参数模型 名称 是否必须 说明 name 是 用户名。4-50个字符 age 否 年龄 like 否 爱好。最多20个 4 响应体参数模型 名称 说明 id 用户id 5 异常处理 状态码 说明 解决方案 401 token过期 请重新申请token 424 超过最大在创建人数 请在控制台修改最大创建人数 7.2. 这样组织的原因 请求示例: 请求示例放在第一位的原因是，要用最快的方式告诉开发者，这个接口应该如何请求 路径与查询字符串参数模型： 使用mustache包裹参数 请求体参数模型：如果没有请求体，可以不写 响应体参数模型： 异常处理 8. 文档提供的形式文档建议由一下两种形式，在线文档，pdf文档。 在线文档 更新方便 易于随时阅读 易于查找 pdf文档 内容表现始终如一，不依赖文档阅读器 文档只读，不会被轻易修改 其中由于是面对第三方开发者，公开的在线文档必须提供；由于某些特殊的原因，可能需要提供文件形式的文档，建议提供pdf文档。当然，以下的文档形式是非常不建议提供的： word文档 markdown文档 word文档和markdown文档有以下缺点： 文档的表现形式非常依赖文档查看器：各个版本的word文档对word的表现形式差异很大，可能在你的电脑上内容表现很好的文档，到别人的电脑上就会一团乱麻；另外markdown文件也是如此。而且markdown中引入文件只能依靠图片链接，如果文档中含有图片，很可能会出现图片丢失的情况。 文档无法只读：文档无法只读，就有可能会被第三方开发者在不经意间修改，那么文档就无法保证其准确性了。 总结一下，文档形式的要点： 只读性：保证文档不会被开发者轻易修改 一致性：保证文档在不同设备，不同文档查看器上内容表现始终如一 易于版本管理：文档即软件（DAAS: Document as a Software），一般意义上说软件 = 数据 + 算法, 但是我认为文档也是一种组成软件的重要形式。既然软件需要版本管理，文档的版本管理也是比不可少的。]]></content>
      <tags>
        <tag>接口文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费服务的盈利模式]]></title>
    <url>%2Fhow-free-server-make-money.html</url>
    <content type="text"><![CDATA[免费产品的盈利模式有四种 投放广告 增值服务：先把羊养肥，再慢慢割羊毛，现在大部分都是互联网服务都是这种 交叉补贴: A服务免费，再用户使用A服务时，通过提供B服务来盈利 零边际成本：免费提供A服务，但是用户需要用物品去交换A服务，服务提供者通过加工物品来盈利]]></content>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ztree-note]]></title>
    <url>%2Fztree-note.html</url>
    <content type="text"><![CDATA[1. ztree获得顶层节点1treeObj.getNodesByParam('level',0,null);]]></content>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkpad 系列恢复F1-F12原始功能，切换ctrl和fn的位置]]></title>
    <url>%2Fthinkpad-f1-f12.html</url>
    <content type="text"><![CDATA[1. 实验准备 T450笔记本 2. 进入BIOS 重启电脑 一直不停按enter 按F1 选择Keyboard/mouse 3. 恢复F1-F2恢复原始功能:fn and ctrl key swap [enabled] 4. 切换ctrl和ctrl的位置:F1-F12 as primary function [enabled] 5. 保存，退出]]></content>
      <tags>
        <tag>thinkpad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚌埠出入境管理局电话以及相关注意事项]]></title>
    <url>%2Fgoverment-info.html</url>
    <content type="text"><![CDATA[1. 相关地址信息1.1. 蚌埠市公安局出入境接待大厅办公地址：蚌埠市南湖路600号咨询电话：0552-2089266投诉电话：0552-2089269节假日值班电话：0552-2089266工作时间：周一至周五：上午8:00-12:00，下午14:30-17:30； 1.2. 蚌埠市五河县公安局出入境接待大厅办公地址：五河县城关镇淮河路40号咨询电话：0552-5057155投诉电话：0552-5057155节假日值班电话：0552-5057155工作时间：周一至周五：上午8：00-12：00，下午：14：30-17：30 1.3. 蚌埠市怀远县公安局出入境接待大厅办公地址：怀远县禹王路中段咨询电话：0552-8027123投诉电话：0552-8027123节假日值班电话：0552-8027123工作时间：周一至周五：上午8：00-12：00，下午：14：30-17：30； 1.4. 蚌埠市固镇县公安局出入境接待大厅办公地址：固镇县谷阳路中段咨询电话：0552-6075830投诉电话：0552-6075830节假日值班电话：0552-6075830工作时间：周一至周五：上午8:00-12:00，下午14:30-17:30； 2. 注意事项2.1. 准备材料 身份证 银行卡(有些费用只能用银行卡支付) 零钱 2.2. 其他事项 一般来说签证10天后才能办好，可以申请寄送服务 不要在将近中午的时候去办证，他们中午休息时间蛮长的 办证前，可以打电话问问本地是支持团签还是个签 3. 注意以上信息不能保证时效性，如果电话或者地址不存在，请自行查询。]]></content>
      <tags>
        <tag>蚌埠</tag>
        <tag>出入境管理局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win7 ie11 开发者工具打开后一片空白]]></title>
    <url>%2Fie11-without-devtool.html</url>
    <content type="text"><![CDATA[解决方法安装Windows7补丁：KB3008923；下载地址：http://www.microsoft.com/en-us/download/details.aspx?id=45134 （32位）http://www.microsoft.com/zh-CN/download/details.aspx?id=45154 （64位）]]></content>
      <tags>
        <tag>ie11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 服务管理指令]]></title>
    <url>%2Fcentos7-service-manager.html</url>
    <content type="text"><![CDATA[功能 命令 使服务开启启动 systemctl enable httpd.service 关闭服务开机启动 systemctl disabled httpd.service 检查服务状态 systemctl status httpd.service 查看所有已启动的服务 systemctl list-units –type=service 启动服务 systemctl start httpd.service 停止服务 systemctl stop httpd.service 重启服务 systemctl restart httpd.service]]></content>
      <tags>
        <tag>centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSTA 呼叫模型简介]]></title>
    <url>%2Fcsta-call-model-overview.html</url>
    <content type="text"><![CDATA[1. 内容概要 CSTA协议与标准概述 CSTA OpenScape 语音架构概述 2. CSTA协议标准2.1. 什么是CSTA ? CSTA：电脑支持通讯程序(Computer Supported TelecommunicationsApplications) 基本的呼叫模型在1992建立，后来随着行业发展，呼叫模型也被加强和扩展，例如新的协议等等 CSTA是一个应用层接口，用来监控呼叫，设备和网络 CSTA创建了一个通讯程序的抽象层: CSTA并不依赖任何底层的信令协议 E.g.H.323,SIP,Analog,T1,ISDN,etc. CSTA并不要求用户必须使用某些设备 E.g.intelligentendpoints,low-function/stimulusdevices,SIPSignalingmodels-3PCC vs. Peer/Peer 适用不同的操作模式 第三方呼叫控制 一方呼叫控制 CSTA的设计目标是为了提高各种CSTA实现之间的移植性 规范化呼叫模型和行为 完成服务、事件定义 规范化标准 3. CSTA 标准的进化史 阶段1 (发布于 June ’92) 40 特性, 66 页 (服务定义) 专注于呼叫控制 阶段2 (发布于 Dec. ’94) 77 特性, 145 页 (服务定义) I/O &amp; 语音单元服务, 更多呼叫控制服务 阶段3 - CSTA Phase II Features &amp; versit CTI Technology 发布于 Dec. ‘98 136 特性, 650 页 (服务定义) 作为ISO 标准发布于 July 2000 发布 CSTA XML (ECMA-323) June 2004 发布 “Using CSTA with Voice Browsers” (TR/85) Dec. 02 发布 CSTA WSDL (ECMA-348) June 2004 June 2004: 发布对象模型 TR/88 June 2004: 发布 “Using CSTA for SIP Phone User Agents (uaCSTA)” TR/87 June 2004: 发布 “Application Session Services” (ECMA-354) June 2005: 发布 “WS-Session: WSDL for ECMA-354”(ECMA-366) December 2005 : 发布 “Management Notification and Computing FunctionServices” December 2005 : Session Management, Event Notification, Amendements for ECMA-348” (TR/90) December 2006 : Published new editions of ECMA-269, ECMA-323, ECMA-348 4. CSTA 标准文档 5. CSTA 标准扩展 新的特性可以被加入标准通过发布新版本的标准 新的参数，新的值可以被加入通过发布新版本的标准 未来的新版本必须下向后兼容 具体的实施可以增加属性通过CSTA自带的扩展机制(e.g. ONS – One Number Service) 6. CSTA 操作模型 CSTA操作模型由计算域和转换域组成，是CSTA定义在两个域之间的接口 CSTA标准规定了消息（服务以及事件上报）,还有与之相关的行为 计算域是CSTA程序的宿主环境，用来与转换域交互与控制 转换域 - CSTA模型提供抽象层，程序可以观测并控制的。转换渔包括一些对象例如CSTA呼叫，设备，链接。 7. CSTA 操作模型：呼叫，设备，链接 相关说明是的的的的 8. 参考 CSTAoverview CSTA_introduction_and_overview]]></content>
      <tags>
        <tag>csta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh 无密码登录远程服务器]]></title>
    <url>%2Fssh-login-without-password.html</url>
    <content type="text"><![CDATA[1. 前提说明A(本机 mac item2)B(远程机器 ip:a.b.c.d centos) 2. 过程13. 生成public_key与private_key在本机上输入，可以一路回车，不用说明1ssh-keygen -t rsa 最终会在~/.ssh/下生成两个文件12id_rsaid_rsa.pub 4. 将public_key上传到远程服务器注意：在本机上输入12// 回车之后，需要输入远程主机B的登录密码scp ~/.ssh/id_rsa.pub root@a.b.c.d:/root/.ssh 5. 登录远程主机在本机上输入1234567891011// 需要输入远程主机的密码ssh root@a.b.c.d// 进到远程主机~/.ssh/目录下, 此目录下应该已经有了之前上传的id_rsa.pub文件// 如果目录下没有authorized_keys文件，那么将id_rsa.pub改名成authorized_keysmv id_rsa.pub authorized_keys// 如果远程目录下已经存在authorized_keys文件，可以将id_rsa.pub追加进去cat id_rsa.pub &gt;&gt; authorized_keys 6. 本机配置注意，此时需要退出ssh, 在本机上执行以下命令123456789vi ~/.ssh/config在config文件中追加以下内容，并保存退出Host serverNameHostname a.b.c.dPort 22User rootIdentityFile ~/.ssh/id_rsa 然后试一下，只需要ssh serverName, 就可以直接登录远程服务器，是不是很爽 7. 参考文献 scp 命令教程 mac用iterm2实现ssh，怎么像SecureCRT一样保存IP和账号密码？ 8. 精华推荐最后推荐一本非常好的linux常用命令手册，非常不错哦。 Linux下有很多命令行工具供我们使用，每个工具总是提供了大量参数供我们选择； 实际工作中，我们用到的工具，最常用的总是那么几个参数组合； 为此，我写了这本书相对实用的书； 这本书专注于Linux工具的最常用用法，以便读者能以最快时间掌握，并在工作中应用； 《Linux工具快速教程》]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组织在召唤：如何免费获取一个js.org的二级域名]]></title>
    <url>%2Fhow-to-get-jsorg-sub-domain.html</url>
    <content type="text"><![CDATA[之前我是使用wangduanduan.github.io作为我的博客地址，后来觉得麻烦，有把博客关了。最近有想去折腾折腾。先看效果：wdd.js.org 如果你不了解js.org可以看看我的这篇文章:一个值得所有前端开发者关注的网站js.org 1. 前提 已经有了github pages的一个博客，并且博客中有内容，没有内容会审核不通过的。我第一次申请域名，就是因为内容太少而审核不通过。 2. 想好自己要什么域名？比如你想要一个：wdd.js.org的域名，你先在浏览器里访问这个地址，看看有没有人用过，如果已经有人用过，那么你就只能想点其他的域名了。 3. fork js.org的项目，添加自己的域名1 fork https://github.com/js-org/dns.js.org2 修改你fork后的仓库中的cnames_active.js文件，加上自己的一条域名，最好要按照字母顺序 如下图所示，我在第1100行加入。注意，不要在该行后加任何注释。1"wdd": "wangduanduan.github.io", 3 commit 4. 加入CNAME文件我是用hexo和next主题作为博客的模板。其中我在gh-pages分支写博客，然后部署到master分支。 我在我的gh-pages分支的source目录下加入CNAME文件, 内容只有一行 1wdd.js.org 将博客再次部署好，如果CNAME生效的话，你已经无法从原来的地址访问：wangduanduan.github.io， 这个博客了。 5. 向js.org项目发起pull-request找到你fork后的项目，点击 new pull request, 向原来的项目发起请求。 然后你可以在js-org/dns.js.org项目的pull requests看到你的请求，当这个请求被合并时，你就拥有了js.org的二级域名。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>jsorg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不常用却很有妙用的事件及方法]]></title>
    <url>%2Fbrowser-events.html</url>
    <content type="text"><![CDATA[1. visibilitychange事件触发条件：浏览器标签页被隐藏或显示的时候会触发visibilitychange事件. 使用场景：当标签页显示或者隐藏时，触发一些业务逻辑 123document.addEventListener("visibilitychange", function() &#123; console.log( document.visibilityState );&#125;); 2. storage事件触发条件：使用localStorage or sessionStorage存储或者修改某个本地存储时 使用场景：标签页间通信 123456789// AB页面同源// 在A 页面window.addEventListener('storage', (e) =&gt; &#123;console.log(e)&#125;)// 在B 页面，向120打个电话localStorage.setItem('makeCall','120')// 然后可以在A页面间有输出, 可以看出A页面 收到了B页面的通知...key: "makeCall", oldValue: "119", newValue: "120", ... 3. beforeunload事件触发条件：当页面的资源将要卸载(及刷新或者关闭标签页前). 当页面依然可见，并且该事件可以被取消只时 使用场景：关闭或者刷新页面时弹窗确认，关闭页面时向后端发送报告等 123456window.addEventListener("beforeunload", function (e) &#123; var confirmationMessage = "\o/"; e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+ return confirmationMessage; // Gecko, WebKit, Chrome &lt;34&#125;); 4. navigator.sendBeacon这个方法主要用于满足 统计和诊断代码 的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。过早的发送数据可能导致错过收集数据的机会。然而， 对于开发者来说保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在卸载事件处理器中产生的异步 XMLHttpRequest 。 使用 sendBeacon() 方法，将会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：使它可靠，异步并且不会影响下一页面的加载。此外，代码实际上还要比其他技术简单！ 注意：该方法在IE和safari没有实现 使用场景：发送崩溃报告 12345window.addEventListener('unload', logData, false);function logData() &#123; navigator.sendBeacon("/log", analyticsData);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nodejs 服务端框架合集(78个)]]></title>
    <url>%2Fnodejs-server-frameworks.html</url>
    <content type="text"><![CDATA[没有什么事情是一个框架解决不了的，如果有，就再找一个。 Photo by 贝莉儿 NG on Unsplash 1. MVC frameworks2. Sinatra-like这些框架提供了丰富的配置，比Rails-like或full-stack少。 Express hapi flatiron locomotive total.js koa.js TWEE.IO diet.js Flicker.js ZinkyJS 2.1. Rails-like正确呈现您的项目。从包含的模板创建自己的艺术 Nodal Strapi CompoundJS geddy Sails.js Adonis RhapsodyJS ThinkJS Trails KambojaJS JS-Web 3. Full-stack frameworks这就是Node.js真正闪耀的地方。全栈MVC框架与脚手架，模板引擎，websocket和持久性库捆绑在一起，允许您构建实时可伸缩的Web应用程序。 Catberry.js AllcountJS Derby Feathers SocketCluster SocketStream MEAN.js MEAN.io Meteor Meatier TWEE.IO Mojito Seeds.js SANE COKE Sleekjs Danf Catberry Nuke.js We.js seneca.js Keystone.js Horizon Apogeu 4. REST API frameworks对于那些使用富客户端/前端MVC框架（或不）的客户，只需要启动一个快速的Node.js REST API服务器即可。 Ivy Restocat actionHero.js Frisby restling restify restmvc percolator LoopBack Fortune.js facet Raddish Restberry Gugamarket Nest microlet Moleculer 5. Other libraries中间件，库和静态站点生成器。 Connect Kraken ewdGateway2 Wintersmith docpad Blacksmith romulus Petrify Tower.js Impress Rendr Backnode Sequelize Cylon.js Virgilio.js SHPS]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[You-Dont-Need 你不需要系列]]></title>
    <url>%2Fyou-dont-need.html</url>
    <content type="text"><![CDATA[1. You-Dont-Need-JavaScript CSS是强大的，你可以做很多事情没有JS。 本文教你使用原生CSS做下面的事情。 内容目录 手风琴/切换 圆盘传送带 检查复选框的计数器 翻转点击 Textfield上的浮动标签 字体（拉丁） 游戏 悬停/弹出信息 图片廊 菜单 移动菜单关闭画布 汉堡菜单 花式菜单 莫代尔/弹出 鼠标跟踪 视差滚动 标签 待办事项列表 提示 树视图 Twitter心动画 动态图像着色 连锁反应 响应式计数器显示不适合屏幕的项目数量 可以看一下纯CSS的例子 2. You-Dont-Need-Lodash-Underscore Lodash和Underscore是伟大的现代JavaScript实用程序库，它们被前端开发人员广泛使用。但是，如果您将目标锁定为现代浏览器，则可能会发现，许多方法已经得到ES5和ES6的原生支持。如果你想要你的项目需要更少的依赖，并且你清楚的知道你的目标浏览器，那么你可能不需要Lodash / Underscore。 来自开发者的声音 在代码变臃肿之前，请使用原生JS对象和数组工具函数. —Cody Lindley, Author of jQuery Cookbook and JavaScript Enlightenment 你可能不需要lodash. 有许多好用的原生方法了. —Daniel Lamb, Computer Scientist, Technical Reviewer of Secrets of the JavaScript Ninja and Functional Programming in JavaScript 我想不是，但我想要它. —Tero Parviainen, Author of build-your-own-angular 我承认，我曾经过度使用lodash. —@therebelrobot, Maker of web things, Facilitator for Node.js/io.js 内容目录 Array _.compact _.concat _.fill _.find _.findIndex _.first _.flatten _.flattenDeep .head and .tail _.indexOf _.join _.last _.lastIndexOf _.reverse _.without _.slice _.isArray Collection _.each _.every _.filter _.groupBy _.includes _.map .minBy and .maxBy _.pluck _.range _.reduce _.reduceRight _.size _.some Function _.after Lang _.isNaN Object _.assign _.keys _.toPairs _.values String _.repeat _.template _.toLower _.toUpper _.trim _.replace 3. You-Dont-Need-jQuery纯JavaScript的例子, 实现做jQuery与查询，样式，dom，ajax，事件等 前端发展很快，现代浏览器原生 API 已经足够好用。我们并不需要为了操作 DOM、Event 等再学习一下 jQuery 的 API。同时由于 React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。本项目总结了大部分 jQuery API 替代的方法，暂时只支持 IE10 以上浏览器。 内容目录 Translations Query Selector CSS &amp; Style DOM Manipulation Ajax Events Utilities Promises Animation Alternatives Browser Support 4. You-Dont-Need-GUI图形用户界面对计算机用户非常友好。它们被引入以响应命令行界面（CLI）感知的陡峭学习曲线。 但是，他们往往需要更多的资源，功能不强，难以通过脚本自动化。 作为计算机专家，我们希望更高效，更好地完成工作。我们知道命令字可能不容易被发现或助记符，所以我们尝试列出一些您可能试图在GUI中执行的常见任务。 内容目录 复制一个文件 复制一个文件 复制一个文件夹 复制一个文件夹 移动一个文件 重命名一个文件 移动一个文件夹 重命名文件夹 合并文件夹 创建一个新的文件 新建一个文件夹 显示文件/文件夹大小 用默认程序打开一个文件 压缩一个文件夹 解压缩文件夹 删除一个文件 删除一个文件夹 列出文件夹内容 树查看文件夹及其子文件夹 找到一个陈旧的文件 显示一个日历 找到未来的日期 使用计算器 强制退出程序]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nodejs alpine 基础docker镜像构建]]></title>
    <url>%2Fnodejs-alpine-docker.html</url>
    <content type="text"><![CDATA[1. 系统环境 centos7 内核：3.10.0-514.26.2.el7.x86_64 安装docker要求内核版本不低于3.10 2. 安装docker123yum install docker // 安装dockersystemctl start docker.service // 启动dockersystemctl enable docker.service // 设置开机启动 3. Nodejs 镜像选择 REPOSITORY TAG IMAGE ID CREATED SIZE docker.io/node 9.2.1-slim 69c9f9292fa4 3 days ago 230 MB docker.io/node 9.2.1-alpine afdc3aaaf748 3 days ago 67.46 MB docker.io/node latest 727b047a1f4e 3 days ago 675.6 MB docker.io/iron/node latest 9ca501065d18 20 months ago 18.56 MB 选择镜像的标准 官方的 经常维护的 体积小的 要有yarn 和 npm node版本要高 最终选择 node:9.2.1-alpine, 该镜像体积很小，已经内置npm(5.5.1), yarn(1.3.2) 4. 时区配置node:9.2.1-alpine的时区默认不是国内的，需要在build时，配置时区。 1234567891011FROM node:9.2.1-alpine# Install base packages and set timezone ShangHaiRUN apk update &amp;&amp; apk add bash tzdata \ &amp;&amp; cp -r -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime.........CMD [ "node" ] 验证：123456789➜ node-dockerfile git:(master) docker run -it e595 sh / # yarn -v1.3.2/ # npm -v5.5.1/ # node -vv9.2.1/ # dateTue Dec 12 17:33:26 CST 2017]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vscode中用standard style 风格去验证 vue文件]]></title>
    <url>%2Fvscode-vue-standardjs.html</url>
    <content type="text"><![CDATA[1. JavaScript Standard Style简介本工具通过以下三种方式为你（及你的团队）节省大量时间： 无须配置。 史上最便捷的统一代码风格的方式，轻松拥有。 自动代码格式化。 只需运行 standard –fix 从此和脏乱差的代码说再见。 提前发现风格及程序问题。 减少代码审查过程中反反复复的修改过程，节约时间。 无须犹豫。再也不用维护 .eslintrc, .jshintrc, or .jscsrc 。开箱即用。 安装：1npm i standard -g 关于JavaScript 代码规范, 你可以点击链接看一下。 2. 如何在vscode中用JavaScript Standard Style风格去验证 vue文件实际上JavaScript Standard Style有一个FAQ, 说明了如何使用。 但是有一点非常重要的作者没有提到，就是eslint-plugin-html这个插件必须要安装3.x.x版本的, 现在eslint-plugin-html, 已经升级到4.x版本，默认不写版本号安装的就是4.x版本的，所以会出现问题。参考 ESLint v4 is only supported by eslint-plugin-html v3, so you can’t use eslint-plugin-html v1.5.2 with it (I should add a warning about this when trying to use the plugin with an incompatible version on ESLint). If you do not use ESLint v4, please provide more information (package.json, a gist to reproduce, …) 1234567891011121314151617181920212223242526// FAQHow to lint script tag in vue or html files?You can lint them with eslint-plugin-html, just install it first, then enable linting for those file types in settings.json with: "standard.validate": [ "javascript", "javascriptreact", "html" ], "standard.options": &#123; "plugins": ["html"] &#125;, "files.associations": &#123; "*.vue": "html" &#125;,If you want to enable autoFix for the new languages, you should enable it yourself: "standard.validate": [ "javascript", "javascriptreact", &#123; "language": "html", "autoFix": true &#125; ], "standard.options": &#123; "plugins": ["html"] &#125; 3. 综上， 整理一下安装思路3.1. 需要安装哪些包？ npm i -g standard npm i -g eslint-plugin-html@3.2.2 必须是3x版本 npm i -g eslint以上三个包都是全局安装的，如果你想看看全局安装了哪些包可以用npm list -g --depth=0查看 3.2. vscode config 如何写？1234567891011121314"standard.validate": [ "javascript", "javascriptreact", &#123; "language": "html", "autoFix": true &#125;],"standard.options": &#123; "plugin": ["html"]&#125;,"files.associations": &#123; "*.vue": "html"&#125;, 3.3. 如何在保存文件时，自动使用standard格式化vue文件1"standard.autoFixOnSave": true 3.4. 如果还不行怎么办？ 重启一下vscode 重启一下电脑 在此文后追加评论]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>vue</tag>
        <tag>standardjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[油猴子脚本 - 我的地盘我做主]]></title>
    <url>%2Ftampermonkey.html</url>
    <content type="text"><![CDATA[当你用浏览器访问某个网页时，你可曾想过，你看到的这个网页，实际上是属于你自己的。 打个比喻：访问某个网站就好像是网购了一筐鸡蛋，鸡蛋虽然是养鸡场生产的，但是这个蛋我怎么吃，你养鸡场管不着。 当然了，对于很多人来说，鸡蛋没有别的吃法，鸡蛋只能煮着吃。 你可以看如下的页面：当你在某搜索引擎上搜索前端开发时 大多数人看到的页面是这样的, 满屏的广告，满屏的推广，满屏的排名，满屏的中间地址跳转，满屏的流量劫持, 还有莆田系 但是有些人的页面却是这样的：清晰，自然，链接直达，清水出芙蓉，天然去雕饰 这就是油猴子脚本干的事情， 当然，它能干的事情，远不止如此。它是齐天大圣孙悟空，有七十二变。 1. 什么是油猴子脚本？ Greasemonkey，简称GM，中文俗称为“油猴”，是Firefox的一个附加组件。它让用户安装一些脚本使大部分HTML为主的网页于用户端直接改变得更方便易用。随着Greasemonkey脚本常驻于浏览器，每次随着目的网页打开而自动做修改，使得运行脚本的用户印象深刻地享受其固定便利性。 Greasemonkey可替网页加入些新功能（例如在亚马逊书店嵌入商品比价功能）、修正网页错误、组合来自不同网页的数据、或者数繁不及备载的其他功能。写的好的Greasemonkey脚本甚至可让其输出与被修改的页面集成得天衣无缝，像是原本网页里的一部分。 来自维基百科 2. 如何安装油猴子插件？在google商店搜索Tampermonkey, 安装量最高的就是它。 3. 如何写油猴子脚本？油猴子脚本有个新建脚本页面，在此页面可以创建脚本。具体教程可以参考。 中文 GreaseMonkey 用户脚本开发手册 GreaseMonkey（油猴子）脚本开发 深入浅出 Greasemonkey Greasemonkey Hacks/Getting Started 4. 如何使用他人的脚本？greasyfork网站提供很多脚本，它仿佛是代码界的github, 可以在该网站搜到很多有意思的脚本。 5. 有哪些好用的脚本？ 有哪些超神的油猴脚本? 或者你可以在greasyfork网站查看一些下载量排行]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】一个值得所有前端开发者关注的网站 js.org]]></title>
    <url>%2Fjs-org.html</url>
    <content type="text"><![CDATA[二十年后，域js.org第一次注册，它终于服务于其明显的目的 - JavaScript社区。 从一开始，对JavaScript的看法各不相同 - 有些人喜欢的语言，有人讨厌它。但是，对于使JavaScript成为最受欢迎的编程语言之一的社区的威力，应该毫无疑问。为了与社区的自由开放的心态保持一致，JS.ORG为开发人员及其项目免费提供了子域名。自第一步以来，我们还专注于跟踪JavaScript趋势并传播有关它的新闻。 贡献是欢迎：如果你有热情开始一个合作项目，或者如果你想成为JS.ORG的成员，并贡献JS.ORG，随时与我联系。 1. DNS 如果您是JavaScript开发人员，您可能已经听说过 - 或者甚至已经使用GitHub页面来托管您的内容。 DNS.JS.ORG补充GitHub提供的免费网络空间，并提供了一个适合您项目的自由和时尚的网址。 2. STARTS STATS.JS.ORG获取GitHub上最重要的JavaScript项目的统计参数，并将它们填充到10k行的巨型表中。这个项目旨在使JavaScript的趋势可见。 3. NEWS你有什么东西要与社区分享或想阅读其他JavaScript爱好者的东西吗？ NEWS.JS.ORG提供了一种方便的传播，消费和讨论JavaScript项目。 4. WASMWebAssembly（或简称wasm）是一种用于Web平台上的低级代码的新的二进制语法。 WASM.NEWS是JS.ORG计划的一个分支，并作为这个即将到来的主题的新闻聚合。]]></content>
      <tags>
        <tag>js.org</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[追本溯源：substr与substring历史漫话]]></title>
    <url>%2Fsubstr-and-substring-history.html</url>
    <content type="text"><![CDATA[引子： 很多时候，当我要字符串截取时，我会想到substr和substring的方法，但是具体要怎么传参数时，我总是记不住。哪个应该传个字符串长度，哪个又应该传个开始和结尾的下标，如果我不去查查这两个函数，我始终不敢去使用它们。所以我总是觉得，这个两个方法名起的真是蹩脚。然而事实是这样的吗？ 看来是时候扒一扒这两个方法的历史了。 1. 基因追本溯源 在编程语言的历史长河中，曾经出现过很多编程语言。然而大浪淘沙，铅华洗尽之后，很多早已折戟沉沙，有些却依旧光彩夺目。那么stubstr与substring的DNA究竟来自何处？ 1950与1960年代 1954 - FORTRAN 1958 - LISP 1959 - COBOL 1964 - BASIC 1970 - Pascal 1967-1978：确立了基础范式 1972 - C语言 1975 - Scheme 1978 - SQL (起先只是一种查询语言，扩充之后也具备了程序结构) 1980年代：增强、模块、性能 1983 - C++ (就像有类别的C) 1988 - Tcl 1990年代：互联网时代 1991 - Python 1991 - Visual Basic 1993 - Ruby 1995 - Java 1995 - Delphi (Object Pascal) 1995 - JavaScript 1995 - PHP 2009 - Go 2014 - Swift (编程语言) 1.1. 在C++中首次出现substr() 在c语言中，并没有出现substr或者substring方法。然而在1983，substr()方法已经出现在C++语言中了。然而这时候还没有出现substring, 所以可以见得：substr是stustring的老大哥 1string substr (size_t pos = 0, size_t len = npos) const; 从C++的方法定义中可以看到, substr的参数是开始下标，以及字符串长度。 12std::string str="We think in generalities, but we live in details.";std::string str2 = str.substr (3,5); // "think" 1.2. 在Java中首次出现substring() 距离substr()方法出现已经有了将近十年之隔，此间涌现一批后起之秀，如: Python, Ruby, VB之类，然而他们之中并没有stustring的基因，在Java的String类中，我们看到两个方法。从这两个方法之中我们可以看到：substring方法基本原型的参数是开始和结束的下标。 1234String substring(int beginIndex) // 返回一个新的字符串，它是此字符串的一个子字符串。String substring(int beginIndex, int endIndex)// 返回一个新字符串，它是此字符串的一个子字符串。 2. JavaScript的历史继承 1995年，网景公司招募了Brendan Eich，目的是将Scheme编程语言嵌入到Netscape Navigator中。在开始之前，Netscape Communications与Sun Microsystems公司合作，在Netscape Navigator中引入了更多的静态编程语言Java，以便与微软竞争用户采用Web技术和平台。网景公司决定，他们想创建的脚本语言将补充Java，并且应该有一个类似的语法，排除采用Perl，Python，TCL或Scheme等其他语言。为了捍卫对竞争性提案的JavaScript的想法，公司需要一个原型。 1995年5月，Eich在10天内写完。 上帝用七天时间创造万物, Brendan Eich用10天时间创造了一门语言。或许用创造并不合适，因为JavaScript是站在了Perl，Python，TCL或Scheme等其他巨人的肩膀上而产生的。 JavaScript并不像C那样出身名门，在贝尔实验室精心打造，但是JavaScript在往后的自然选择中，并没有因此萧条，反而借助于C,C++, Java, Perl，Python，TCL, Scheme优秀基因，进化出更加强大强大的生命力。 因此可以想象，在10天之内，当Brendan Eich写到String的substr和substring方法时，或许他并没困惑着两个方法的参数应该如何设置，因为在C++和Java的实现中，已经有了类似的定义。 如果你了解历史，你就不会困惑现在。 3. 所以，substr和substring究竟有什么不同？如下图所示：substr和substring都接受两个参数，他们的第一个参数的含义是相同的，不同的是第二个参数。substr的第二个参数是到达结束点的距离，substring是结束的位置。 4. 参考文献 维基百科：程式語言歷史 C++ std::string::substr JavaScript 如有不正确的地方，欢迎指正。]]></content>
      <tags>
        <tag>substr</tag>
        <tag>substring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熟练使用使用jQuery Promise (Deferred)]]></title>
    <url>%2Fjquery-deferred.html</url>
    <content type="text"><![CDATA[1. 情景再现以前用nodejs写后端程序时，遇到Promise这个概念，这个东西好呀！不用谢一层一层回调，直接用类似于jQuery的连缀方式。后来遇到bluebird这个库，它就是Promise库中很有名的。我希望可以把Promise用在前端的ajax请求上，但是我不想又引入bluebird。后来发现，jquery本身就具有类似于Promise的东西。于是我就jquery的Promise写一些异步请求。 2. 不堪回首看看一看我以前写异步请求的方式12345678910111213141516171819202122// 函数定义function sendRequest(req,successCallback,errorCallback)&#123; $.ajax(&#123; ... ... success:function(res)&#123; successCallback(res); &#125;, error:function(res)&#123; errorCallback(res); &#125; &#125;);&#125;// 函数调用,这个函数的匿名函数写的时候很容易出错，而且有时候难以理解sendRequest(req,function(res)&#123; //请求成功 ...&#125;,function(res)&#123; //请求失败 ...&#125;); 3. 面朝大海下面是我希望的异步调用方式123456789sendRequest(req).done(function(res)&#123; //请求成功 ...&#125;).fail(function(req)&#123; //请求失败 ...&#125;); 4. 废话少说，放‘码’过来 talk is cheap, show me the code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 最底层的发送异步请求，做成Promise的形式App.addMethod('_sendRequest',function(path,method,payload)&#123; var dfd = $.Deferred(); $.ajax(&#123; url:path, type:method || "get", headers:&#123; sessionId:session.id || '' &#125;, data:JSON.stringify(payload), dataType:"json", contentType : 'application/json; charset=UTF-8', success:function(data)&#123; dfd.resolve(data); &#125;, error:function(data)&#123; dfd.reject(data); &#125; &#125;); return dfd.promise();&#125;);//根据callId查询录音文件，不仅仅是异步请求可以做成Promise形式，任何函数都可以做成Promise形式App.addMethod('_getRecordingsByCallId',function(callId)&#123; var dfd = $.Deferred(), path = '/api/tenantcalls/'+callId+'/recordings'; App._sendRequest(path) .done(function(res)&#123;dfd.resolve(res);&#125;) .fail(function(res)&#123;dfd.reject(res);&#125;); return dfd.promise();&#125;);// 获取录音App.addMethod('getCallDetailRecordings',function(callId)&#123; App._getRecordingsByCallId(callId) .done(function(res)&#123; // 获取结果后渲染数据 App.renderRecording(res); &#125;) .fail(function(res)&#123; App.error(res); &#125;);&#125;); 5. 注意事项 jQuery的Promise主要是用了jQquery的$.Derferred()方法，一些老版本的jquery并不支持此方法。 jQuery版本必须大于等于1.5，推荐使用1.11.3 6. 参考文献 jquery官方api文档 jquery维基百科文档 7. 最后以上文章仅供参考，不包完全正确。欢迎评论，3q。]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的JavaScript最佳实践]]></title>
    <url>%2Fjsbestpractices.html</url>
    <content type="text"><![CDATA[为了避免维护多份文档，我将这篇文档放置于：https://wdd.js.org/js-best-practices/#/]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
